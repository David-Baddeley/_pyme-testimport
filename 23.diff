
--- ./PYME/Acquire/MetaDataHandler.py	(original)
+++ ./PYME/Acquire/MetaDataHandler.py	(refactored)


@@ -294,7 +294,7 @@
         elif isinstance(value, str):
             node.setAttribute('class', 'str')
             node.setAttribute('value', value)
-        elif isinstance(value, unicode):
+        elif isinstance(value, str):
             node.setAttribute('class', 'unicode')
             node.setAttribute('value', value)
         elif np.isscalar(value):

 



              

       




--- ./PYME/Acquire/Hardware/AndorNeo/plotTimings.py	(original)
+++ ./PYME/Acquire/Hardware/AndorNeo/plotTimings.py	(refactored)
@@ -44,7 +44,7 @@
         
     figure()
     
-    for i, ev in enumerate(events.keys()):
+    for i, ev in enumerate(list(events.keys())):
         t = array(events[ev])
         
         plot(t, i*ones(t.size), '+', label=ev)
@@ -54,10 +54,10 @@
     
     figure()
     colours = ['r', 'g', 'b']
-    for i, ev in enumerate(pollEvents.keys()):
+    for i, ev in enumerate(list(pollEvents.keys())):
         if len(pollEvents[ev]) > 0:
             t = array(pollEvents[ev])
-            print t.shape
+            print(t.shape)
             
             u = arange(t.shape[0]) % 2
             
--- ./PYME/Acquire/Hardware/AndorNeo/testNeo.py	(original)
+++ ./PYME/Acquire/Hardware/AndorNeo/testNeo.py	(refactored)
@@ -22,29 +22,29 @@
 ################
 
 
-print 'Importing Camera ... '
-import AndorNeo
+print('Importing Camera ... ')
+from . import AndorNeo
 import time
 import numpy as np
 
-print 'Initialising Camera ... '
+print('Initialising Camera ... ')
 cam = AndorNeo.AndorNeo(0)
 cam.Init()
 
 cam.SetIntegTime(100)
 #cam.PixelReadoutRate.setIndex(2)
 
-print 'Starting Exposure ...'
+print('Starting Exposure ...')
 cam.StartExposure()
 
 buf = np.empty((cam.GetPicWidth(), cam.GetPicHeight()), 'uint16')
 
-print '\nStarting Extraction loop ...'
+print('\nStarting Extraction loop ...')
 for i in range(200):
-    print i,
+    print(i, end=' ')
     while cam.ExpReady():
         cam.ExtractColor(buf, 1)
-        print 'e',
+        print('e', end=' ')
     
     time.sleep(.2)
         
@@ -54,7 +54,7 @@
 time.sleep(.5)
 AndorNeo.camReg.unregCamera()
 
-import plotTimings
+from . import plotTimings
 plotTimings.PlotTimings()
         
         
--- ./PYME/Acquire/Hardware/CanonEOS/eossdk.py	(original)
+++ ./PYME/Acquire/Hardware/CanonEOS/eossdk.py	(refactored)
@@ -70,7 +70,7 @@
 
 class UserString:
     def __init__(self, seq):
-        if isinstance(seq, basestring):
+        if isinstance(seq, str):
             self.data = seq
         elif isinstance(seq, UserString):
             self.data = seq.data[:]
@@ -79,7 +79,7 @@
     def __str__(self): return str(self.data)
     def __repr__(self): return repr(self.data)
     def __int__(self): return int(self.data)
-    def __long__(self): return long(self.data)
+    def __long__(self): return int(self.data)
     def __float__(self): return float(self.data)
     def __complex__(self): return complex(self.data)
     def __hash__(self): return hash(self.data)
@@ -101,12 +101,12 @@
     def __add__(self, other):
         if isinstance(other, UserString):
             return self.__class__(self.data + other.data)
-        elif isinstance(other, basestring):
+        elif isinstance(other, str):
             return self.__class__(self.data + other)
         else:
             return self.__class__(self.data + str(other))
     def __radd__(self, other):
-        if isinstance(other, basestring):
+        if isinstance(other, str):
             return self.__class__(other + self.data)
         else:
             return self.__class__(str(other) + self.data)
@@ -120,7 +120,7 @@
     def capitalize(self): return self.__class__(self.data.capitalize())
     def center(self, width, *args):
         return self.__class__(self.data.center(width, *args))
-    def count(self, sub, start=0, end=sys.maxint):
+    def count(self, sub, start=0, end=sys.maxsize):
         return self.data.count(sub, start, end)
     def decode(self, encoding=None, errors=None): # XXX improve this?
         if encoding:
@@ -138,13 +138,13 @@
                 return self.__class__(self.data.encode(encoding))
         else:
             return self.__class__(self.data.encode())
-    def endswith(self, suffix, start=0, end=sys.maxint):
+    def endswith(self, suffix, start=0, end=sys.maxsize):
         return self.data.endswith(suffix, start, end)
     def expandtabs(self, tabsize=8):
         return self.__class__(self.data.expandtabs(tabsize))
-    def find(self, sub, start=0, end=sys.maxint):
+    def find(self, sub, start=0, end=sys.maxsize):
         return self.data.find(sub, start, end)
-    def index(self, sub, start=0, end=sys.maxint):
+    def index(self, sub, start=0, end=sys.maxsize):
         return self.data.index(sub, start, end)
     def isalpha(self): return self.data.isalpha()
     def isalnum(self): return self.data.isalnum()
@@ -164,9 +164,9 @@
         return self.data.partition(sep)
     def replace(self, old, new, maxsplit=-1):
         return self.__class__(self.data.replace(old, new, maxsplit))
-    def rfind(self, sub, start=0, end=sys.maxint):
+    def rfind(self, sub, start=0, end=sys.maxsize):
         return self.data.rfind(sub, start, end)
-    def rindex(self, sub, start=0, end=sys.maxint):
+    def rindex(self, sub, start=0, end=sys.maxsize):
         return self.data.rindex(sub, start, end)
     def rjust(self, width, *args):
         return self.__class__(self.data.rjust(width, *args))
@@ -178,7 +178,7 @@
     def rsplit(self, sep=None, maxsplit=-1):
         return self.data.rsplit(sep, maxsplit)
     def splitlines(self, keepends=0): return self.data.splitlines(keepends)
-    def startswith(self, prefix, start=0, end=sys.maxint):
+    def startswith(self, prefix, start=0, end=sys.maxsize):
         return self.data.startswith(prefix, start, end)
     def strip(self, chars=None): return self.__class__(self.data.strip(chars))
     def swapcase(self): return self.__class__(self.data.swapcase())
@@ -221,7 +221,7 @@
         start = max(start, 0); end = max(end, 0)
         if isinstance(sub, UserString):
             self.data = self.data[:start]+sub.data+self.data[end:]
-        elif isinstance(sub, basestring):
+        elif isinstance(sub, str):
             self.data = self.data[:start]+sub+self.data[end:]
         else:
             self.data =  self.data[:start]+str(sub)+self.data[end:]
@@ -233,7 +233,7 @@
     def __iadd__(self, other):
         if isinstance(other, UserString):
             self.data += other.data
-        elif isinstance(other, basestring):
+        elif isinstance(other, str):
             self.data += other
         else:
             self.data += str(other)
@@ -248,7 +248,7 @@
                 ('data', c_char_p)]
 
     def __init__(self, obj=""):
-        if isinstance(obj, (str, unicode, UserString)):
+        if isinstance(obj, (str, UserString)):
             self.data = str(obj)
         else:
             self.raw = obj
@@ -398,7 +398,7 @@
                 return ctypes.CDLL(path, ctypes.RTLD_GLOBAL)
             else:
                 return ctypes.cdll.LoadLibrary(path)
-        except OSError,e:
+        except OSError as e:
             raise ImportError(e)
 
     def getpaths(self,libname):
@@ -805,7 +805,7 @@
 
 kEdsAccess_ReadWrite = (kEdsAccess_Write + 1) # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 571
 
-kEdsAccess_Error = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 571
+kEdsAccess_Error = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 571
 
 EdsAccess = enum_anon_248 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 571
 
@@ -855,7 +855,7 @@
 
 kEdsImageSize_Small3 = 16 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 616
 
-kEdsImageSize_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 616
+kEdsImageSize_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 616
 
 EdsImageSize = enum_anon_251 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 616
 
@@ -869,7 +869,7 @@
 
 kEdsCompressQuality_SuperFine = 5 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 629
 
-kEdsCompressQuality_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 629
+kEdsCompressQuality_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 629
 
 EdsCompressQuality = enum_anon_252 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 629
 
@@ -993,7 +993,7 @@
 
 EdsImageQuality_SRSJ = 40108560 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 708
 
-EdsImageQuality_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 708
+EdsImageQuality_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 708
 
 EdsImageQuality = enum_anon_253 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 708
 
@@ -1043,7 +1043,7 @@
 
 kEdsImageQualityForLegacy_LR2SJ = 3080735 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 738
 
-kEdsImageQualityForLegacy_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 738
+kEdsImageQualityForLegacy_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 738
 
 EdsImageQualityForLegacy = enum_anon_254 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 738
 
@@ -1121,7 +1121,7 @@
 
 kEdsBatteryLevel2_BCLevel = 0 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 810
 
-kEdsBatteryLevel2_AC = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 810
+kEdsBatteryLevel2_AC = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 810
 
 EdsBatteryLevel2 = enum_anon_259 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 810
 
@@ -1253,7 +1253,7 @@
 
 kEdsColorSpace_AdobeRGB = 2 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 924
 
-kEdsColorSpace_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 924
+kEdsColorSpace_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 924
 
 EdsColorSpace = enum_anon_267 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 924
 
@@ -1337,7 +1337,7 @@
 
 kEdsAEMode_PhotoInMovie = 21 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 984
 
-kEdsAEMode_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 984
+kEdsAEMode_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 984
 
 EdsAEMode = enum_anon_270 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 984
 
@@ -1351,7 +1351,7 @@
 
 kEdsBracket_FEB = 8 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 997
 
-kEdsBracket_Unknown = 4294967295L # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 997
+kEdsBracket_Unknown = 4294967295 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 997
 
 EdsBracket = enum_anon_271 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 997
 
@@ -2416,7 +2416,7 @@
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKTypes.h: 249
 try:
-    kEdsPropID_AtCapture_Flag = 2147483648L
+    kEdsPropID_AtCapture_Flag = 2147483648
 except:
     pass
 
@@ -2884,559 +2884,559 @@
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 34
 try:
-    EDS_ISSPECIFIC_MASK = 2147483648L
+    EDS_ISSPECIFIC_MASK = 2147483648
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 35
 try:
-    EDS_COMPONENTID_MASK = 2130706432L
+    EDS_COMPONENTID_MASK = 2130706432
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 36
 try:
-    EDS_RESERVED_MASK = 16711680L
+    EDS_RESERVED_MASK = 16711680
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 37
 try:
-    EDS_ERRORID_MASK = 65535L
+    EDS_ERRORID_MASK = 65535
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 42
 try:
-    EDS_CMP_ID_CLIENT_COMPONENTID = 16777216L
+    EDS_CMP_ID_CLIENT_COMPONENTID = 16777216
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 43
 try:
-    EDS_CMP_ID_LLSDK_COMPONENTID = 33554432L
+    EDS_CMP_ID_LLSDK_COMPONENTID = 33554432
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 44
 try:
-    EDS_CMP_ID_HLSDK_COMPONENTID = 50331648L
+    EDS_CMP_ID_HLSDK_COMPONENTID = 50331648
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 49
 try:
-    EDS_ERR_OK = 0L
+    EDS_ERR_OK = 0
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 55
 try:
-    EDS_ERR_UNIMPLEMENTED = 1L
+    EDS_ERR_UNIMPLEMENTED = 1
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 56
 try:
-    EDS_ERR_INTERNAL_ERROR = 2L
+    EDS_ERR_INTERNAL_ERROR = 2
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 57
 try:
-    EDS_ERR_MEM_ALLOC_FAILED = 3L
+    EDS_ERR_MEM_ALLOC_FAILED = 3
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 58
 try:
-    EDS_ERR_MEM_FREE_FAILED = 4L
+    EDS_ERR_MEM_FREE_FAILED = 4
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 59
 try:
-    EDS_ERR_OPERATION_CANCELLED = 5L
+    EDS_ERR_OPERATION_CANCELLED = 5
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 60
 try:
-    EDS_ERR_INCOMPATIBLE_VERSION = 6L
+    EDS_ERR_INCOMPATIBLE_VERSION = 6
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 61
 try:
-    EDS_ERR_NOT_SUPPORTED = 7L
+    EDS_ERR_NOT_SUPPORTED = 7
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 62
 try:
-    EDS_ERR_UNEXPECTED_EXCEPTION = 8L
+    EDS_ERR_UNEXPECTED_EXCEPTION = 8
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 63
 try:
-    EDS_ERR_PROTECTION_VIOLATION = 9L
+    EDS_ERR_PROTECTION_VIOLATION = 9
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 64
 try:
-    EDS_ERR_MISSING_SUBCOMPONENT = 10L
+    EDS_ERR_MISSING_SUBCOMPONENT = 10
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 65
 try:
-    EDS_ERR_SELECTION_UNAVAILABLE = 11L
+    EDS_ERR_SELECTION_UNAVAILABLE = 11
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 68
 try:
-    EDS_ERR_FILE_IO_ERROR = 32L
+    EDS_ERR_FILE_IO_ERROR = 32
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 69
 try:
-    EDS_ERR_FILE_TOO_MANY_OPEN = 33L
+    EDS_ERR_FILE_TOO_MANY_OPEN = 33
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 70
 try:
-    EDS_ERR_FILE_NOT_FOUND = 34L
+    EDS_ERR_FILE_NOT_FOUND = 34
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 71
 try:
-    EDS_ERR_FILE_OPEN_ERROR = 35L
+    EDS_ERR_FILE_OPEN_ERROR = 35
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 72
 try:
-    EDS_ERR_FILE_CLOSE_ERROR = 36L
+    EDS_ERR_FILE_CLOSE_ERROR = 36
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 73
 try:
-    EDS_ERR_FILE_SEEK_ERROR = 37L
+    EDS_ERR_FILE_SEEK_ERROR = 37
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 74
 try:
-    EDS_ERR_FILE_TELL_ERROR = 38L
+    EDS_ERR_FILE_TELL_ERROR = 38
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 75
 try:
-    EDS_ERR_FILE_READ_ERROR = 39L
+    EDS_ERR_FILE_READ_ERROR = 39
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 76
 try:
-    EDS_ERR_FILE_WRITE_ERROR = 40L
+    EDS_ERR_FILE_WRITE_ERROR = 40
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 77
 try:
-    EDS_ERR_FILE_PERMISSION_ERROR = 41L
+    EDS_ERR_FILE_PERMISSION_ERROR = 41
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 78
 try:
-    EDS_ERR_FILE_DISK_FULL_ERROR = 42L
+    EDS_ERR_FILE_DISK_FULL_ERROR = 42
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 79
 try:
-    EDS_ERR_FILE_ALREADY_EXISTS = 43L
+    EDS_ERR_FILE_ALREADY_EXISTS = 43
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 80
 try:
-    EDS_ERR_FILE_FORMAT_UNRECOGNIZED = 44L
+    EDS_ERR_FILE_FORMAT_UNRECOGNIZED = 44
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 81
 try:
-    EDS_ERR_FILE_DATA_CORRUPT = 45L
+    EDS_ERR_FILE_DATA_CORRUPT = 45
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 82
 try:
-    EDS_ERR_FILE_NAMING_NA = 46L
+    EDS_ERR_FILE_NAMING_NA = 46
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 85
 try:
-    EDS_ERR_DIR_NOT_FOUND = 64L
+    EDS_ERR_DIR_NOT_FOUND = 64
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 86
 try:
-    EDS_ERR_DIR_IO_ERROR = 65L
+    EDS_ERR_DIR_IO_ERROR = 65
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 87
 try:
-    EDS_ERR_DIR_ENTRY_NOT_FOUND = 66L
+    EDS_ERR_DIR_ENTRY_NOT_FOUND = 66
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 88
 try:
-    EDS_ERR_DIR_ENTRY_EXISTS = 67L
+    EDS_ERR_DIR_ENTRY_EXISTS = 67
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 89
 try:
-    EDS_ERR_DIR_NOT_EMPTY = 68L
+    EDS_ERR_DIR_NOT_EMPTY = 68
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 92
 try:
-    EDS_ERR_PROPERTIES_UNAVAILABLE = 80L
+    EDS_ERR_PROPERTIES_UNAVAILABLE = 80
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 93
 try:
-    EDS_ERR_PROPERTIES_MISMATCH = 81L
+    EDS_ERR_PROPERTIES_MISMATCH = 81
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 94
 try:
-    EDS_ERR_PROPERTIES_NOT_LOADED = 83L
+    EDS_ERR_PROPERTIES_NOT_LOADED = 83
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 97
 try:
-    EDS_ERR_INVALID_PARAMETER = 96L
+    EDS_ERR_INVALID_PARAMETER = 96
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 98
 try:
-    EDS_ERR_INVALID_HANDLE = 97L
+    EDS_ERR_INVALID_HANDLE = 97
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 99
 try:
-    EDS_ERR_INVALID_POINTER = 98L
+    EDS_ERR_INVALID_POINTER = 98
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 100
 try:
-    EDS_ERR_INVALID_INDEX = 99L
+    EDS_ERR_INVALID_INDEX = 99
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 101
 try:
-    EDS_ERR_INVALID_LENGTH = 100L
+    EDS_ERR_INVALID_LENGTH = 100
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 102
 try:
-    EDS_ERR_INVALID_FN_POINTER = 101L
+    EDS_ERR_INVALID_FN_POINTER = 101
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 103
 try:
-    EDS_ERR_INVALID_SORT_FN = 102L
+    EDS_ERR_INVALID_SORT_FN = 102
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 106
 try:
-    EDS_ERR_DEVICE_NOT_FOUND = 128L
+    EDS_ERR_DEVICE_NOT_FOUND = 128
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 107
 try:
-    EDS_ERR_DEVICE_BUSY = 129L
+    EDS_ERR_DEVICE_BUSY = 129
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 108
 try:
-    EDS_ERR_DEVICE_INVALID = 130L
+    EDS_ERR_DEVICE_INVALID = 130
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 109
 try:
-    EDS_ERR_DEVICE_EMERGENCY = 131L
+    EDS_ERR_DEVICE_EMERGENCY = 131
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 110
 try:
-    EDS_ERR_DEVICE_MEMORY_FULL = 132L
+    EDS_ERR_DEVICE_MEMORY_FULL = 132
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 111
 try:
-    EDS_ERR_DEVICE_INTERNAL_ERROR = 133L
+    EDS_ERR_DEVICE_INTERNAL_ERROR = 133
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 112
 try:
-    EDS_ERR_DEVICE_INVALID_PARAMETER = 134L
+    EDS_ERR_DEVICE_INVALID_PARAMETER = 134
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 113
 try:
-    EDS_ERR_DEVICE_NO_DISK = 135L
+    EDS_ERR_DEVICE_NO_DISK = 135
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 114
 try:
-    EDS_ERR_DEVICE_DISK_ERROR = 136L
+    EDS_ERR_DEVICE_DISK_ERROR = 136
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 115
 try:
-    EDS_ERR_DEVICE_CF_GATE_CHANGED = 137L
+    EDS_ERR_DEVICE_CF_GATE_CHANGED = 137
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 116
 try:
-    EDS_ERR_DEVICE_DIAL_CHANGED = 138L
+    EDS_ERR_DEVICE_DIAL_CHANGED = 138
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 117
 try:
-    EDS_ERR_DEVICE_NOT_INSTALLED = 139L
+    EDS_ERR_DEVICE_NOT_INSTALLED = 139
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 118
 try:
-    EDS_ERR_DEVICE_STAY_AWAKE = 140L
+    EDS_ERR_DEVICE_STAY_AWAKE = 140
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 119
 try:
-    EDS_ERR_DEVICE_NOT_RELEASED = 141L
+    EDS_ERR_DEVICE_NOT_RELEASED = 141
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 122
 try:
-    EDS_ERR_STREAM_IO_ERROR = 160L
+    EDS_ERR_STREAM_IO_ERROR = 160
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 123
 try:
-    EDS_ERR_STREAM_NOT_OPEN = 161L
+    EDS_ERR_STREAM_NOT_OPEN = 161
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 124
 try:
-    EDS_ERR_STREAM_ALREADY_OPEN = 162L
+    EDS_ERR_STREAM_ALREADY_OPEN = 162
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 125
 try:
-    EDS_ERR_STREAM_OPEN_ERROR = 163L
+    EDS_ERR_STREAM_OPEN_ERROR = 163
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 126
 try:
-    EDS_ERR_STREAM_CLOSE_ERROR = 164L
+    EDS_ERR_STREAM_CLOSE_ERROR = 164
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 127
 try:
-    EDS_ERR_STREAM_SEEK_ERROR = 165L
+    EDS_ERR_STREAM_SEEK_ERROR = 165
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 128
 try:
-    EDS_ERR_STREAM_TELL_ERROR = 166L
+    EDS_ERR_STREAM_TELL_ERROR = 166
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 129
 try:
-    EDS_ERR_STREAM_READ_ERROR = 167L
+    EDS_ERR_STREAM_READ_ERROR = 167
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 130
 try:
-    EDS_ERR_STREAM_WRITE_ERROR = 168L
+    EDS_ERR_STREAM_WRITE_ERROR = 168
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 131
 try:
-    EDS_ERR_STREAM_PERMISSION_ERROR = 169L
+    EDS_ERR_STREAM_PERMISSION_ERROR = 169
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 132
 try:
-    EDS_ERR_STREAM_COULDNT_BEGIN_THREAD = 170L
+    EDS_ERR_STREAM_COULDNT_BEGIN_THREAD = 170
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 133
 try:
-    EDS_ERR_STREAM_BAD_OPTIONS = 171L
+    EDS_ERR_STREAM_BAD_OPTIONS = 171
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 134
 try:
-    EDS_ERR_STREAM_END_OF_STREAM = 172L
+    EDS_ERR_STREAM_END_OF_STREAM = 172
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 137
 try:
-    EDS_ERR_COMM_PORT_IS_IN_USE = 192L
+    EDS_ERR_COMM_PORT_IS_IN_USE = 192
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 138
 try:
-    EDS_ERR_COMM_DISCONNECTED = 193L
+    EDS_ERR_COMM_DISCONNECTED = 193
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 139
 try:
-    EDS_ERR_COMM_DEVICE_INCOMPATIBLE = 194L
+    EDS_ERR_COMM_DEVICE_INCOMPATIBLE = 194
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 140
 try:
-    EDS_ERR_COMM_BUFFER_FULL = 195L
+    EDS_ERR_COMM_BUFFER_FULL = 195
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 141
 try:
-    EDS_ERR_COMM_USB_BUS_ERR = 196L
+    EDS_ERR_COMM_USB_BUS_ERR = 196
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 144
 try:
-    EDS_ERR_USB_DEVICE_LOCK_ERROR = 208L
+    EDS_ERR_USB_DEVICE_LOCK_ERROR = 208
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 145
 try:
-    EDS_ERR_USB_DEVICE_UNLOCK_ERROR = 209L
+    EDS_ERR_USB_DEVICE_UNLOCK_ERROR = 209
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 148
 try:
-    EDS_ERR_STI_UNKNOWN_ERROR = 224L
+    EDS_ERR_STI_UNKNOWN_ERROR = 224
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 149
 try:
-    EDS_ERR_STI_INTERNAL_ERROR = 225L
+    EDS_ERR_STI_INTERNAL_ERROR = 225
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 150
 try:
-    EDS_ERR_STI_DEVICE_CREATE_ERROR = 226L
+    EDS_ERR_STI_DEVICE_CREATE_ERROR = 226
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 151
 try:
-    EDS_ERR_STI_DEVICE_RELEASE_ERROR = 227L
+    EDS_ERR_STI_DEVICE_RELEASE_ERROR = 227
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 152
 try:
-    EDS_ERR_DEVICE_NOT_LAUNCHED = 228L
+    EDS_ERR_DEVICE_NOT_LAUNCHED = 228
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 154
 try:
-    EDS_ERR_ENUM_NA = 240L
+    EDS_ERR_ENUM_NA = 240
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 155
 try:
-    EDS_ERR_INVALID_FN_CALL = 241L
+    EDS_ERR_INVALID_FN_CALL = 241
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 156
 try:
-    EDS_ERR_HANDLE_NOT_FOUND = 242L
+    EDS_ERR_HANDLE_NOT_FOUND = 242
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 157
 try:
-    EDS_ERR_INVALID_ID = 243L
+    EDS_ERR_INVALID_ID = 243
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 158
 try:
-    EDS_ERR_WAIT_TIMEOUT_ERROR = 244L
+    EDS_ERR_WAIT_TIMEOUT_ERROR = 244
 except:
     pass
 
@@ -3592,67 +3592,67 @@
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 190
 try:
-    EDS_ERR_TAKE_PICTURE_AF_NG = 36097L
+    EDS_ERR_TAKE_PICTURE_AF_NG = 36097
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 191
 try:
-    EDS_ERR_TAKE_PICTURE_RESERVED = 36098L
+    EDS_ERR_TAKE_PICTURE_RESERVED = 36098
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 192
 try:
-    EDS_ERR_TAKE_PICTURE_MIRROR_UP_NG = 36099L
+    EDS_ERR_TAKE_PICTURE_MIRROR_UP_NG = 36099
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 193
 try:
-    EDS_ERR_TAKE_PICTURE_SENSOR_CLEANING_NG = 36100L
+    EDS_ERR_TAKE_PICTURE_SENSOR_CLEANING_NG = 36100
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 194
 try:
-    EDS_ERR_TAKE_PICTURE_SILENCE_NG = 36101L
+    EDS_ERR_TAKE_PICTURE_SILENCE_NG = 36101
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 195
 try:
-    EDS_ERR_TAKE_PICTURE_NO_CARD_NG = 36102L
+    EDS_ERR_TAKE_PICTURE_NO_CARD_NG = 36102
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 196
 try:
-    EDS_ERR_TAKE_PICTURE_CARD_NG = 36103L
+    EDS_ERR_TAKE_PICTURE_CARD_NG = 36103
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 197
 try:
-    EDS_ERR_TAKE_PICTURE_CARD_PROTECT_NG = 36104L
+    EDS_ERR_TAKE_PICTURE_CARD_PROTECT_NG = 36104
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 198
 try:
-    EDS_ERR_TAKE_PICTURE_MOVIE_CROP_NG = 36105L
+    EDS_ERR_TAKE_PICTURE_MOVIE_CROP_NG = 36105
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 199
 try:
-    EDS_ERR_TAKE_PICTURE_STROBO_CHARGE_NG = 36106L
+    EDS_ERR_TAKE_PICTURE_STROBO_CHARGE_NG = 36106
 except:
     pass
 
 # C:\\PYME\\PYME\\Acquire\\Hardware\\CanonEOS\\/EDSDKErrors.h: 202
 try:
-    EDS_ERR_LAST_GENERIC_ERROR_PLUS_ONE = 245L
+    EDS_ERR_LAST_GENERIC_ERROR_PLUS_ONE = 245
 except:
     pass
 
--- ./PYME/Acquire/Hardware/DigiData/DigiData.py	(original)
+++ ./PYME/Acquire/Hardware/DigiData/DigiData.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-from axDD132x import *
+from .axDD132x import *
 from ctypes import *
 from ctypes.wintypes import *
 
--- ./PYME/Acquire/Hardware/DigiData/RemoteDigiData.py	(original)
+++ ./PYME/Acquire/Hardware/DigiData/RemoteDigiData.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 #!/usr/bin/python
-from DigiData import *
+from .DigiData import *
 import Pyro.core
 import Pyro.naming
 
--- ./PYME/Acquire/Hardware/Mercury/Mercury.py	(original)
+++ ./PYME/Acquire/Hardware/Mercury/Mercury.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-import PI_Mercury_GCS_DLL as mc
+from . import PI_Mercury_GCS_DLL as mc
 import ctypes
 
 #class MercuryWrap:
--- ./PYME/Acquire/Hardware/Mercury/mercuryStepper.py	(original)
+++ ./PYME/Acquire/Hardware/Mercury/mercuryStepper.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-import Mercury as m
+from . import Mercury as m
 import time
 import numpy  as np
 
--- ./PYME/Acquire/Hardware/Old/esp300.py	(original)
+++ ./PYME/Acquire/Hardware/Old/esp300.py	(refactored)
@@ -48,7 +48,7 @@
     def stop_all(self, event=0):
         #stop all axes (emergency)
         self.ser_port.write('AB\r')
-        print 'stop all axes'
+        print('stop all axes')
 
     def MoveTo(self, iChannel, fPos, bTimeOut=True):
         if (fPos >= 0):
@@ -82,12 +82,12 @@
     def ledOn(self, event=0):
         #switch the LED on
         self.ser_port.write('sb01h\r\n')
-        print 'led on'
+        print('led on')
         
     def ledOff(self, event=1):
         # switch the LED off
         self.ser_port.write('sb00h\r\n')
-        print 'led off'        
+        print('led off')        
     
     def addMenuItems(self,parentWindow, menu):
         '''Add menu items and keyboard accelerators for LED control
--- ./PYME/Acquire/Hardware/Old/mc2000.py	(original)
+++ ./PYME/Acquire/Hardware/Old/mc2000.py	(refactored)
@@ -42,10 +42,10 @@
                 time.sleep(0.1)
                 if (iChannel == 1):
                     #self.ser_port.write('%2.5f 0 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2))
-                    print ('%2.5f 0 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2))
+                    print(('%2.5f 0 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2)))
                 else:
                     #self.ser_port.write('0 %2.5f 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2))
-                    print ('0 %2.5f 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2))
+                    print(('0 %2.5f 0 rmove \r\n' %(fPos - self.max_travel[iChannel - 1]/2)))
                     
             else:
                 self.ser_port.flushOutput()
@@ -78,7 +78,7 @@
         # and we have the value as string now
         ipos = posi.__getitem__(0)
         ipos = float(ipos) + self.max_travel[iChannel - 1]/2
-        print('Kanal: %d Wert: %2.5f' %(iChannel, ipos))
+        print(('Kanal: %d Wert: %2.5f' %(iChannel, ipos)))
         return ipos 
     
     def GetId(self):
@@ -112,14 +112,14 @@
         self.ser_port.flushOutput()
         time.sleep(0.05)
         self.ser_port.write('1 j \r\n')
-        print 'joystick on'
+        print('joystick on')
         
     def JoyOff(self, event=1):
         # switch the Joystick off
         self.ser_port.flushOutput()
         time.sleep(0.05)
         self.ser_port.write('0 j \r\n')
-        print 'joystick off'        
+        print('joystick off')        
     
     def addMenuItems(self,parentWindow, menu):
         '''Add menu items and keyboard accelerators for joystick control
--- ./PYME/Acquire/Hardware/Old/Sensicam/__init__.py	(original)
+++ ./PYME/Acquire/Hardware/Old/Sensicam/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from sensicam import *
+from .sensicam import *
--- ./PYME/Acquire/Hardware/Old/Sensicam/sensicam.py	(original)
+++ ./PYME/Acquire/Hardware/Old/Sensicam/sensicam.py	(refactored)
@@ -53,7 +53,7 @@
     if (name == "thisown"): return self.this.own()
     method = class_type.__swig_getmethods__.get(name,None)
     if method: return method(self)
-    raise AttributeError,name
+    raise AttributeError(name)
 
 def _swig_repr(self):
     try: strthis = "proxy of " + self.this.__repr__()
@@ -62,7 +62,7 @@
 
 import types
 try:
-    _object = types.ObjectType
+    _object = object
     _newclass = 1
 except AttributeError:
     class _object : pass
--- ./PYME/Acquire/Hardware/Piezos/piezo_c867.py	(original)
+++ ./PYME/Acquire/Hardware/Piezos/piezo_c867.py	(refactored)
@@ -74,7 +74,7 @@
         #time.sleep(0.005)
         res = self.ser_port.readline()
         #res = self.ser_port.readline()
-        print res
+        print(res)
         return float(res) 
         
         
@@ -123,7 +123,7 @@
         #time.sleep(0.005)
         res1 = self.ser_port.readline()
         res2 = self.ser_port.readline()
-        print res1, res2
+        print(res1, res2)
         return float(res1.split('=')[1]), float(res2.split('=')[1])
 
 
@@ -148,7 +148,7 @@
         return float(re.findall(r'V(\d\.\d\d)', verstring)[0])
         
 import threading
-import Queue
+import queue
 import numpy as np
         
 class piezo_c867T(object):    
@@ -221,7 +221,7 @@
                 self.errCode = int(self.ser_port.readline())
                 
                 if not self.errCode == 0:
-                    print 'Stage Error: %d' %self.errCode
+                    print('Stage Error: %d' %self.errCode)
                 
                 #print self.targetPosition, self.stopMove
                 
@@ -244,7 +244,7 @@
                     for i, vel in enumerate(self.targetVelocity):
                         self.ser_port.write('VEL %d %3.9f\n' % (i+1, vel))
                     self.velocity = self.targetVelocity.copy()
-                    print 'v'
+                    print('v')
                 
                 if not np.all(self.targetPosition == self.lastTargetPosition):
                     #update our target position
@@ -252,12 +252,12 @@
         
                     self.ser_port.write('MOV 1 %3.9f 2 %3.9f\n' % (pos[0], pos[1]))
                     self.lastTargetPosition = pos.copy()
-                    print 'p'
+                    print('p')
                     
                 #time.sleep(.1)
                 
             except serial.SerialTimeoutException:
-                print 'Serial Timeout'
+                print('Serial Timeout')
                 pass
             finally:
                 self.stopMove = False
--- ./PYME/Acquire/Hardware/Piezos/piezo_e709.py	(original)
+++ ./PYME/Acquire/Hardware/Piezos/piezo_e709.py	(refactored)
@@ -172,7 +172,7 @@
         
         
 import threading
-import Queue
+import queue
 import numpy as np
         
 class piezo_e709T(object):    
@@ -238,7 +238,7 @@
                 self.errCode = int(self.ser_port.readline())
                 
                 if not self.errCode == 0:
-                    print 'Stage Error: %d' %self.errCode
+                    print('Stage Error: %d' %self.errCode)
                 
                 #print self.targetPosition, self.stopMove
                 
@@ -269,15 +269,15 @@
         
                     self.ser_port.write('MOV Z %3.9f\n' % (pos[0], ))
                     self.lastTargetPosition = pos.copy()
-                    print 'p'
+                    print('p')
                     
                 #time.sleep(.1)
                 
             except serial.SerialTimeoutException:
-                print 'Serial Timeout'
+                print('Serial Timeout')
                 pass
             except IndexError:
-                print 'IndexException'
+                print('IndexException')
             finally:
                 self.stopMove = False
                 self.lock.release()
--- ./PYME/Acquire/Hardware/Piezos/piezo_e816.py	(original)
+++ ./PYME/Acquire/Hardware/Piezos/piezo_e816.py	(refactored)
@@ -99,7 +99,7 @@
         self.ser_port.flush()
         time.sleep(0.05)
 
-        for i, v in zip(range(self.numWavePoints), data):
+        for i, v in zip(list(range(self.numWavePoints)), data):
             self.ser_port.write('SWT A%d %3.4f\n' % (i, v))
             self.ser_port.flushOutput()
             time.sleep(0.01)
--- ./PYME/Acquire/Hardware/Simulator/dSimControl.py	(original)
+++ ./PYME/Acquire/Hardware/Simulator/dSimControl.py	(refactored)
@@ -25,13 +25,13 @@
 
 import wx
 import wx.grid
-import fluor
-import wormlike2
+from . import fluor
+from . import wormlike2
 import pylab
 import scipy
 import numpy as np
 import os
-import rend_im
+from . import rend_im
 
 def create(parent):
     return dSimControl(parent)
@@ -119,7 +119,7 @@
         self.cbFlatten.SetValue(False)
         hsizer.Add(self.cbFlatten, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 2)
 
-        self.cbColour = wx.CheckBox(self, -1, u'colourful')
+        self.cbColour = wx.CheckBox(self, -1, 'colourful')
         self.cbColour.SetValue(False)
         hsizer.Add(self.cbColour, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 2)
         
@@ -328,7 +328,7 @@
     def OnBLoadPointsButton(self, event):
         fn = wx.FileSelector('Read point positions from file')
         if fn == None:
-            print 'No file selected'
+            print('No file selected')
             return
 
         self.points = np.loadtxt(fn)
@@ -339,7 +339,7 @@
     def OnBSavePointsButton(self, event):
         fn = wx.SaveFileSelector('Save point positions to file', '.txt')
         if fn == None:
-            print 'No file selected'
+            print('No file selected')
             return
 
         #self.points = pylab.load(fn)
@@ -349,7 +349,7 @@
 
     def OnBSetPSF(self, event):
         fn = wx.FileSelector('Read PSF from file', default_extension='psf', wildcard='PYME PSF Files (*.psf)|*.psf')
-        print fn
+        print(fn)
         if fn == '':
             rend_im.genTheoreticalModel(rend_im.MetaData.TIRFDefault)
             return
--- ./PYME/Acquire/Hardware/Simulator/fakeCam.py	(original)
+++ ./PYME/Acquire/Hardware/Simulator/fakeCam.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-import rend_im
+from . import rend_im
 import PYME.cSMI as example
 import scipy
 
@@ -102,8 +102,8 @@
         self.stopAq = False
         self.startAq = False
 
-        print laserPowers
-        print intTime
+        print(laserPowers)
+        print(intTime)
 
         #self.frameLock = threading.Lock()
         #self.frameLock.acquire()
@@ -127,7 +127,7 @@
             if not self.xPiezo == None:
                 yp = (self.yPiezo.GetPos() - self.yPiezo.max_travel/2)*1e3
                 
-            if not self.fluors == None and not 'spec' in self.fluors.fl.dtype.fields.keys():
+            if not self.fluors == None and not 'spec' in list(self.fluors.fl.dtype.fields.keys()):
                 if self.biplane:
                     self.im = self.noiseMaker.noisify(rend_im.simPalmImFBP(self.XVals, self.YVals, zPos,self.fluors, laserPowers=self.laserPowers, intTime=self.intTime, deltaZ = self.deltaZ))[:,:].astype('uint16')
                 else:
@@ -251,33 +251,33 @@
         
 
     def GetCamType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetSerialNumber(self):
         return 0
     def GetDataType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetADBits(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetMaxDigit(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetNumberCh(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetBytesPerPoint(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCCDType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamID(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamVer(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetTrigMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetTrigMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetDelayTime(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetDelayTime(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def SetIntegTime(self, iTime): 
         self.intTime=iTime*1e-3
@@ -286,17 +286,17 @@
         return self.intTime
     
     def SetROIMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetROIMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetCamMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetBoardNum(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetBoardNum(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def GetCCDWidth(self): 
         return len(self.XVals)
@@ -304,19 +304,19 @@
         return len(self.YVals)
     
     def SetHorizBin(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetHorizBin(*args):
         return 0
         #raise Exception, 'Not implemented yet!!'
     def GetHorzBinValue(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetVertBin(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetVertBin(*args):
         return 0
         #raise Exception, 'Not implemented yet!!'
     def GetNumberChannels(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def GetElectrTemp(*args): 
         return 25
@@ -399,9 +399,9 @@
         return 0
 
     def StartLifePreview(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def StopLifePreview(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def ExpReady(self):
         #return not self.compTCur.isAlive() #thread has finished -> a picture is available
@@ -410,7 +410,7 @@
         #raise Exception, 'Not implemented yet!!'
 
     def GetBWPicture(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def ExtractColor(self, chSlice, mode): 
         #im = self.noiseMaker.noisify(rend_im.simPalmIm(self.XVals, self.YVals, self.zPiezo.GetPos() - self.zOffset,self.fluors, laserPowers=self.laserPowers, intTime=self.intTime*1e-3))[:,:].astype('uint16')
@@ -420,7 +420,7 @@
 	    chSlice[:,:] = self.compT.getIm() #grab image from completed computation thread
 	    #self.compTOld = None #set computation thread to None such that we get an error if we try and obtain the same result twice
 	except AttributeError:  # triggered if called with None
-	    print "Grabbing problem: probably called with 'None' thread"
+	    print("Grabbing problem: probably called with 'None' thread")
         #pylab.figure(2)
         #pylab.hist([f.state for f in self.fluors], [0, 1, 2, 3], hold=False)
         #pylab.gca().set_xticks([0.5,1.5,2.5,3.5])
@@ -428,7 +428,7 @@
         #pylab.show()
         
     def CheckCoordinates(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     #new fcns for Andor compatibility
     def GetNumImsBuffered(self):
@@ -497,7 +497,7 @@
     def __getattr__(self, name):
         if name in dir(self.noiseMaker):
             return self.noiseMaker.__dict__[name]
-        else:  raise AttributeError, name  # <<< DON'T FORGET THIS LINE !!
+        else:  raise AttributeError(name)  # <<< DON'T FORGET THIS LINE !!
         
     def __del__(self):
         self.Shutdown()
--- ./PYME/Acquire/Hardware/Simulator/fakePiezo.py	(original)
+++ ./PYME/Acquire/Hardware/Simulator/fakePiezo.py	(refactored)
@@ -56,4 +56,4 @@
     def __getattr__(self, name):
         if name == 'lastPos':
             return self.curpos
-        else: raise AttributeError, name  # <<< DON'T FORGET THIS LINE !!
+        else: raise AttributeError(name)  # <<< DON'T FORGET THIS LINE !!
--- ./PYME/Acquire/Hardware/Simulator/fluor.py	(original)
+++ ./PYME/Acquire/Hardware/Simulator/fluor.py	(refactored)
@@ -25,17 +25,17 @@
 import numpy as np
 
 try:
-    import illuminate
+    from . import illuminate
     HAVE_ILLUMINATE_MOD = True
 except ImportError:
     HAVE_ILLUMINATE_MOD = False
     
 
 class states:
-    caged, active, blinked, bleached = range(4)
+    caged, active, blinked, bleached = list(range(4))
     n=4
 
-ALL_TRANS, FROM_ONLY, TO_ONLY = range(3)
+ALL_TRANS, FROM_ONLY, TO_ONLY = list(range(3))
 
 
 illuminationFunctions = {}
--- ./PYME/Acquire/Hardware/Simulator/rend_im.py	(original)
+++ ./PYME/Acquire/Hardware/Simulator/rend_im.py	(refactored)
@@ -24,10 +24,10 @@
 from PYME.PSFGen import *
 from scipy import *
 from pylab import ifftshift, fftn, ifftn
-import fluor
+from . import fluor
 from PYME.Analysis import MetaData
 from PYME.Analysis import cInterp
-import cPickle
+import pickle
 from scipy import ndimage
 import numpy as np
 
@@ -86,12 +86,12 @@
 
         interpModel = genWidefieldPSF(IntXVals, IntYVals, IntZVals, P,1e3, 0, 0, 0, 2*pi/525, 1.47, 10e3).astype('f')
         
-        print 'foo'
-        print interpModel.strides, interpModel.shape
+        print('foo')
+        print(interpModel.strides, interpModel.shape)
 
         interpModel = np.maximum(interpModel/interpModel[:,:,len(IntZVals)/2].sum(), 0) #normalise to 1 and clip
         
-        print 'bar'
+        print('bar')
 
 genTheoreticalModel(MetaData.TIRFDefault)
 
@@ -115,7 +115,7 @@
 
     
     mf = open(getFullExistingFilename(modName), 'rb')
-    mod, voxelsize = cPickle.load(mf)
+    mod, voxelsize = pickle.load(mf)
     mf.close()
     
     mod = resizePSF(mod, interpModel.shape)
--- ./PYME/Acquire/Hardware/Spectrometer/specCam.py	(original)
+++ ./PYME/Acquire/Hardware/Spectrometer/specCam.py	(refactored)
@@ -30,7 +30,7 @@
 from PYME.Acquire import MetaDataHandler
 from PYME.Acquire import eventLog
 
-from spectrometerClient import SpecClient
+from .spectrometerClient import SpecClient
 
 import threading
 
@@ -160,33 +160,33 @@
         MetaDataHandler.provideStartMetadata.append(self.GenStartMetadata)    
 
     def GetCamType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetSerialNumber(self):
         return 0
     def GetDataType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetADBits(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetMaxDigit(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetNumberCh(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetBytesPerPoint(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCCDType(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamID(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamVer(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetTrigMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetTrigMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetDelayTime(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetDelayTime(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def SetIntegTime(self, iTime): 
         self.intTime=iTime
@@ -202,17 +202,17 @@
         return self.intTime
     
     def SetROIMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetROIMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetCamMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetCamMode(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetBoardNum(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetBoardNum(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def GetCCDWidth(self): 
         return len(self.XVals)
@@ -220,19 +220,19 @@
         return 1
     
     def SetHorizBin(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetHorizBin(*args):
         return 0
         #raise Exception, 'Not implemented yet!!'
     def GetHorzBinValue(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def SetVertBin(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def GetVertBin(*args):
         return 0
         #raise Exception, 'Not implemented yet!!'
     def GetNumberChannels(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def GetElectrTemp(*args): 
         return 25
@@ -248,7 +248,7 @@
         return self.ROIy[1] - self.ROIy[0]
 
     def SetROI(self, x1, y1, x2, y2):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def GetROIX1(self):
         return self.ROIx[0]
@@ -297,9 +297,9 @@
         return 0
 
     def StartLifePreview(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     def StopLifePreview(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def ExpReady(self):
         #return not self.compTCur.isAlive() #thread has finished -> a picture is available
@@ -308,7 +308,7 @@
         #raise Exception, 'Not implemented yet!!'
 
     def GetBWPicture(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
     
     def ExtractColor(self, chSlice, mode): 
         #im = self.noiseMaker.noisify(rend_im.simPalmIm(self.XVals, self.YVals, self.zPiezo.GetPos() - self.zOffset,self.fluors, laserPowers=self.laserPowers, intTime=self.intTime*1e-3))[:,:].astype('uint16')
@@ -318,7 +318,7 @@
 	    chSlice[:,:] = self.compT.getIm()[:,None] #grab image from completed computation thread
 	    #self.compTOld = None #set computation thread to None such that we get an error if we try and obtain the same result twice
 	except AttributeError:  # triggered if called with None
-	    print "Grabbing problem: probably called with 'None' thread"
+	    print("Grabbing problem: probably called with 'None' thread")
         #pylab.figure(2)
         #pylab.hist([f.state for f in self.fluors], [0, 1, 2, 3], hold=False)
         #pylab.gca().set_xticks([0.5,1.5,2.5,3.5])
@@ -326,7 +326,7 @@
         #pylab.show()
         
     def CheckCoordinates(*args): 
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     #new fcns for Andor compatibility
     def GetNumImsBuffered(self):
--- ./PYME/Acquire/Hardware/uc480/AndorControlFrame.py	(original)
+++ ./PYME/Acquire/Hardware/uc480/AndorControlFrame.py	(refactored)
@@ -110,17 +110,17 @@
         self.chVertClock.Bind(wx.EVT_CHOICE, self.OnChVertClockChoice)
         hsizer.Add(self.chVertClock, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5)
 
-        hsizer.Add(wx.StaticText(cp, -1, u'\u03BCs'), 0, wx.ALIGN_CENTER_VERTICAL, 0)
+        hsizer.Add(wx.StaticText(cp, -1, '\u03BCs'), 0, wx.ALIGN_CENTER_VERTICAL, 0)
         sbReadout.Add(hsizer, 0, 0, 0)
 
         hsizer = wx.BoxSizer(wx.HORIZONTAL)
 
-        self.cbFrameTransfer = wx.ToggleButton(cp, -1, u'Frame Transfer')
+        self.cbFrameTransfer = wx.ToggleButton(cp, -1, 'Frame Transfer')
         self.cbFrameTransfer.SetValue(True)
         self.cbFrameTransfer.Bind(wx.EVT_TOGGLEBUTTON, self.OnCbFrameTransferCheckbox)
         hsizer.Add(self.cbFrameTransfer, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5)
 
-        self.cbBaselineClamp = wx.ToggleButton(cp, -1, u'Baseline Clamp')
+        self.cbBaselineClamp = wx.ToggleButton(cp, -1, 'Baseline Clamp')
         self.cbBaselineClamp.SetValue(False)
         self.cbBaselineClamp.Bind(wx.EVT_TOGGLEBUTTON, self.OnCbBaselineClampCheckbox)
         hsizer.Add(self.cbBaselineClamp, 0, wx.ALIGN_CENTER_VERTICAL, 0)
@@ -143,7 +143,7 @@
         vsizer=wx.BoxSizer(wx.VERTICAL)
         hsizer = wx.BoxSizer(wx.HORIZONTAL)
 
-        sbCooling = wx.StaticBoxSizer(wx.StaticBox(self, -1, u'Cooling [\N{DEGREE SIGN}C]'), wx.VERTICAL)
+        sbCooling = wx.StaticBoxSizer(wx.StaticBox(self, -1, 'Cooling [\N{DEGREE SIGN}C]'), wx.VERTICAL)
         hsizer2 = wx.BoxSizer(wx.HORIZONTAL)
 
         self.tCCDTemp = wx.TextCtrl(self, -1, '0', size=(30, -1))
@@ -179,7 +179,7 @@
         hsizer.Add(sbEMGain, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
         vsizer.Add(hsizer, 0, wx.EXPAND|wx.ALIGN_CENTER_HORIZONTAL, 0)
 
-        self.cbShutter = wx.CheckBox(self, -1, u'Camera Shutter Open')
+        self.cbShutter = wx.CheckBox(self, -1, 'Camera Shutter Open')
         self.cbShutter.SetValue(True)
         self.cbShutter.Bind(wx.EVT_CHECKBOX, self.OnCbShutterCheckbox)
         vsizer.Add(self.cbShutter, 0, wx.ALIGN_CENTER_VERTICAL|wx.TOP, 5)
--- ./PYME/Acquire/Hardware/uc480/uCam480.py	(original)
+++ ./PYME/Acquire/Hardware/uc480/uCam480.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-import uc480
+from . import uc480
 from ctypes import *
 import ctypes
 import time
@@ -30,7 +30,7 @@
 from PYME.Acquire.Hardware import ccdCalibrator
 
 import threading
-import Queue
+import queue
 
 import numpy as np
 #import example
@@ -93,7 +93,7 @@
         self.boardHandle = wintypes.HANDLE(0)
 
         ret = uc480.CALL('InitCamera', byref(self.boardHandle), wintypes.HWND(0))
-        print 'I',ret
+        print('I',ret)
         if not ret == 0:
             raise RuntimeError('Error getting camera handle: %d: %s' % GetError(self.boardHandle))
             
@@ -155,7 +155,7 @@
         
         self._buffers = []
         
-        self.fullBuffers = Queue.Queue()
+        self.fullBuffers = queue.Queue()
         self.nFull = 0
         
         self.Init()
@@ -229,43 +229,43 @@
 
 
     def GetCamType(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetDataType(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetADBits(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetMaxDigit(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetNumberCh(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetBytesPerPoint(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetCCDType(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetCamID(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetCamVer(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def SetTrigMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetTrigMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def SetDelayTime(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetDelayTime(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
 
     def SetIntegTime(self, iTime):
@@ -293,22 +293,22 @@
         return self.expTime
 
     def SetROIMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetROIMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def SetCamMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetCamMode(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def SetBoardNum(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetBoardNum(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetCCDWidth(self):
         return self.CCDSize[0]
@@ -323,7 +323,7 @@
 #        ret = ac.SetImage(self.binX,self.binY,self.ROIx[0],self.ROIx[1],self.ROIy[0],self.ROIy[1])
 #        if not ret == ac.DRV_SUCCESS:
 #            raise RuntimeError('Error setting image size: %s' % ac.errorCodes[ret])
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetHorizBin(self):
         return self.binning
@@ -340,7 +340,7 @@
 #        ret = ac.SetImage(self.binX,self.binY,self.ROIx[0],self.ROIx[1],self.ROIy[0],self.ROIy[1])
 #        if not ret == ac.DRV_SUCCESS:
 #            raise RuntimeError('Error setting image size: %s' % ac.errorCodes[ret])
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetVertBin(*args):
         return 0
@@ -351,7 +351,7 @@
         return self.binY
 
     def GetNumberChannels(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def GetElectrTemp(*args):
         return 25
@@ -404,7 +404,7 @@
         rect.s32Width = 1+ self.ROIx[1] - self.ROIx[0]
         rect.s32Height = 1+ self.ROIy[1] - self.ROIy[0]
         
-        print rect.s32X, rect.s32Width
+        print(rect.s32X, rect.s32Width)
         
         #ret = uc480.CALL('SetImageSize', self.boardHandle, rect.s32Width, rect.s32Height )
         #if not ret == 0:
@@ -445,7 +445,7 @@
     def StartExposure(self):
         
         if self.doPoll:
-            print 'StartAq'
+            print('StartAq')
             self.StopAq()
         self.InitBuffers()
         
@@ -458,10 +458,10 @@
         return 0
 
     def StartLifePreview(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def StopLifePreview(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     #PYME Camera interface functions - make this look like the other cameras
     def ExpReady(self):
@@ -488,7 +488,7 @@
         #self._queueBuffer(buf)
         
     def CheckCoordinates(*args):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
 
     def StopAq(self):
         ret = uc480.CALL('StopLiveVideo', self.boardHandle, uc480.IS_WAIT)
@@ -498,7 +498,7 @@
         pass
 
     def SetEMGain(self, gain):
-        raise Exception, 'Not implemented yet!!'
+        raise Exception('Not implemented yet!!')
        
 
     def GetEMGain(self):
--- ./PYME/Acquire/Hardware/uc480/uc480.py	(original)
+++ ./PYME/Acquire/Hardware/uc480/uc480.py	(refactored)
@@ -10,7 +10,7 @@
 import ctypes.wintypes
 import warnings
 
-from uc480_h import *
+from .uc480_h import *
 from ctypes.wintypes import BYTE
 from ctypes.wintypes import WORD
 from ctypes.wintypes import DWORD
@@ -95,7 +95,7 @@
     include_uc480_h = os.environ['PROGRAMFILES']+'\\Thorlabs DCU camera\\Develop\\Include\\uc480.h'
     lib = ctypes.util.find_library(libname)
     if lib is None:
-        print 'uc480.dll not found'
+        print('uc480.dll not found')
         lib = libname
 
 		
@@ -110,7 +110,7 @@
 	except ImportError:
 		uc480_h = None
 	if uc480_h is None:
-		assert os.path.isfile (include_uc480_h), `include_uc480_h`
+		assert os.path.isfile (include_uc480_h), repr(include_uc480_h)
 		d = {}
 		l = ['# This file is auto-generated. Do not edit!']
 		error_map = {}
@@ -130,7 +130,7 @@
 			if len (words)!=2: continue
 			name, value = words
 			if value.startswith('0x'):
-				exec '%s = %s' % (name, value)
+				exec('%s = %s' % (name, value))
 				d[name] = eval(value)
 				l.append('%s = %s' % (name, value))
 			# elif name.startswith('DAQmxError') or name.startswith('DAQmxWarning'):
@@ -144,10 +144,10 @@
 				d[name] = eval(value)
 				l.append('%s = %s' % (name, value))
 			elif value.startswith('UC'):
-				print value
-				d[name] = unicode(value[3:-1])
+				print(value)
+				d[name] = str(value[3:-1])
 				l.append('%s = unicode("%s")' % (name, value[3:-1]))
-			elif d.has_key(value):
+			elif value in d:
 				d[name] = d[value]
 				l.append('%s = %s' % (name, d[value]))
 			else:
@@ -156,11 +156,11 @@
 				pass
 		l.append('error_map = %r' % (error_map))
 		fn = os.path.join (os.path.dirname(os.path.abspath (__file__)), uc480_h_name+'.py')
-		print 'Generating %r' % (fn)
+		print('Generating %r' % (fn))
 		f = open(fn, 'w')
 		f.write ('\n'.join(l) + '\n')
 		f.close()
-		print 'Please upload generated file %r to http://code.google.com/p/pylibuc480/issues' % (fn)
+		print('Please upload generated file %r to http://code.google.com/p/pylibuc480/issues' % (fn))
 	else:
 		pass
 		#d = uc480_h.__dict__
@@ -215,8 +215,8 @@
 	func = getattr(libuc480, funcname)
 	new_args = []
 	for a in args:		
-		if isinstance (a, unicode):
-			print name, 'argument',a, 'is unicode'
+		if isinstance (a, str):
+			print(name, 'argument',a, 'is unicode')
 			new_args.append (str (a))
 		else:
 			new_args.append (a)
@@ -248,7 +248,7 @@
 		self.image = c_char_p()
 		self.id = c_int()
 		CALL('AllocImageMem',self,c_int(width),c_int(height),c_int(bitpixel),ctypes.byref(self.image),ctypes.byref(self.id))
-		print self.id
+		print(self.id)
 #		CALL('AllocImageMem',self,c_int(width),c_int(height),c_int(bitpixel),self.image.data,ctypes.byref(self.id))
 	
 	def FreeImageMem (self):
@@ -262,8 +262,8 @@
 		r = CALL("CopyImageMem",self,self.image,self.id,self.data.ctypes.data)
 		if r == -1:
 			self.GetError()
-			print self.err
-			print self.errMessage.value
+			print(self.err)
+			print(self.errMessage.value)
 		return 
 
 	def GetError(self):
@@ -275,7 +275,7 @@
 		CALL("SetImageMem",self,self.image,self.id)
 		
 	def SetImageSize(self,x=IS_GET_IMAGE_SIZE_X_MAX,y=IS_GET_IMAGE_SIZE_X_MAX):
-		print IS_GET_IMAGE_SIZE_X_MAX
+		print(IS_GET_IMAGE_SIZE_X_MAX)
 		CALL("SetImageSize",self,c_int(x),c_int(y))
 		
 	def SetImagePos(self,x=0,y=0):
--- ./PYME/Acquire/Hardware/uc480/uc480_h.py	(original)
+++ ./PYME/Acquire/Hardware/uc480/uc480_h.py	(refactored)
@@ -3,8 +3,8 @@
 IS_COLORMODE_INVALID = 0
 IS_COLORMODE_MONOCHROME = 1
 IS_COLORMODE_BAYER = 2
-KODAK_KAI1020M_NAME = unicode("D1024G23M\0")
-KODAK_KAI1020C_NAME = unicode("D1024G23C\0")
+KODAK_KAI1020M_NAME = str("D1024G23M\0")
+KODAK_KAI1020C_NAME = str("D1024G23C\0")
 IS_SENSOR_INVALID = 0x0000
 IS_SENSOR_C0640R13M = 0x0001
 IS_SENSOR_C0640R13C = 0x0002
@@ -226,7 +226,7 @@
 IS_OFF = 0
 IS_ON = 1
 IS_IGNORE_PARAMETER = -1
-IS_USE_DEVICE_ID = 0x8000L
+IS_USE_DEVICE_ID = 0x8000
 IS_GET_AUTO_EXIT_ENABLED = 0x8000
 IS_DISABLE_AUTO_EXIT = 0
 IS_ENABLE_AUTO_EXIT = 1
--- ./PYME/Acquire/Protocols/photoconversion2.py	(original)
+++ ./PYME/Acquire/Protocols/photoconversion2.py	(refactored)
@@ -42,7 +42,7 @@
 taskList += [T(140, scope.dichroic.SetFilter, 'DAPI'),] #Photoconversion
 taskList += alternans(250, 10, 5, ['Cy5', 'TxRed'])
 
-print taskList
+print(taskList)
 
 #optional - metadata entries
 metaData = [
--- ./PYME/Acquire/Protocols/shiftfield.py	(original)
+++ ./PYME/Acquire/Protocols/shiftfield.py	(refactored)
@@ -132,7 +132,7 @@
 
     #stop after one full scan
     stopTask.when = 23 + 2*ps.imsize
-    print stopTask.when
+    print(stopTask.when)
 
 
 
--- ./PYME/Acquire/Protocols/tile.py	(original)
+++ ./PYME/Acquire/Protocols/tile.py	(refactored)
@@ -61,7 +61,7 @@
 
         self.subplot.cla()
 
-        for i in xrange(X.size):
+        for i in range(X.size):
             self.subplot.plot(ox + X[i], oy + Y[i])#, c=i)
 
         #self.subplot.set_xlim(0, 512)
@@ -156,7 +156,7 @@
 
     #stop after one full scan
     stopTask.when = 14 + 1*ps.imsize
-    print stopTask.when
+    print(stopTask.when)
 
 
 
--- ./PYME/Acquire/Protocols/tile3D.py	(original)
+++ ./PYME/Acquire/Protocols/tile3D.py	(refactored)
@@ -61,7 +61,7 @@
 
         self.subplot.cla()
 
-        for i in xrange(X.size):
+        for i in range(X.size):
             self.subplot.plot(ox + X[i], oy + Y[i])#, c=i)
 
         #self.subplot.set_xlim(0, 512)
@@ -156,7 +156,7 @@
 
     #stop after one full scan
     stopTask.when = 14 + 1*ps.imsize
-    print stopTask.when
+    print(stopTask.when)
 
 
 
--- ./PYME/Acquire/Protocols/tile671.py	(original)
+++ ./PYME/Acquire/Protocols/tile671.py	(refactored)
@@ -52,7 +52,7 @@
 
         self.subplot.cla()
 
-        for i in xrange(X.size):
+        for i in range(X.size):
             self.subplot.plot(ox + X[i], oy + Y[i])#, c=i)
 
         #self.subplot.set_xlim(0, 512)
@@ -147,7 +147,7 @@
 
     #stop after one full scan
     stopTask.when = 40 + 3*ps.imsize
-    print stopTask.when
+    print(stopTask.when)
 
 
 
--- ./PYME/Analysis/MetaDataEdit.py	(original)
+++ ./PYME/Analysis/MetaDataEdit.py	(refactored)
@@ -127,7 +127,7 @@
             self.filename = mdh[self.paramName]
             FieldText = '%s ' % self.guiName + os.path.split(mdh[self.paramName])[1]
             haveFile = True
-            print FieldText
+            print(FieldText)
 
         self.stFilename = wx.StaticText(parent, -1, FieldText)
         if haveFile:
--- ./PYME/Analysis/MetadataTree.py	(original)
+++ ./PYME/Analysis/MetadataTree.py	(refactored)
@@ -150,7 +150,7 @@
         #print x,y
         item, flags, col = self.HitTest((x,y))
 
-        print item, flags, col
+        print(item, flags, col)
 
 #        if row != self.curRow: # self.curRow keeps track of the current row
 #            evt.Skip()
@@ -290,7 +290,7 @@
 
 class EditableTreeList(gizmos.TreeListCtrl, TextEditMixin):
     def __init__(self, parent, id=-1, style=wx.TR_DEFAULT_STYLE):
-        print style
+        print(style)
         gizmos.TreeListCtrl.__init__(self,parent, id, style=style)
         TextEditMixin.__init__(self)
 
@@ -366,7 +366,7 @@
 
     def addEntries(self, mdh, node, entrypath=''):
         #en = []
-        for k in mdh.__dict__.keys():
+        for k in list(mdh.__dict__.keys()):
             child = self.tree.AppendItem(node, k)
             self.tree.SetItemText(child, k, 0)
             if mdh.__dict__[k].__class__ == NestedClassMDHandler:
--- ./PYME/Analysis/SimReconstruction.py	(original)
+++ ./PYME/Analysis/SimReconstruction.py	(refactored)
@@ -37,7 +37,7 @@
     
     for ang in a:
         idx = angles == ang
-        print idx, imgs[:,:,idx].shape, phases[idx].shape
+        print(idx, imgs[:,:,idx].shape, phases[idx].shape)
         A1, B1 = ReconstructAngle(imgs[:,:,idx], ang, phases[idx], pixelsize, period)
         A += A1
         B += B1
--- ./PYME/Analysis/angleFilter.py	(original)
+++ ./PYME/Analysis/angleFilter.py	(refactored)
@@ -272,10 +272,10 @@
     import sys
     
     filenames = sys.argv[1:]
-    print filenames
+    print(filenames)
     
     for fn in filenames:
-        print fn
+        print(fn)
         procSkelFile(fn)
     
     
--- ./PYME/Analysis/binAvg.py	(original)
+++ ./PYME/Analysis/binAvg.py	(refactored)
@@ -29,7 +29,7 @@
     bs = np.zeros(len(bins) - 1)
     bn = np.zeros(len(bins) - 1, dtype='i')
 
-    for i, el, er in zip(range(len(bm)), bins[:-1], bins[1:]):
+    for i, el, er in zip(list(range(len(bm))), bins[:-1], bins[1:]):
         v = indepVar[(binVar >= el)*(binVar < er)]
 
         bn[i] = len(v)
@@ -47,7 +47,7 @@
     bs = np.zeros(len(bins) - 1)
     bn = np.zeros(len(bins) - 1, dtype='i')
 
-    for i, el, er in zip(range(len(bm)), bins[:-1], bins[1:]):
+    for i, el, er in zip(list(range(len(bm))), bins[:-1], bins[1:]):
         v = indepVar[(binVar >= el)*(binVar < er)]
 
         bn[i] = len(v)
--- ./PYME/Analysis/cramerRao.py	(original)
+++ ./PYME/Analysis/cramerRao.py	(refactored)
@@ -42,7 +42,7 @@
     lpk = lp_poisson(lam, k)
     pk = p_poisson(lam, k)
 
-    print 'number of NaNs = %d' % isnan(pk).sum()
+    print('number of NaNs = %d' % isnan(pk).sum())
 
     dx, dy, dz, dk = gradient(lpk)
     dx *= 1./voxelsize[0]
--- ./PYME/Analysis/deTile.py	(original)
+++ ./PYME/Analysis/deTile.py	(refactored)
@@ -67,7 +67,7 @@
     xc = np.abs(ifftshift(ifftn(fftn(im1)*ifftn(im2))))
 
     xct = (xc - xc.max()/1.1)*(xc > xc.max()/1.1)
-    print xct.shape
+    print(xct.shape)
 
     #figure(1)
     #imshow(xct)
@@ -93,10 +93,10 @@
         flt +=  ds[:,:,i]
         n+=1
 
-    print flt.shape, dark.shape
+    print(flt.shape, dark.shape)
 
     flt = flt/n - dark
-    print flt.shape, flt.mean()
+    print(flt.shape, flt.mean())
     return np.minimum(flt.mean()/flt, 2.5)
 
 
@@ -219,14 +219,14 @@
                         x0,y0,x1,y1 = r
                         #print r
                         dx_, dy_ = calcCorrShift(d.sum(2)[x0:x1, y0:y1], imr[x0:x1, y0:y1])
-                        print 'd_', dx_, dy_
+                        print('d_', dx_, dy_)
                         dx += dx_
                         dy += dy_
                     
                     dx = np.round(dx/len(rois))
                     dy = np.round(dy/len(rois))
 
-                    print dx, dy
+                    print(dx, dy)
 
                     #dx, dy = (0,0)
                 else:
--- ./PYME/Analysis/expectationMaximisation.py	(original)
+++ ./PYME/Analysis/expectationMaximisation.py	(refactored)
@@ -263,7 +263,7 @@
     for i in range(means.size):
         c = pylab.cm.hsv(float(i)/means.size)
 
-        print c
+        print(c)
 
         pylab.axvline(means[i], color=c)
         pylab.axvspan(means[i] - sigs[i], means[i] + sigs[i], alpha=0.5, facecolor=c)
--- ./PYME/Analysis/implicitFilter.py	(original)
+++ ./PYME/Analysis/implicitFilter.py	(refactored)
@@ -79,9 +79,9 @@
         if not changed:
             stepsize *=.5
 
-    print 'Optimisation terminated:'
-    print 'nIterations: %d' % nIters
-    print 'nFevals: %d' % nFeval
+    print('Optimisation terminated:')
+    print('nIterations: %d' % nIters)
+    print('nFevals: %d' % nFeval)
 
     return x0 #, xts
 
@@ -202,9 +202,9 @@
         #if not changed:
         stepsize *=.1
 
-    print 'Optimisation terminated:'
-    print 'nIterations: %d' % nIters
-    print 'nFevals: %d' % nFeval
+    print('Optimisation terminated:')
+    print('nIterations: %d' % nIters)
+    print('nFevals: %d' % nFeval)
 
     return x0 #, xts
 
@@ -278,7 +278,7 @@
         fCand = fcn(xCand, *args)
         nFeval += 1
 
-        print x0, xCand, fPred, fCand
+        print(x0, xCand, fPred, fCand)
 
 
         while fCand < fval and nFeval < maxFevals:
@@ -316,7 +316,7 @@
         #print t
         A = (-C - B*t)/t**2
 
-        print A, B, C
+        print(A, B, C)
 
         #should be minimum
         tn = -B/(2*A)
@@ -326,10 +326,10 @@
         fCand = fcn(xCand, *args)
         nFeval += 1
 
-        print 'q\t', tn,  x0, xCand, fval, fCand
+        print('q\t', tn,  x0, xCand, fval, fCand)
 
         if fCand < fval:
-            print 'Accepting quad est.'
+            print('Accepting quad est.')
             x0[:] = xCand[:]
             fval = fCand
             changed = True
@@ -343,9 +343,9 @@
         #if not changed:
         stepsize *=.1
 
-    print 'Optimisation terminated:'
-    print 'nIterations: %d' % nIters
-    print 'nFevals: %d' % nFeval
+    print('Optimisation terminated:')
+    print('nIterations: %d' % nIters)
+    print('nFevals: %d' % nFeval)
 
     return x0 #, xts
 
--- ./PYME/Analysis/multicolourMeta.py	(original)
+++ ./PYME/Analysis/multicolourMeta.py	(refactored)
@@ -92,7 +92,7 @@
 
 def drawPairwiseGraphs(chan1, chan2):
     r1, r2 = getChannelPair(chan1, chan2)
-    print len(r1), len(r2)
+    print(len(r1), len(r2))
     figure(3)
     plot(r1['nEvents'], r2['nEvents'], '.', ms=3, label=chan2)
     #print n.max()
--- ./PYME/Analysis/ofind.py	(original)
+++ ./PYME/Analysis/ofind.py	(refactored)
@@ -380,7 +380,7 @@
                 im[-5:, -5:] = 0
                 im[-5:, 0:5] = 0
 
-                print len(xs)
+                print(len(xs))
 
         xs = numpy.array(xs)
         ys = numpy.array(ys)
--- ./PYME/Analysis/ofind3d.py	(original)
+++ ./PYME/Analysis/ofind3d.py	(refactored)
@@ -208,7 +208,7 @@
         if (self.numThresholdSteps == 0): #don't do threshold scan - just use lower threshold (faster)
             im = maskedFilteredData
             #View3D(im)
-            print 'Threshold: %3.2f' %self.lowerThreshold
+            print('Threshold: %3.2f' %self.lowerThreshold)
             (labeledPoints, nLabeled) = ndimage.label(im > self.lowerThreshold)
             
             objSlices = ndimage.find_objects(labeledPoints)
@@ -228,7 +228,7 @@
             #generate threshold range - note slightly awkard specification of lowwer and upper bounds as the stop bound is excluded from arange
             #self.thresholdRange = scipy.arange(self.upperThreshold, self.lowerThreshold - (self.upperThreshold - self.lowerThreshold)/(self.numThresholdSteps -1), - (self.upperThreshold - self.lowerThreshold)/(self.numThresholdSteps))
             self.thresholdRange = scipy.logspace(np.log10(self.upperThreshold), np.log10(self.lowerThreshold), self.numThresholdSteps)
-            print 'Thresholds:', self.thresholdRange
+            print('Thresholds:', self.thresholdRange)
 
             #get a working copy of the filtered data
             im = maskedFilteredData.copy()
@@ -296,7 +296,7 @@
                     im[-5:, -5:] = 0
                     im[-5:, 0:5] = 0
 
-                print len(self)
+                print(len(self))
 
         #create pseudo lists to allow indexing along the lines of self.x[i]
         self.x = PseudoPointList(self, 'x')
--- ./PYME/Analysis/ofind_pri.py	(original)
+++ ./PYME/Analysis/ofind_pri.py	(refactored)
@@ -106,12 +106,12 @@
     PSFFilename = md.PSFFile
                 
     if (not (PSFFileName == PSFFilename)):
-        import cPickle
+        import pickle
         try:
             ps, vox = md.taskQueue.getQueueData(md.dataSourceID, 'PSF')
         except:
             fid = open(getFullExistingFilename(PSFFilename), 'rb')
-            ps, vox = cPickle.load(fid)
+            ps, vox = pickle.load(fid)
             fid.close()
             
         ps = ps.max(2)
@@ -128,7 +128,7 @@
         sepr = I[(I.size/2):].argmax()
         sepl = I[(I.size/2)::-1].argmax()
         
-        print sepr, sepl
+        print(sepr, sepl)
         
         lobeSeparation = sepr + sepl
 
@@ -450,7 +450,7 @@
                 im[-5:, -5:] = 0
                 im[-5:, 0:5] = 0
 
-                print len(xs)
+                print(len(xs))
 
         xs = numpy.array(xs)
         ys = numpy.array(ys)
--- ./PYME/Analysis/ofind_split.py	(original)
+++ ./PYME/Analysis/ofind_split.py	(refactored)
@@ -380,7 +380,7 @@
                 im[-5:, -5:] = 0
                 im[-5:, 0:5] = 0
 
-                print len(xs)
+                print(len(xs))
 
         xs = numpy.array(xs)
         ys = numpy.array(ys)
--- ./PYME/Analysis/ofind_xcorr.py	(original)
+++ ./PYME/Analysis/ofind_xcorr.py	(refactored)
@@ -25,7 +25,7 @@
 import scipy.signal
 import scipy.ndimage as ndimage
 import numpy
-import cPickle
+import pickle
 from scipy.fftpack import fftn, ifftn, ifftshift
 from PYME import pad
 from PYME.ParallelTasks.relativeFiles import getFullExistingFilename
@@ -48,7 +48,7 @@
             ps, vox = md.taskQueue.getQueueData(md.dataSourceID, 'PSF')
         except:
             fid = open(getFullExistingFilename(PSFFilename), 'rb')
-            ps, vox = cPickle.load(fid)
+            ps, vox = pickle.load(fid)
             fid.close()
             
         ps = ps.max(2)
@@ -325,7 +325,7 @@
                 im[-5:, -5:] = 0
                 im[-5:, 0:5] = 0
 
-                print len(xs)
+                print(len(xs))
 
         xs = scipy.array(xs)
         ys = scipy.array(ys)
--- ./PYME/Analysis/ofind_xcorr_fw.py	(original)
+++ ./PYME/Analysis/ofind_xcorr_fw.py	(refactored)
@@ -25,7 +25,7 @@
 import scipy.signal
 import scipy.ndimage as ndimage
 import numpy
-import cPickle
+import pickle
 from scipy.fftpack import fftn, ifftn, ifftshift
 
 #import fftw3
@@ -142,7 +142,7 @@
             ps, vox = md.taskQueue.getQueueData(md.dataSourceID, 'PSF')
         except:
             fid = open(getFullExistingFilename(PSFFilename), 'rb')
-            ps, vox = cPickle.load(fid)
+            ps, vox = pickle.load(fid)
             fid.close()     
         
         FTW = fftwWeiner(ps,vox, PSSize)
--- ./PYME/Analysis/piecewiseMapping.py	(original)
+++ ./PYME/Analysis/piecewiseMapping.py	(refactored)
@@ -36,7 +36,7 @@
     sfr = array([int(e['EventDescr']) for e in startEvents])
 
     si = startEvents['Time'].searchsorted(t, side='right')
-    print si, startEvents, sfr
+    print(si, startEvents, sfr)
     try:
         if len(si) > 1:
             si = si[-1]
--- ./PYME/Analysis/pointFitConfoc.py	(original)
+++ ./PYME/Analysis/pointFitConfoc.py	(refactored)
@@ -104,7 +104,7 @@
 
     of.write('ID\tx\ty\tA\tsigma\tcorrectedFWHM\n')
 
-    for r, i in zip(res, range(len(res))):
+    for r, i in zip(res, list(range(len(res)))):
         of.write('%d\t%3.2f\t%3.2f\t%3.2f\t%3.2f\t%3.0f\n' % (i, r['fitResults']['x0']/1e3, r['fitResults']['y0']/1e3, r['fitResults']['A'], r['fitResults']['sigma'], sqrt((2.35*r['fitResults']['sigma'])**2 - scopeFWHM**2)))
 
     of.close()
--- ./PYME/Analysis/processLogger.py	(original)
+++ ./PYME/Analysis/processLogger.py	(refactored)
@@ -21,10 +21,10 @@
 
 def dictToRecarray(d):
         '''Create a 1 entry recarray from a dictionay'''
-        dt = np.dtype([(k, _upstr(np.array(v).dtype)) for k, v in d.items()])
+        dt = np.dtype([(k, _upstr(np.array(v).dtype)) for k, v in list(d.items())])
         
         ra = np.zeros(1, dt)
-        for k,v in d.items():
+        for k,v in list(d.items()):
             ra[k] = v
         
         return ra
@@ -91,7 +91,7 @@
             
 class BackendBase(object):
     def AddRecord(self, table, record):
-        print table, record
+        print(table, record)
         
 PL = ContextManager(BackendBase())
 
--- ./PYME/Analysis/remFitBuf.py	(original)
+++ ./PYME/Analysis/remFitBuf.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 from PYME.ParallelTasks import taskDef
-import ofind
+from . import ofind
 #import ofind_nofilt #use for drift estimation - faster
 #import ofind_xcorr
 #try:
@@ -32,8 +32,8 @@
     #fall back on fftpack in scipy
     #this was only marginally slower at last benchmark implying much of the 
     #cost is not in the ffts
-import ofind_xcorr
-import ofind_pri
+from . import ofind_xcorr
+from . import ofind_pri
     
 import numpy
 import numpy as np
@@ -175,7 +175,7 @@
             #starting from scratch
             self._createBuffers(self.initSize, data.shape, data.dtype)
             
-            self.availableSlots += range(self.initSize)
+            self.availableSlots += list(range(self.initSize))
             
         else:
             #keep a copy of the existing data
@@ -193,11 +193,11 @@
             self.validData[:oldsize] = ov
             
             #add new frames to list of availiable frames
-            self.availableSlots += range(oldsize, newsize)
+            self.availableSlots += list(range(oldsize, newsize))
             
     def getPercentile(self, pctile):
         pcIDX = int(self.validData.sum()*pctile)
-        print pcIDX
+        print(pcIDX)
         
         return (self.frameBuffer*(self.indices==pcIDX)).max(0).squeeze()
             
--- ./PYME/Analysis/tCluster.py	(original)
+++ ./PYME/Analysis/tCluster.py	(refactored)
@@ -28,7 +28,7 @@
 def cluster(T):
     edb = genEdgeDB(T)
     nodeNum = -1*np.ones(T.x.shape)
-    nodeInfo = sys.maxint*np.ones((len(T.x), 2))
+    nodeInfo = sys.maxsize*np.ones((len(T.x), 2))
 
     curNode = 0
 
--- ./PYME/Analysis/twoColDep.py	(original)
+++ ./PYME/Analysis/twoColDep.py	(refactored)
@@ -23,9 +23,9 @@
 
 import numpy as np
 import scipy as sp
-import ofind
+from . import ofind
 from PYME.Analysis.FitFactories.LatGaussFitFRTC import FitFactory, FitResultsDType
-import MetaData
+from . import MetaData
 
 def fitDep(g,r,ofindThresh, dx, dy):
     rg = r + g #detect objects in sum image
--- ./PYME/Analysis/twoColour.py	(original)
+++ ./PYME/Analysis/twoColour.py	(refactored)
@@ -24,9 +24,9 @@
 #from PYME.FileUtils.read_kdf import ReadKdfData
 import numpy as np
 import scipy as sp
-import ofind
+from . import ofind
 from PYME.Analysis.FitFactories.LatGaussFitFR import FitFactory, FitResultsDType
-import MetaData
+from . import MetaData
 from scipy.interpolate import Rbf, SmoothBivariateSpline
 from matplotlib import delaunay
 import tables
@@ -92,7 +92,7 @@
     def __init__(self, x, dx, var=1, axis='x'):
         #do a simple linear fit to estimate start parameters
         pstart = linalg.lstsq(np.vstack([x, np.ones_like(x)]).T, dx)[0]
-        print pstart
+        print(pstart)
         
         #now do a maximum likelihood fit with our robust lhood function
         self.m, self.x0 = fmin(robustLinLhood, [pstart[0],-pstart[1]/pstart[0]], args=(x, dx, var))
@@ -119,7 +119,7 @@
     def __init__(self, x, y, dx, var=1):
         #do a simple linear fit to estimate start parameters
         pstart = linalg.lstsq(np.vstack([x, y, np.ones_like(x)]).T, dx)[0]
-        print pstart
+        print(pstart)
         
         #now do a maximum likelihood fit with our robust lhood function
         self.mx, self.my, self.x0 = fmin(robustLin2Lhood, pstart, args=(x, y,dx, var))
@@ -159,7 +159,7 @@
         y = y*self.sc
         #do a simple linear fit to estimate start parameters
         pstart = linalg.lstsq(np.vstack([x, y, x*x, y*y, x*y, x*y*y, x*x*y,x*x*x, np.ones_like(x)]).T, dx)[0]
-        print pstart
+        print(pstart)
         
         
         #now do a maximum likelihood fit with our robust lhood function
@@ -258,7 +258,7 @@
             nsx.append(sx[i])
             nsy.append(sy[i])
         else:
-            print 'point %d dropped' %i
+            print('point %d dropped' %i)
 
     nx = np.array(nx)
     ny = np.array(ny)
@@ -316,7 +316,7 @@
     #wonky = findWonkyVectors(nx, ny, nsx, nsy, tol=100)
     good = wonky == 0
 
-    print '%d wonky vectors found and discarded' % wonky.sum()
+    print('%d wonky vectors found and discarded' % wonky.sum())
     
     if bbox:
         spx = SmoothBivariateSpline(nx[good], ny[good], nsx[good], 1./err_sx[good], bbox=bbox)
--- ./PYME/Analysis/twoColourPlot.py	(original)
+++ ./PYME/Analysis/twoColourPlot.py	(refactored)
@@ -47,7 +47,7 @@
     dx1 = spx.ev(x,y)
     dy1 = spy.ev(x,y)
     
-    print dx1.shape, dx.shape
+    print(dx1.shape, dx.shape)
     
     dist = sqrt((dx1 - dx)**2 + (dy1 - dy)**2)
     quiver(x, y, dx1 - dx, dy1 - dy, dist, scale=2e2, clim=(0, dist.mean()*2))
@@ -60,7 +60,7 @@
     dx1 = spx.ev(x,y)
     dy1 = spy.ev(x,y)
     
-    print dx1.shape, dx.shape
+    print(dx1.shape, dx.shape)
     
     dist = sqrt((dx1 - dx)**2 + (dy1 - dy)**2)
     quiver(x, y, dx1 - dx, dy1 - dy, dist, scale=2e2, clim=(0, dist.mean()*2))
--- ./PYME/Analysis/Auto/auto_photophysics.py	(original)
+++ ./PYME/Analysis/Auto/auto_photophysics.py	(refactored)
@@ -16,13 +16,13 @@
 
 
 def analyseFile(filename):
-    print filename
+    print(filename)
     seriesName = os.path.splitext(os.path.split(filename)[-1])[0]
     PL.ExtendContext({'seriesName':seriesName})
     try:
         pipe = Pipeline(filename)
     except RuntimeError:
-        print 'Error opening %s' % filename
+        print('Error opening %s' % filename)
         PL.PopContext()
         return
     
--- ./PYME/Analysis/BleachProfile/fitRecover.py	(original)
+++ ./PYME/Analysis/BleachProfile/fitRecover.py	(refactored)
@@ -20,8 +20,8 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-import intensProf
-import kinModels
+from . import intensProf
+from . import kinModels
 from pylab import *
 from PYME.Analysis._fithelpers import *
 
--- ./PYME/Analysis/BleachProfile/intensProf.py	(original)
+++ ./PYME/Analysis/BleachProfile/intensProf.py	(refactored)
@@ -26,7 +26,7 @@
 import wx
 from pylab import *
 
-import deMod
+from . import deMod
 
 def calcProf(fn_list):
     sm = zeros(len(fn_list), 'f')
@@ -41,7 +41,7 @@
         if inWxApp:
             pb.Update(i, 'Processing slice %d of %d' % (i,len(fn_list)))
         else:
-            print fn_list[i]
+            print(fn_list[i])
 
         try:
             ds_a = ReadKdfData(fn_list[i])[:,:,0]
--- ./PYME/Analysis/BleachProfile/kinModels.py	(original)
+++ ./PYME/Analysis/BleachProfile/kinModels.py	(refactored)
@@ -39,9 +39,9 @@
 def munge_res(model, res, **kwargs):
     #res = FitModel(model, startParams, data, *args)
     #if mse:
-    r = np.hstack([res[0],] + kwargs.values())
-
-    dt = np.dtype({'names':model.paramNames + kwargs.keys(), 'formats':len(r)*[r.dtype.str]})
+    r = np.hstack([res[0],] + list(kwargs.values()))
+
+    dt = np.dtype({'names':model.paramNames + list(kwargs.keys()), 'formats':len(r)*[r.dtype.str]})
     #else:
     #    r = res[0]
     #
@@ -198,7 +198,7 @@
         chans = colourFilter.getColourChans()
         
         if USE_GUI:
-            figure(os.path.split(pipeline.filename)[-1] + ' - ' + fcn.func_name)
+            figure(os.path.split(pipeline.filename)[-1] + ' - ' + fcn.__name__)
     
         if len(chans) == 0:
             fcn(colourFilter, metadata)
@@ -218,7 +218,7 @@
                     if lab[i][0] in chanNames:
                         chanNames[chanNames.index(lab[i][0])] = lab[i][1]
     
-            for ch, i in zip(chans, range(len(chans))):
+            for ch, i in zip(chans, list(range(len(chans)))):
                 colourFilter.setColour(ch)
                 PL.ExtendContext({'chan': chanNames[i]})
                 if 'rng' in args:
@@ -381,7 +381,7 @@
     yb = ybins[:-1][None, :]*ones([xbins.size - 1, 1])    
     
     res0 = FitModel(fITmod2, [n.max()*3, 1, np.median(nPh), 20, 1e2, 1e2, 100], n, xb, yb, Nco)
-    print res0[0]
+    print(res0[0])
     
     PL.AddRecord('/Photophysics/FluorBrightness/fITmod2', munge_res(fITmod2,res0))
     
@@ -425,7 +425,7 @@
         #sc = (lamb/(ybins[1] - ybins[0]))
         #sc = len(ybins)
         sc = 1./(1 - exp(-(ybins[1] - ybins[0])/lamb))
-        print 'sc = ', sc
+        print('sc = ', sc)
         y1 = sc*A/((t_/tauI)**a + 1)
         plot(t_, y1)
         plot(t_, sc*(Ndet/((t_/tauI)**a + 1) + NDetM))
--- ./PYME/Analysis/BleachProfile/rawIntensity.py	(original)
+++ ./PYME/Analysis/BleachProfile/rawIntensity.py	(refactored)
@@ -140,7 +140,7 @@
     
     r0 = FitModel(linMod, [-1, -1, full_bleach[0],full_bleach[3] - init_bleach[-1]], hstack((init_bleach[-40:], full_bleach[5:40])), 
                   hstack((t_init[-40:], t_full[5:40])) - t_init[-1])
-    print r0[0]
+    print(r0[0])
     
     figure()
     t_ = hstack((t_init[-40:], t_full[5:40])) - t_init[-1]
@@ -160,26 +160,26 @@
     #ds3 = t[ds] - t2[0]
     
     r = FitModelWeighted(dyedyemod, [I2[0], 1., I2[-1]], I2, sqrt(I2)/4, t3)
-    print r[0]
+    print(r[0])
     
     #r2 = FitModel(dyedyemod2, [I2[0], 1., I2[-1], 0.], I2, t3, ds3)
     #print r2[0]
     
     r3 = FitModel(dyedyemod, [init_bleach[0], .01, full_bleach[-1]], init_bleach, t_init - t_init[0])
-    print r3[0]
-    
-    print [init_bleach[0], .01, full_bleach[-1]]
+    print(r3[0])
+    
+    print([init_bleach[0], .01, full_bleach[-1]])
     
     r4 = FitModel(dyedyemod, [init_bleach[0], .1, full_bleach[-1]], full_bleach, t_full - t_init[0])
-    print r4[0]
+    print(r4[0])
     
     #r5 = FitModel(dyedyemoda, [sqrt(init_bleach[0]), .01, full_bleach[-1]], full_bleach, t_full - t_init[0])
     #print r5[0]
     
     A0 = init_bleach[0] 
-    print A0
+    print(A0)
     r6 = FitModelWeighted(dyedyemodt, [A0, dt, full_bleach[-1], 1.], I2, sqrt(I2)/4, t3)
-    print r6[0]
+    print(r6[0])
     
     figure()
     plot(t_init, init_bleach)
--- ./PYME/Analysis/Colocalisation/colocScaleDep.py	(original)
+++ ./PYME/Analysis/Colocalisation/colocScaleDep.py	(refactored)
@@ -21,9 +21,9 @@
 ##################
 import numpy as np
 from scipy import ndimage
-import correlationCoeffs
+from . import correlationCoeffs
 from pylab import *
-import edtColoc
+from . import edtColoc
 import Image
 
 DIRNAME='/home/david/Desktop/coloc/'
--- ./PYME/Analysis/DataSources/AlignDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/AlignDataSource.py	(refactored)
@@ -21,7 +21,7 @@
 ##################
 import numpy as np
 from scipy import ndimage
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 
 class DataSource(BaseDataSource): 
     moduleName = 'AlignDataSource'
@@ -50,7 +50,7 @@
         return ndimage.shift(sl, self.pixelShifts[:2], cval=sl.min())
     
     def getSlice(self,ind):
-        if ind in self.buffer.keys():
+        if ind in list(self.buffer.keys()):
             return self.buffer[ind]
         else:
             zs = self.pixelShifts[2]
--- ./PYME/Analysis/DataSources/BGSDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/BGSDataSource.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 import numpy as np
 
 class dataBuffer: #buffer our io to avoid decompressing multiple times
@@ -101,7 +101,7 @@
         
     def _indexAdd(self,data, slot):
         self.indices[slot,:,:] = 0
-        for i in xrange(self.frameBuffer.shape[0]):
+        for i in range(self.frameBuffer.shape[0]):
             if not i == slot:
                 dg = (self.frameBuffer[i,:,:] > data).astype('uint16')
                 self.indices[slot, :,:] += (1 - dg)
@@ -146,7 +146,7 @@
             #starting from scratch
             self._createBuffers(self.initSize, data.shape, data.dtype)
             
-            self.availableSlots += range(self.initSize)
+            self.availableSlots += list(range(self.initSize))
             
         else:
             #keep a copy of the existing data
@@ -164,11 +164,11 @@
             self.validData[:oldsize] = ov
             
             #add new frames to list of availiable frames
-            self.availableSlots += range(oldsize, newsize)
+            self.availableSlots += list(range(oldsize, newsize))
             
     def getPercentile(self, pctile):
         pcIDX = int(self.validData.sum()*pctile)
-        print pcIDX
+        print(pcIDX)
         
         return (self.frameBuffer*(self.indices==pcIDX)).max(0).squeeze()
             
@@ -228,7 +228,7 @@
                 step = self.bgRange[2]
             else:
                 step = 1
-            bgi = range(max(ind + self.bgRange[0],self.dataStart), max(ind + self.bgRange[1],self.dataStart), step)
+            bgi = list(range(max(ind + self.bgRange[0],self.dataStart), max(ind + self.bgRange[1],self.dataStart), step))
             #print len(bgi)
             if len(bgi) > 0:
                 return sl - self.bBuffer.getBackground(bgi)
--- ./PYME/Analysis/DataSources/BufferedDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/BufferedDataSource.py	(refactored)
@@ -20,7 +20,7 @@
 #
 ##################
 import numpy
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 import threading
 
 class DataSource(BaseDataSource): #buffer our io to avoid decompressing multiple times
--- ./PYME/Analysis/DataSources/FlatFieldDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/FlatFieldDataSource.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 from PYME.ParallelTasks.relativeFiles import getFullFilename
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 #import tables
 
 class DataSource(BaseDataSource):
@@ -40,7 +40,7 @@
         y0 = mdh.getEntry('Camera.ROIPosY') - 1
         y1 = y0 + mdh.getEntry('Camera.ROIHeight') + 1
 
-        print x0, x1, y0, y1
+        print(x0, x1, y0, y1)
 
         #self.offset = mdh.getEntry()
 
@@ -50,7 +50,7 @@
     def getSlice(self, ind):
         #if ind >= self.h5File.root.ImageData.shape[0]:
         #        self.reloadData() #try reloading the data in case it's grown
-        print self.getSliceShape(), self.flat.shape
+        print(self.getSliceShape(), self.flat.shape)
         
         return (self.source.getSlice(ind) - self.mdh.getEntry('Camera.ADOffset'))*self.flat
 
--- ./PYME/Analysis/DataSources/HDFDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/HDFDataSource.py	(refactored)
@@ -23,7 +23,7 @@
 
 from PYME.ParallelTasks.relativeFiles import getFullFilename
 import tables
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 
 class DataSource(BaseDataSource):
     moduleName = 'HDFDataSource'
--- ./PYME/Analysis/DataSources/ImageSeriesDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/ImageSeriesDataSource.py	(refactored)
@@ -28,7 +28,7 @@
 import glob
 import os
 import numpy as np
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 #from PYME.misc import TiffImagePlugin #monkey patch PIL with improved tiff support from Priithon
 
 #import numpy as np
@@ -60,8 +60,8 @@
         if self.im0.ifd.prefix =='MM':
             self.endedness = 'BE'
             
-        print self.im0.ifd.prefix
-        print self.endedness
+        print(self.im0.ifd.prefix)
+        print(self.endedness)
 
         #to find the number of images we have to loop over them all
         #this is obviously not ideal as PIL loads the image data into memory for each
--- ./PYME/Analysis/DataSources/TQDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/TQDataSource.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ##################
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 
 class DataSource(BaseDataSource):
     moduleName = 'TQDataSource'
--- ./PYME/Analysis/DataSources/TiffDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/TiffDataSource.py	(refactored)
@@ -29,7 +29,7 @@
 #import numpy as np
 
 from PYME.gohlke import tifffile
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 
 class DataSource(BaseDataSource):
     moduleName = 'TiffDataSource'
@@ -63,7 +63,7 @@
         #except EOFError:
         #    pass
 
-        print self.filename
+        print(self.filename)
 
         self.im = tifffile.TIFFfile(self.filename).series[0].pages
 
--- ./PYME/Analysis/DataSources/UnsplitDataSource.py	(original)
+++ ./PYME/Analysis/DataSources/UnsplitDataSource.py	(refactored)
@@ -20,7 +20,7 @@
 #
 ##################
 import numpy
-from BaseDataSource import BaseDataSource
+from .BaseDataSource import BaseDataSource
 
 class DataSource(BaseDataSource): 
     moduleName = 'UnsplitDataSource'
--- ./PYME/Analysis/DeClump/pyDeClump.py	(original)
+++ ./PYME/Analysis/DeClump/pyDeClump.py	(refactored)
@@ -97,7 +97,7 @@
     #all the points within a certain range of frames
     frameIndices = (nRes + 2)*np.ones(t.max() + 10, 'int32')
 
-    for t_i, i in zip(t, range(nRes)):
+    for t_i, i in zip(t, list(range(nRes))):
         frameIndices[:(t_i+1)] = np.minimum(frameIndices[:(t_i+1)], i)
 
     #print frameIndices
@@ -131,11 +131,11 @@
 
     fres = np.empty(NClumps, dt)
     
-    clist = [[] for i in xrange(NClumps)]
+    clist = [[] for i in range(NClumps)]
     for i, c in enumerate(assigned):
         clist[int(c-1)].append(i)
 
-    for i in xrange(NClumps):
+    for i in range(NClumps):
             #coalesce the connected ponts into one
             vals = fitResults[clist[i]]
 
--- ./PYME/Analysis/DeClump/testClump.py	(original)
+++ ./PYME/Analysis/DeClump/testClump.py	(refactored)
@@ -27,11 +27,11 @@
 
 
 t = arange(0, 200, .02)
-print len(t)
+print(len(t))
 x = randn(10000)
 y = randn(10000)
 delta_x = .05*ones(x.shape)
 
 asg = deClump.findClumps(t.astype('i'), x.astype('f4'), y.astype('f4'), delta_x.astype('f4'), 2)
 
-print asg
+print(asg)
--- ./PYME/Analysis/DistHist/__init__.py	(original)
+++ ./PYME/Analysis/DistHist/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from distHist import *
+from .distHist import *
--- ./PYME/Analysis/EdgeDB/__init__.py	(original)
+++ ./PYME/Analysis/EdgeDB/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from edges import *
+from .edges import *
--- ./PYME/Analysis/EdgeDB/edgeTest.py	(original)
+++ ./PYME/Analysis/EdgeDB/edgeTest.py	(refactored)
@@ -21,10 +21,10 @@
 #
 ################
 from pylab import *
-import edges
+from . import edges
 from matplotlib import delaunay
 
-import segment
+from . import segment
 
 
 x = rand(1e6)
@@ -43,20 +43,20 @@
 
 E = edges.EdgeDB(T)
 
-print "foo"
+print("foo")
 
 #print E.edgeArray[len(x):, 0]
-print E.edgeArray[0]
+print(E.edgeArray[0])
 
 #ei= E.edgeArray[:len(x)]
 
 #print ei[ei['numIncidentEdges']>=7, :]
 #print ei
 
-print E.getVertexEdgeLengths(5)
-print E.getVertexNeighbours(5)
+print(E.getVertexEdgeLengths(5))
+print(E.getVertexNeighbours(5))
 
-print E.getNeighbourDists()
+print(E.getNeighbourDists())
 
 #objects = segment.segment(E, .002)
 
--- ./PYME/Analysis/EdgeDB/edges.py	(original)
+++ ./PYME/Analysis/EdgeDB/edges.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-from edgeDB import *
+from .edgeDB import *
 import numpy
 import threading
 #from PYME.ParallelTasks.launchWorkers import cpuCount
@@ -60,7 +60,7 @@
             N = len(coords[0])
 
             taskSize = N/multiprocessing.cpu_count()
-            taskEdges = range(0,N, taskSize) + [N]
+            taskEdges = list(range(0,N, taskSize)) + [N]
 
             tasks = [(taskEdges[i], taskEdges[i+1]) for i in range(len(taskEdges)-1)]
             #print tasks
--- ./PYME/Analysis/EdgeDB/segment.py	(original)
+++ ./PYME/Analysis/EdgeDB/segment.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-import edges
+from . import edges
 import numpy
 
 def collectConnected(edb, vertexNum, visited, lenThresh, objectNum):
--- ./PYME/Analysis/FitFactories/ConfocCOIR.py	(original)
+++ ./PYME/Analysis/FitFactories/ConfocCOIR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, Xg, Yg, Xr, Yr):
--- ./PYME/Analysis/FitFactories/FFBase.py	(original)
+++ ./PYME/Analysis/FitFactories/FFBase.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import numpy as np
-import fitCommon
+from . import fitCommon
 
 class FitFactory(object):
     def __init__(self, data, metadata, fitfcn=None, background=None):
--- ./PYME/Analysis/FitFactories/Gauss3DFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/Gauss3DFitR.py	(refactored)
@@ -30,7 +30,7 @@
 
 from PYME.Analysis._fithelpers import *
 
-import copy_reg
+import copyreg
 
 def pickleSlice(slice):
         return unpickleSlice, (slice.start, slice.stop, slice.step)
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 
@@ -181,7 +181,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(dataROI.size- len(res1)))
-        except Exception, e:
+        except Exception as e:
             pass
         #print 'foo'
         fr = Gauss3dFitResultR(res1, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
--- ./PYME/Analysis/FitFactories/GaussMultifitR.py	(original)
+++ ./PYME/Analysis/FitFactories/GaussMultifitR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 #from pylab import *
-import copy_reg
+import copyreg
 import numpy
 #import types
 
@@ -41,7 +41,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2dSlow(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -216,7 +216,7 @@
 #        pylab.figure()
         #starting guesses
         labels, nlabels = ndimage.label(mask)
-        print nlabels, mask.sum()
+        print(nlabels, mask.sum())
             
         objSlices = ndimage.find_objects(labels)
         
@@ -271,7 +271,7 @@
         nchi2 = ((residual/s_m)**2).mean()
         resmax = (residual/s_m).max()
         
-        print nchi2, resmax
+        print(nchi2, resmax)
 
         refinementCount = 0  #prevent an infinite loop here      
         
@@ -290,7 +290,7 @@
             nchi2 = ((residual/s_m)**2).mean()
             resmax = (residual/s_m).max()
             
-            print nchi2, resmax
+            print(nchi2, resmax)
             
             
 
@@ -309,7 +309,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         #print res, fitErrors, resCode
         #recreate a list of events in the desired format
--- ./PYME/Analysis/FitFactories/GaussMultifitSR.py	(original)
+++ ./PYME/Analysis/FitFactories/GaussMultifitSR.py	(refactored)
@@ -23,7 +23,7 @@
 
 import scipy
 import scipy.ndimage as ndimage
-import copy_reg
+import copyreg
 import numpy
 
 from PYME.Analysis.cModels.gauss_app import *
@@ -35,7 +35,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
     
 def f_multiGaussS(p, X, Y, s):
@@ -285,7 +285,7 @@
                     
                     if gui ==2:
                         plotIterate(res, os, residual/s_m, resf)
-                        print nEvents, nchi2, resmax, resCode#, cov_x
+                        print(nEvents, nchi2, resmax, resCode)#, cov_x
                     
                     
     
@@ -293,7 +293,7 @@
                 fitErrors=None
                 try:       
                     fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(d_m)- len(res)))
-                except Exception, e:
+                except Exception as e:
                     pass
                 #print res, fitErrors, resCode
                 #recreate a list of events in the desired format
@@ -340,7 +340,7 @@
               #mde.FilenameParam('PSFFilename', 'PSF:', prompt='Please select PSF to use ...', wildcard='PSF Files|*.psf'),
               #mde.ShiftFieldParam('chroma.ShiftFilename', 'Shifts:', prompt='Please select shiftfield to use', wildcard='Shiftfields|*.sf'),
               #mde.IntParam('Analysis.DebounceRadius', 'Debounce r:', 4),
-              mde.FloatParam('Analysis.PSFSigma', u'PSF \u03c3  [nm]:', 130.),
+              mde.FloatParam('Analysis.PSFSigma', 'PSF \u03c3  [nm]:', 130.),
               mde.FloatParam('Analysis.ResidualMax', 'Max residual:', 0.25),
               #mde.ChoiceParam('Analysis.EstimatorModule', 'Z Start Est:', 'astigEstimator', choices=zEstimators.estimatorList),
               #mde.ChoiceParam('PRI.Axis', 'PRI Axis:', 'y', choices=['x', 'y'])
--- ./PYME/Analysis/FitFactories/InterpFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/InterpFitR.py	(refactored)
@@ -25,10 +25,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis._fithelpers import *
 #from PYME.Analysis.FitFactories.zEstimators import astigEstimator
@@ -39,7 +39,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d(p, interpolator, X, Y, Z, safeRegion, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -155,10 +155,10 @@
         if fitfcn == f_Interp3d:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -178,7 +178,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
 #        if 'Analysis.EstimatorModule' in md.getEntryNames():
@@ -247,7 +247,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/InterpFitWFR.py	(original)
+++ ./PYME/Analysis/FitFactories/InterpFitWFR.py	(refactored)
@@ -25,10 +25,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis._fithelpers import *
 #from PYME.Analysis.FitFactories.zEstimators import astigEstimator
@@ -39,7 +39,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d(p, interpolator, X, Y, Z, safeRegion, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -154,10 +154,10 @@
         if fitfcn == f_Interp3d:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -177,7 +177,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         X, Y, Z, safeRegion = interpolator.getCoords(md, slice(-roiHalfSize,roiHalfSize + 1), slice(-roiHalfSize,roiHalfSize + 1), slice(0,1))
@@ -251,7 +251,7 @@
             fitErrors=None
             try:
                 fitErrors = scipy.sqrt(scipy.diag(cov_x0) * (infodict0['fvec'] * infodict0['fvec']).sum() / (len(dataROI.ravel())- len(res0)))
-            except Exception, e:
+            except Exception as e:
                 pass
     
             #print res, fitErrors, resCode
@@ -261,7 +261,7 @@
             fitErrors=None
             try:
                 fitErrors = scipy.sqrt(scipy.diag(cov_x1) * (infodict1['fvec'] * infodict1['fvec']).sum() / (len(dataROI.ravel())- len(res1)))
-            except Exception, e:
+            except Exception as e:
                 pass
     
             #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/LatFitCOIR.py	(original)
+++ ./PYME/Analysis/FitFactories/LatFitCOIR.py	(refactored)
@@ -22,8 +22,8 @@
 ##################
 
 import numpy as np
-from fitCommon import fmtSlicesUsed 
-import FFBase 
+from .fitCommon import fmtSlicesUsed 
+from . import FFBase 
 
 #define the format of the results
 fresultdtype=[('tIndex', '<i4'),
--- ./PYME/Analysis/FitFactories/LatGaussFitFR.py	(original)
+++ ./PYME/Analysis/FitFactories/LatGaussFitFR.py	(refactored)
@@ -22,8 +22,8 @@
 ##################
 
 import numpy as np
-from fitCommon import fmtSlicesUsed 
-import FFBase 
+from .fitCommon import fmtSlicesUsed 
+from . import FFBase 
 
 from PYME.Analysis.cModels.gauss_app import genGauss,genGaussJac, genGaussJacW
 from PYME.Analysis._fithelpers import FitModelWeighted, FitModelWeightedJac
--- ./PYME/Analysis/FitFactories/LatGaussFitlmR.py	(original)
+++ ./PYME/Analysis/FitFactories/LatGaussFitlmR.py	(refactored)
@@ -25,7 +25,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 #from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -41,7 +41,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 
@@ -157,7 +157,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResultR(res, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/LatObjFindFR.py	(original)
+++ ./PYME/Analysis/FitFactories/LatObjFindFR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 #from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -41,7 +41,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 #def f_gauss2d(p, X, Y):
 #    """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
--- ./PYME/Analysis/FitFactories/LatPSFFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/LatPSFFitR.py	(refactored)
@@ -30,7 +30,7 @@
 
 from PYME.Analysis._fithelpers import *
 
-import copy_reg
+import copyreg
 
 def pickleSlice(slice):
         return unpickleSlice, (slice.start, slice.stop, slice.step)
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 
@@ -156,7 +156,7 @@
         (res2, cov_x2, infodict2, mesg2, resCode2) = FitModelWeighted(f_PSF3d, startParameters2, dataROI, sigma, X, Y, Z, P, 2*scipy.pi/488, 1.47, 50e3)
         misfit2 = (infodict2['fvec']**2).sum()
         
-        print 'Misfit above = %f, Misfit below = %f' % (misfit1, misfit2)
+        print('Misfit above = %f, Misfit below = %f' % (misfit1, misfit2))
         #print res
         #print scipy.sqrt(diag(cov_x))
         #return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode)
--- ./PYME/Analysis/FitFactories/PRInterpFitQR.py	(original)
+++ ./PYME/Analysis/FitFactories/PRInterpFitQR.py	(refactored)
@@ -25,10 +25,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis._fithelpers import *
 #from PYME.Analysis.FitFactories.zEstimators import astigEstimator
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d(p, interpolator, X, Y, Z, safeRegion, splitaxis, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -165,7 +165,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         X, Y, Z, safeRegion = interpolator.getCoords(md, xslice, yslice, slice(0,1))
@@ -211,10 +211,10 @@
         if fitfcn == f_Interp3d:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -234,7 +234,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         X, Y, Z, safeRegion = interpolator.getCoords(md, slice(-roiHalfSize + x,roiHalfSize + 1 + x), slice(-roiHalfSize + y,roiHalfSize + 1 + y), slice(0,1))
@@ -302,7 +302,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/PRInterpFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/PRInterpFitR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 #import cPickle
@@ -42,7 +42,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d(p, interpolator, X, Y, Z, safeRegion, splitaxis, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -163,7 +163,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         X, Y, Z, safeRegion = interpolator.getCoords(md, xslice, yslice, slice(0,1))
@@ -209,10 +209,10 @@
         if fitfcn == f_Interp3d:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -232,7 +232,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         X, Y, Z, safeRegion = interpolator.getCoords(md, slice(-roiHalfSize + x,roiHalfSize + 1 + x), slice(-roiHalfSize + y,roiHalfSize + 1 + y), slice(0,1))
@@ -300,7 +300,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/SpecGaussFitFR.py	(original)
+++ ./PYME/Analysis/FitFactories/SpecGaussFitFR.py	(refactored)
@@ -25,7 +25,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 #from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -41,7 +41,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss1d(p, X):
     """1D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -163,7 +163,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResultR(res, self.metadata, (xslice, xslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/SplitterFitCOIR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitCOIR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, Xg, Yg, Xr, Yr):
--- ./PYME/Analysis/FitFactories/SplitterFitFNR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitFNR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, Xg, Yg, Xr, Yr):
@@ -177,7 +177,7 @@
     d = np.zeros([Xr.shape[0], Yr.shape[0], 2], order='F')
     s = np.ones_like(d)
     buf = np.zeros(d.size)
-    print d.shape, Xr.shape, Yr.shape
+    print(d.shape, Xr.shape, Yr.shape)
     im = -splWrap(np.array(list(fitResults['fitResults'])), d, s, Xg, Yg, Xr, Yr, buf).reshape(d.shape, order='F')
 
     return np.hstack([im[:,:,0], im[:,:,1]]).squeeze()
@@ -333,7 +333,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #res = hstack([res, array([0,0,0,0])])
--- ./PYME/Analysis/FitFactories/SplitterFitFR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitFR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, Xg, Yg, Xr, Yr):
@@ -221,7 +221,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #res = hstack([res, array([0,0,0,0])])
--- ./PYME/Analysis/FitFactories/SplitterFitInterpNR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitInterpNR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -37,7 +37,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_Interp3d2c(p, interpolator, Xg, Yg, Zg, Xr, Yr, Zr, safeRegion, axialShift, *args):
@@ -174,10 +174,10 @@
         if fitfcn == f_Interp3d2c:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -197,7 +197,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         Xg, Yg, Zg, safeRegion = interpolator.getCoords(md, slice(-roiHalfSize,roiHalfSize + 1), slice(-roiHalfSize,roiHalfSize + 1), slice(0,1))
@@ -343,7 +343,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/SplitterFitInterpQR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitInterpQR.py	(refactored)
@@ -25,10 +25,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis._fithelpers import *
 #from PYME.Analysis.FitFactories.zEstimators import astigEstimator
@@ -39,7 +39,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d2c(p, interpolator, Xg, Yg, Zg, Xr, Yr, Zr, safeRegion, axialShift, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -135,10 +135,10 @@
         if fitfcn == f_Interp3d2c:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -158,7 +158,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
         Xg, Yg, Zg, safeRegion = interpolator.getCoords(md, slice(-roiHalfSize,roiHalfSize + 1), slice(-roiHalfSize,roiHalfSize + 1), slice(0,1))
@@ -281,7 +281,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/SplitterFitInterpR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitInterpR.py	(refactored)
@@ -25,10 +25,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis._fithelpers import *
 #from PYME.Analysis.FitFactories.zEstimators import astigEstimator
@@ -39,7 +39,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_Interp3d2c(p, interpolator, Xg, Yg, Zg, Xr, Yr, Zr, safeRegion, axialShift, *args):
     """3D PSF model function with constant background - parameter vector [A, x0, y0, z0, background]"""
@@ -165,10 +165,10 @@
         if fitfcn == f_Interp3d2c:
             if 'PSFFile' in metadata.getEntryNames():
                 if self.interpolator.setModelFromMetadata(metadata):
-                    print 'model changed'
+                    print('model changed')
                     self.startPosEstimator.splines.clear()
 
-                if not 'z' in self.startPosEstimator.splines.keys():
+                if not 'z' in list(self.startPosEstimator.splines.keys()):
                     self.startPosEstimator.calibrate(self.interpolator, metadata)
             else:
                 self.interpolator.genTheoreticalModel(metadata)
@@ -188,7 +188,7 @@
         startPosEstimator = __import__('PYME.Analysis.FitFactories.zEstimators.' + estimatorModule , fromlist=['PYME', 'Analysis','FitFactories', 'zEstimators'])        
         
         if interpolator.setModelFromFile(md.PSFFile, md):
-            print 'model changed'
+            print('model changed')
             startPosEstimator.splines.clear()
 
 #        if 'Analysis.EstimatorModule' in md.getEntryNames():
@@ -316,7 +316,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/SplitterFitQR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterFitQR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, Xg, Yg, Xr, Yr):
@@ -239,7 +239,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
 	#print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/SplitterMultifitSR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterMultifitSR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 #from pylab import *
-import copy_reg
+import copyreg
 import numpy
 #import types
 
@@ -41,7 +41,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2dSlow(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -349,7 +349,7 @@
                 fitErrors=None
                 try:       
                     fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(d_m)- len(res)))
-                except Exception, e:
+                except Exception as e:
                     pass
                 #print res, fitErrors, resCode
                 #recreate a list of events in the desired format
--- ./PYME/Analysis/FitFactories/SplitterObjFindR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterObjFindR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, X, Y):
@@ -174,7 +174,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/SplitterShiftEstFR.py	(original)
+++ ./PYME/Analysis/FitFactories/SplitterShiftEstFR.py	(refactored)
@@ -25,7 +25,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -43,7 +43,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 def f_gauss2d2c(p, X, Y):
@@ -173,7 +173,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/fitCommon.py	(original)
+++ ./PYME/Analysis/FitFactories/fitCommon.py	(refactored)
@@ -5,7 +5,7 @@
 @author: david
 """
 
-import copy_reg
+import copyreg
 
 def pickleSlice(slice):
         return unpickleSlice, (slice.start, slice.stop, slice.step)
@@ -13,7 +13,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def replNoneWith1(n):
         if n == None:
--- ./PYME/Analysis/FitFactories/Interpolators/CubicSplineInterpolator.py	(original)
+++ ./PYME/Analysis/FitFactories/Interpolators/CubicSplineInterpolator.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-from baseInterpolator import __interpolator
+from .baseInterpolator import __interpolator
 from numpy import *
 from scipy import ndimage
 
--- ./PYME/Analysis/FitFactories/Interpolators/LinearInterpolator.py	(original)
+++ ./PYME/Analysis/FitFactories/Interpolators/LinearInterpolator.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-from baseInterpolator import __interpolator
+from .baseInterpolator import __interpolator
 from numpy import *
 from PYME.Analysis.cInterp import cInterp
 
--- ./PYME/Analysis/FitFactories/Interpolators/LinearInterpolatorP.py	(original)
+++ ./PYME/Analysis/FitFactories/Interpolators/LinearInterpolatorP.py	(refactored)
@@ -20,7 +20,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-from baseInterpolator import __interpolator
+from .baseInterpolator import __interpolator
 from numpy import *
 
 class LinearInterpolator(__interpolator):
--- ./PYME/Analysis/FitFactories/loft/3DGaussFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/3DGaussFitR.py	(refactored)
@@ -19,7 +19,7 @@
 
 from PYME.Analysis._fithelpers import *
 
-import copy_reg
+import copyreg
 
 def pickleSlice(slice):
         return unpickleSlice, (slice.start, slice.stop, slice.step)
@@ -27,7 +27,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 
@@ -145,7 +145,7 @@
         (res2, cov_x2, infodict2, mesg2, resCode2) = FitModelWeighted(f_PSF3d, startParameters2, dataROI, sigma, X, Y, Z, P, 2*scipy.pi/488, 1.47, 50e3)
         misfit2 = (infodict2['fvec']**2).sum()
         
-        print 'Misfit above = %f, Misfit below = %f' % (misfit1, misfit2)
+        print('Misfit above = %f, Misfit below = %f' % (misfit1, misfit2))
         #print res
         #print scipy.sqrt(diag(cov_x))
         #return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode)
--- ./PYME/Analysis/FitFactories/loft/BiplaneFitR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/BiplaneFitR.py	(refactored)
@@ -14,7 +14,7 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
 
@@ -34,7 +34,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -278,7 +278,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/loft/LatGaussFit.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/LatGaussFit.py	(refactored)
@@ -14,7 +14,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 
 from scipy import weave
@@ -27,7 +27,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2d(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -128,7 +128,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/loft/LatGaussFitAF.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/LatGaussFitAF.py	(refactored)
@@ -14,7 +14,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 
 from gauss_app import *
@@ -29,7 +29,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2dA(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -140,7 +140,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/loft/LatGaussFitF.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/LatGaussFitF.py	(refactored)
@@ -14,7 +14,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 
 from PYME.Analysis.cModels.gauss_app import *
@@ -29,7 +29,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2d(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -150,7 +150,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/loft/LatGaussFitFJ.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/LatGaussFitFJ.py	(refactored)
@@ -14,7 +14,7 @@
 from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 
 from  cModels.gauss_ap import *
@@ -29,7 +29,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 def f_gauss2d(p, X, Y):
     """2D Gaussian model function with linear background - parameter vector [A, x0, y0, sigma, background, lin_x, lin_y]"""
@@ -151,7 +151,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x)*(infodict['fvec']*infodict['fvec']).sum()/(len(dataMean.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
         return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode, fitErrors)
 
--- ./PYME/Analysis/FitFactories/loft/LatPSFFit.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/LatPSFFit.py	(refactored)
@@ -18,7 +18,7 @@
 
 from _fithelpers import *
 
-import copy_reg
+import copyreg
 
 def pickleSlice(slice):
         return unpickleSlice, (slice.start, slice.stop, slice.step)
@@ -26,7 +26,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 
@@ -120,7 +120,7 @@
         (res2, cov_x2, infodict2, mesg2, resCode2) = FitModelWeighted(f_PSF3d, startParameters2, dataROI, sigma, X, Y, Z, P, 2*scipy.pi/525, 1.47, 10e3)
         misfit2 = (infodict2['fvec']**2).sum()
         
-        print 'Misfit above = %f, Misfit below = %f' % (misfit1, misfit2)
+        print('Misfit above = %f, Misfit below = %f' % (misfit1, misfit2))
         #print res
         #print scipy.sqrt(diag(cov_x))
         #return GaussianFitResult(res, self.metadata, (xslice, yslice, zslice), resCode)
--- ./PYME/Analysis/FitFactories/loft/PsfFitCSIR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/PsfFitCSIR.py	(refactored)
@@ -14,10 +14,10 @@
 #from scipy.signal import interpolate
 import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis import twist
 
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -79,7 +79,7 @@
 
     if not modName == interpModelName:
         mf = open(getFullExistingFilename(modName), 'rb')
-        mod, voxelsize = cPickle.load(mf)
+        mod, voxelsize = pickle.load(mf)
         mf.close()
         
         interpModelName = modName
@@ -312,7 +312,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/loft/PsfFitFTR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/PsfFitFTR.py	(refactored)
@@ -14,10 +14,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 #from math import floor, ceil
 
 from PYME.Analysis import twist
@@ -42,7 +42,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -95,7 +95,7 @@
 
     if not modName == interpModelName:
         mf = open(getFullExistingFilename(modName), 'rb')
-        mod, voxelsize = cPickle.load(mf)
+        mod, voxelsize = pickle.load(mf)
 
         mod = mod[15:-15, 15:-15, :]
 
@@ -385,7 +385,7 @@
         try:
             fitErrors[:2] = scipy.sqrt(scipy.diag(cov_z) * (infodict_z['fvec'] * infodict_z['fvec']).sum() / (len(dataROI.ravel())- len(res_z)))
             fitErrors[2:4] = scipy.sqrt(scipy.diag(cov_x) * (infodict_x['fvec'] * infodict_x['fvec']).sum() / (len(dataROI.ravel())- len(res_x)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/loft/PsfFitIR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/PsfFitIR.py	(refactored)
@@ -14,10 +14,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis import twist
 
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -76,7 +76,7 @@
 
     if not modName == interpModelName:
         mf = open(getFullExistingFilename(modName), 'rb')
-        mod, voxelsize = cPickle.load(mf)
+        mod, voxelsize = pickle.load(mf)
         mf.close()
         
         interpModelName = modName
@@ -446,7 +446,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/loft/PsfFitSR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/PsfFitSR.py	(refactored)
@@ -14,10 +14,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 from PYME.Analysis import twist
 
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -89,7 +89,7 @@
 
     if not modName == interpModelName:
         mf = open(getFullExistingFilename(modName), 'rb')
-        mod, voxelsize = cPickle.load(mf)
+        mod, voxelsize = pickle.load(mf)
         mf.close()
 
         interpModelName = modName
@@ -329,7 +329,7 @@
         fitErrors=None
         try:
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #print res, fitErrors, resCode
--- ./PYME/Analysis/FitFactories/loft/SMIAxialFit.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/SMIAxialFit.py	(refactored)
@@ -125,7 +125,7 @@
 
     def __CalcStartParams(self, profile):
         xi = scipy.arange(0, len(profile) - 1, .1)
-        ti = interpolate.interp1d(range(len(profile)), profile, 'cubic')(xi)
+        ti = interpolate.interp1d(list(range(len(profile))), profile, 'cubic')(xi)
 
         i_ = ti.argmax()
         v = ti[i_]
@@ -200,7 +200,7 @@
         #print ind3
         try:
             (res, resCode) = FitModel(f_SMIAxial, startParameters, profile[ind3], ind3, ysmooth[ind3], back)
-        except TypeError, e:
+        except TypeError as e:
             res = [-1, -1, -1, -1]
             resCode = -1
 
--- ./PYME/Analysis/FitFactories/loft/SplitterFitPsfIR.py	(original)
+++ ./PYME/Analysis/FitFactories/loft/SplitterFitPsfIR.py	(refactored)
@@ -14,10 +14,10 @@
 #from scipy.signal import interpolate
 #import scipy.ndimage as ndimage
 from pylab import *
-import copy_reg
+import copyreg
 import numpy
 import types
-import cPickle
+import pickle
 
 #import PYME.Analysis.twoColour as twoColour
 
@@ -38,7 +38,7 @@
 def unpickleSlice(start, stop, step):
         return slice(start, stop, step)
 
-copy_reg.pickle(slice, pickleSlice, unpickleSlice)
+copyreg.pickle(slice, pickleSlice, unpickleSlice)
 
 
 IntXVals = None
@@ -77,7 +77,7 @@
 
     if not modName == interpModelName:
         mf = open(getFullExistingFilename(modName), 'rb')
-        mod, voxelsize = cPickle.load(mf)
+        mod, voxelsize = pickle.load(mf)
         mf.close()
 
         interpModelName = modName
@@ -402,7 +402,7 @@
         fitErrors=None
         try:       
             fitErrors = scipy.sqrt(scipy.diag(cov_x) * (infodict['fvec'] * infodict['fvec']).sum() / (len(dataROI.ravel())- len(res)))
-        except Exception, e:
+        except Exception as e:
             pass
 
         #normalised Chi-squared
--- ./PYME/Analysis/FitFactories/zEstimators/priEstimator.py	(original)
+++ ./PYME/Analysis/FitFactories/zEstimators/priEstimator.py	(refactored)
@@ -195,7 +195,7 @@
 #    x0 = 0.5*(x_0 + x_2)
 #    y0 = 0.5*(y_0 + y_2)
     
-    print xi, yi, x2, y2
+    print(xi, yi, x2, y2)
 #    
     
     x0 = 0.5*(X[xi] + X[x2])
--- ./PYME/Analysis/LMVis/VisGUI.py	(original)
+++ ./PYME/Analysis/LMVis/VisGUI.py	(refactored)
@@ -172,12 +172,12 @@
     def OnIdle(self, event):
         if self.glCanvas.init and not self.refv:
             self.refv = True
-            print self.viewMode, self.colData
+            print(self.viewMode, self.colData)
             
             self.RefreshView()
             self.displayPane.OnPercentileCLim(None)
             self.Refresh()
-            print 'refreshed'
+            print('refreshed')
 
     def AddPage(self, page=None, select=False,caption='Dummy', update=True):
         if update:
@@ -227,7 +227,7 @@
     def SaveMetadata(self, mdh):
         mdh['Filter.Keys'] = self.pipeline.filterKeys      
         
-        if HAVE_DRIFT_CORRECTION and 'x' in self.pipeline.mapping.mappings.keys(): #drift correction has been applied
+        if HAVE_DRIFT_CORRECTION and 'x' in list(self.pipeline.mapping.mappings.keys()): #drift correction has been applied
             self.driftPane.dp.SaveMetadata(mdh)
 
     def CreateFoldPanel(self):
@@ -472,9 +472,9 @@
         colData = ['<None>']
 
         if not self.pipeline.colourFilter == None:
-            colData += self.pipeline.keys()
-
-        colData += self.pipeline.GeneratedMeasures.keys()
+            colData += list(self.pipeline.keys())
+
+        colData += list(self.pipeline.GeneratedMeasures.keys())
 
         hsizer = wx.BoxSizer(wx.HORIZONTAL)
         hsizer.Add(wx.StaticText(pan, -1, 'Colour:'), 0,wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
@@ -502,9 +502,9 @@
             colData = ['<None>']
 
             if not self.pipeline.colourFilter == None:
-                colData += self.pipeline.keys()
-
-            colData += self.pipeline.GeneratedMeasures.keys()
+                colData += list(self.pipeline.keys())
+
+            colData += list(self.pipeline.GeneratedMeasures.keys())
 
             self.chPointColour.Clear()
             for cd in colData:
@@ -528,9 +528,9 @@
         if self.colData == '<None>':
             pointColour = None
         elif not self.pipeline.colourFilter == None:
-            if self.colData in self.pipeline.keys():
+            if self.colData in list(self.pipeline.keys()):
                 pointColour = self.pipeline[self.colData]
-            elif self.colData in self.pipeline.GeneratedMeasures.keys():
+            elif self.colData in list(self.pipeline.GeneratedMeasures.keys()):
                 pointColour = self.pipeline.GeneratedMeasures[self.colData]
             else:
                 pointColour = None
@@ -737,7 +737,7 @@
         self.displayPane.OnPercentileCLim(None)
 
     def OnView3DPoints(self,event):
-        if 'z' in self.pipeline.keys():
+        if 'z' in list(self.pipeline.keys()):
             if not 'glCanvas3D' in dir(self):
                 #self.glCanvas3D = gl_render3D.LMGLCanvas(self)
                 #self.AddPage(page=self.glCanvas3D, select=True, caption='3D')
@@ -751,7 +751,7 @@
             self.glCanvas3D.setCLim(self.glCanvas.clim, (-5e5, -5e5))
 
     def OnView3DTriangles(self,event):
-        if 'z' in self.pipeline.keys():
+        if 'z' in list(self.pipeline.keys()):
             if not 'glCanvas3D' in dir(self):
                 self.glCanvas3D = gl_render3D.LMGLCanvas(self)
                 self.AddPage(page=self.glCanvas3D, select=True, caption='3D')
@@ -834,7 +834,7 @@
         self.AddPage(self.mdp, caption='Metadata')
         
         #print 'cp'        
-        if 'gFrac' in self.pipeline.filter.keys():
+        if 'gFrac' in list(self.pipeline.filter.keys()):
             self.colp = colourPanel.colourPanel(self, self.pipeline, self)
             self.AddPage(self.colp, caption='Colour', update=False)
             
@@ -864,7 +864,7 @@
             
             mf = loadmat(filename)
 
-            dlg = importTextDialog.ImportMatDialog(self, [k for k in mf.keys() if not k.startswith('__')])
+            dlg = importTextDialog.ImportMatDialog(self, [k for k in list(mf.keys()) if not k.startswith('__')])
             ret = dlg.ShowModal()
 
             if not ret == wx.ID_OK:
@@ -895,9 +895,9 @@
             #print 'Skipping %d rows' %args['SkipRows']
             dlg.Destroy()
 
-        print 'Creating Pipeline'
+        print('Creating Pipeline')
         self.pipeline.OpenFile(filename, **args)
-        print 'Pipeline Created'
+        print('Pipeline Created')
         self.SetTitle('PYME Visualise - ' + filename)
         
         #############################
@@ -906,7 +906,7 @@
         self._createNewTabs()
         
         self.CreateFoldPanel()
-        print 'Gui stuff done'
+        print('Gui stuff done')
         
         self.SetFit()
             
@@ -1050,12 +1050,12 @@
                                   self.pipeline.imageBounds.y0, self.pipeline.imageBounds.y1)
 
     def OnFitROI(self,event = None):
-        if 'x' in self.pipeline.filterKeys.keys():
+        if 'x' in list(self.pipeline.filterKeys.keys()):
             xbounds = self.pipeline.filterKeys['x']
         else:
             xbounds = (self.pipeline.imageBounds.x0, self.pipeline.imageBounds.x1)
 
-        if 'y' in self.pipeline.filterKeys.keys():
+        if 'y' in list(self.pipeline.filterKeys.keys()):
             ybounds = self.pipeline.filterKeys['y']
         else:
             ybounds = (self.pipeline.imageBounds.y0, self.pipeline.imageBounds.y1)
--- ./PYME/Analysis/LMVis/colourPanel.py	(original)
+++ ./PYME/Analysis/LMVis/colourPanel.py	(refactored)
@@ -28,7 +28,7 @@
 import wx
 from pylab import cm
 import sys
-import dyeRatios
+from . import dyeRatios
 
 class colourPlotPanel(wxPlotPanel.PlotPanel):
     def __init__(self, parent, pipeline, visFrame, **kwargs ):
@@ -39,12 +39,12 @@
         wxPlotPanel.PlotPanel.__init__( self, parent, **kwargs )
 
     def draw( self ):
-            print 'd'
+            print('d')
             """Draw data."""
             if self.visFrame.refv and not self.pipeline.ready or len(self.pipeline.filter['x']) == 0:
                 return
             
-            print 'vd'            
+            print('vd')            
             if not hasattr( self, 'subplot1' ):
                 self.subplot1 = self.figure.add_axes([.1, .1, .89, .89])
                 #self.subplot2 = self.figure.add_subplot( 122 )
@@ -65,14 +65,14 @@
             c = -5e3*numpy.ones(x.shape)
 #            print (c < -1).sum(), c.min()
 
-            for k, v in self.pipeline.fluorSpecies.items():
+            for k, v in list(self.pipeline.fluorSpecies.items()):
                 p_dye = self.pipeline.mapping['p_%s' % k][::max(l_x/1e4, 1)]
 
                 p_other = numpy.zeros(x.shape)
                 #p_tot = numpy.zeros(p_dye.shape)
                 p_tot = self.pipeline.t_p_background*self.pipeline.mapping['ColourNorm'][::max(l_x/1e4, 1)]
 
-                for k2 in self.pipeline.fluorSpecies.keys():
+                for k2 in list(self.pipeline.fluorSpecies.keys()):
                     p_tot  += self.pipeline.mapping['p_%s' % k2][::max(l_x/1e4, 1)]
                     if not k2 ==k:
                         p_other = numpy.maximum(p_other, self.pipeline.mapping['p_%s' % k2][::max(l_x/1e4, 1)])
@@ -112,7 +112,7 @@
             self.subplot1.set_ylim((0, yl))
 
 
-            for k, v in self.pipeline.fluorSpecies.items():
+            for k, v in list(self.pipeline.fluorSpecies.items()):
                 self.subplot1.plot([0,xl], [0, ((1-v)/v)*xl], lw=2, c=cm.jet_r(v))
 
             self.canvas.draw()
@@ -170,8 +170,8 @@
         self.lFluorSpecies.makeColumnEditable(4)
         self.lFluorSpecies.makeColumnEditable(5)
 
-        for key, value in self.pipeline.fluorSpecies.items():
-            ind = self.lFluorSpecies.InsertStringItem(sys.maxint, key)
+        for key, value in list(self.pipeline.fluorSpecies.items()):
+            ind = self.lFluorSpecies.InsertStringItem(sys.maxsize, key)
             self.lFluorSpecies.SetStringItem(ind,1, '%3.2f' % value)
             self.lFluorSpecies.SetItemTextColour(ind, wx.Colour(*((128*numpy.array(cm.jet_r(value)))[:3])))
             
@@ -291,7 +291,7 @@
 
             self.pipeline.fluorSpecies[key] = val
 
-            ind = self.lFluorSpecies.InsertStringItem(sys.maxint, key)
+            ind = self.lFluorSpecies.InsertStringItem(sys.maxsize, key)
             self.lFluorSpecies.SetStringItem(ind,1, '%3.2f' % val)
             #print val, (255*numpy.array(cm.gist_rainbow(val)))[:3]
             self.lFluorSpecies.SetItemTextColour(ind, wx.Colour(*((128*numpy.array(cm.jet_r(val)))[:3])))
@@ -339,7 +339,7 @@
         else: #shift
             axis = ['x', 'y', 'z'][col-3]
             specName = it.GetText()
-            if not specName in self.pipeline.chromaticShifts.keys():
+            if not specName in list(self.pipeline.chromaticShifts.keys()):
                 self.pipeline.chromaticShifts[specName] = {}
 
             self.pipeline.chromaticShifts[specName][axis] = val
@@ -353,10 +353,10 @@
 
         guesses = scipy.cluster.vq.kmeans(self.pipeline.filter['gFrac'], n)[0]
 
-        for g, i in zip(guesses, range(n)):
+        for g, i in zip(guesses, list(range(n))):
             key = '%c' % (65 + i)
             self.pipeline.fluorSpecies[key] = g
-            ind = self.lFluorSpecies.InsertStringItem(sys.maxint, key)
+            ind = self.lFluorSpecies.InsertStringItem(sys.maxsize, key)
             self.lFluorSpecies.SetStringItem(ind,1, '%3.3f' % g)
             self.lFluorSpecies.SetItemTextColour(ind, wx.Colour(*((128*numpy.array(cm.jet_r(g)))[:3])))
 
@@ -382,7 +382,7 @@
 
             if not ratio == None:
                 self.pipeline.fluorSpecies[structure] = ratio
-                ind = self.lFluorSpecies.InsertStringItem(sys.maxint, structure)
+                ind = self.lFluorSpecies.InsertStringItem(sys.maxsize, structure)
                 self.lFluorSpecies.SetStringItem(ind,1, '%3.3f' % ratio)
                 self.lFluorSpecies.SetItemTextColour(ind, wx.Colour(*((128*numpy.array(cm.jet_r(ratio)))[:3])))
 
@@ -405,7 +405,7 @@
     def refresh(self):
         self.colPlotPan.draw()
 
-        for key in self.pipeline.fluorSpecies.keys():
+        for key in list(self.pipeline.fluorSpecies.keys()):
             ind = self.lFluorSpecies.FindItem(-1,key)
             p_dye = self.pipeline.mapping['p_%s' % key]
 
@@ -413,7 +413,7 @@
             #p_tot = numpy.zeros(p_dye.shape)
             p_tot = self.pipeline.t_p_background*self.pipeline.mapping['ColourNorm']
 
-            for k2 in self.pipeline.fluorSpecies.keys():
+            for k2 in list(self.pipeline.fluorSpecies.keys()):
                 p_tot  += self.pipeline.mapping['p_%s' % k2]
                 if not k2 ==key:
                     p_other = numpy.maximum(p_other, self.pipeline.mapping['p_%s' % k2])
--- ./PYME/Analysis/LMVis/displayPane.py	(original)
+++ ./PYME/Analysis/LMVis/displayPane.py	(refactored)
@@ -44,7 +44,7 @@
         #Colourmap
         cmapnames = pylab.cm.cmapnames
         
-        print cmapnames, self.glCanvas.cmap.name
+        print(cmapnames, self.glCanvas.cmap.name)
 
         #curCMapName = self.glCanvas.cmap.name
         curCMapName = 'hot'
@@ -163,9 +163,9 @@
         hsizer.Add(wx.StaticText(pan, -1, 'Scale Bar: '), 0, wx.LEFT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
 
 
-        chInd = self.scaleBarLengths.values().index(self.glCanvas.scaleBarLength)
-
-        chScaleBar = wx.Choice(pan, -1, choices = self.scaleBarLengths.keys())
+        chInd = list(self.scaleBarLengths.values()).index(self.glCanvas.scaleBarLength)
+
+        chScaleBar = wx.Choice(pan, -1, choices = list(self.scaleBarLengths.keys()))
         chScaleBar.SetSelection(chInd)
         hsizer.Add(chScaleBar, 0,wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
 
--- ./PYME/Analysis/LMVis/dyeRatios.py	(original)
+++ ./PYME/Analysis/LMVis/dyeRatios.py	(refactored)
@@ -31,13 +31,13 @@
 dichr_ratios = {'FF700-Di01': {'A647':0.3, 'A680':0.87,'A700':0.7}}
 
 def getRatio(dye, mdh=None):
-    if dye in ratios.keys():
+    if dye in list(ratios.keys()):
         
         if 'Analysis.FitModule' in mdh.getEntryNames() and mdh['Analysis.FitModule'].startswith('PRInterpFit'):
             return PRIRatios[dye]
         if 'Splitter.Dichroic' in mdh.getEntryNames():
             dichroicName = mdh['Splitter.Dichroic']
-            if dichroicName in dichr_ratios.keys():
+            if dichroicName in list(dichr_ratios.keys()):
                 return dichr_ratios[dichroicName][dye]
                 
         if 'Splitter.TransmittedPathPosition' in mdh.getEntryNames() and mdh.getEntry('Splitter.TransmittedPathPosition') == 'Top':
--- ./PYME/Analysis/LMVis/fastGraph.py	(original)
+++ ./PYME/Analysis/LMVis/fastGraph.py	(refactored)
@@ -129,7 +129,7 @@
         h = (self.Size[1] - self.textSize - 2)*(1.0-((self.h - self.h.min())/(1.0*(self.h.max()-self.h.min() + .1))))
 
         maxy = self.Size[1] - self.textSize
-        pointlist = [(i+self.left_margin,h_i) for i, h_i in zip(range(len(h)), h)]
+        pointlist = [(i+self.left_margin,h_i) for i, h_i in zip(list(range(len(h))), h)]
         #pointlist = [(10,h[0])] + pointlist + [(self.Size[0], maxy)]
 
         dc.Clear()
--- ./PYME/Analysis/LMVis/filterPane.py	(original)
+++ ./PYME/Analysis/LMVis/filterPane.py	(refactored)
@@ -48,8 +48,8 @@
         self.lFiltKeys.InsertColumn(1, 'Min')
         self.lFiltKeys.InsertColumn(2, 'Max')
 
-        for key, value in self.filterKeys.items():
-            ind = self.lFiltKeys.InsertStringItem(sys.maxint, key)
+        for key, value in list(self.filterKeys.items()):
+            ind = self.lFiltKeys.InsertStringItem(sys.maxsize, key)
             self.lFiltKeys.SetStringItem(ind,1, '%3.2f' % value[0])
             self.lFiltKeys.SetStringItem(ind,2, '%3.2f' % value[1])
 
@@ -133,14 +133,14 @@
         event.Skip()
 
     def OnFilterClipToSelection(self, event):
-        if 'x' in self.filterKeys.keys() or 'y' in self.filterKeys.keys():
-            if 'x' in self.filterKeys.keys():
+        if 'x' in list(self.filterKeys.keys()) or 'y' in list(self.filterKeys.keys()):
+            if 'x' in list(self.filterKeys.keys()):
                 i = 0
                 while not self.lFiltKeys.GetItemText(i) == 'x':
                     i +=1
                 self.lFiltKeys.DeleteItem(i)
                 self.filterKeys.pop('x')
-            if 'y' in self.filterKeys.keys():
+            if 'y' in list(self.filterKeys.keys()):
                 i = 0
                 while not self.lFiltKeys.GetItemText(i) == 'y':
                     i +=1
@@ -152,13 +152,13 @@
             x0, y0 = self.visFr.glCanvas.selectionStart
             x1, y1 = self.visFr.glCanvas.selectionFinish
 
-            if not 'x' in self.filterKeys.keys():
-                indx = self.lFiltKeys.InsertStringItem(sys.maxint, 'x')
+            if not 'x' in list(self.filterKeys.keys()):
+                indx = self.lFiltKeys.InsertStringItem(sys.maxsize, 'x')
             else:
                 indx = [self.lFiltKeys.GetItemText(i) for i in range(self.lFiltKeys.GetItemCount())].index('x')
 
-            if not 'y' in self.filterKeys.keys():
-                indy = self.lFiltKeys.InsertStringItem(sys.maxint, 'y')
+            if not 'y' in list(self.filterKeys.keys()):
+                indy = self.lFiltKeys.InsertStringItem(sys.maxsize, 'y')
             else:
                 indy = [self.lFiltKeys.GetItemText(i) for i in range(self.lFiltKeys.GetItemCount())].index('y')
 
@@ -181,7 +181,7 @@
 
         possibleKeys = []
         if not self.pipeline.selectedDataSource == None:
-            possibleKeys = self.pipeline.selectedDataSource.keys()
+            possibleKeys = list(self.pipeline.selectedDataSource.keys())
 
         dlg = editFilterDialog.FilterEditDialog(self, mode='new', possibleKeys=possibleKeys)
 
@@ -198,7 +198,7 @@
 
             self.filterKeys[key] = (minVal, maxVal)
 
-            ind = self.lFiltKeys.InsertStringItem(sys.maxint, key)
+            ind = self.lFiltKeys.InsertStringItem(sys.maxsize, key)
             self.lFiltKeys.SetStringItem(ind,1, '%3.2f' % minVal)
             self.lFiltKeys.SetStringItem(ind,2, '%3.2f' % maxVal)
 
--- ./PYME/Analysis/LMVis/gen3DTriangs.py	(original)
+++ ./PYME/Analysis/LMVis/gen3DTriangs.py	(refactored)
@@ -24,7 +24,7 @@
 try:
     import delaunay
 except:
-    print 'could not import delaunay'
+    print('could not import delaunay')
 from numpy import *
 #import matplotlib.delaunay
 
@@ -150,7 +150,7 @@
 
 class emptyListDict(dict):
     def __getitem__(self, key):
-        if key in self.keys():
+        if key in list(self.keys()):
             return dict.__getitem__(self, key)
         else:
             return []
@@ -231,9 +231,9 @@
 #           surfInds*=(matches == 0) #remove triangles
     if internalCull:
         fcs = {} #emptyListDict()
-        for i, triI in zip(range(len(triInds)), triInds):
+        for i, triI in zip(list(range(len(triInds))), triInds):
             t_t = tuple(triI)
-            if t_t in fcs.keys():
+            if t_t in list(fcs.keys()):
                 surfInds[fcs[t_t]] = 0
                 surfInds[i] = 0
             else:
@@ -410,7 +410,7 @@
     return sqrt((edVecs**2).sum(1)).sum()
 
 def averageNormals(P,N):
-    i_s = range(P.shape[0])
+    i_s = list(range(P.shape[0]))
 
     while len(i_s) > 0:
         i = i_s.pop(0)
@@ -617,7 +617,7 @@
     
     A_ = []
 
-    for o, i in zip(objects, range(len(objects))):
+    for o, i in zip(objects, list(range(len(objects)))):
         T = delaunay.Triangulation(o.ravel(),2)
         #T2 = matplotlib.delaunay.Triangulation(o[:, 0], o[:,1])
         P, A, triI = gen2DTriangsTF(T, sizeCutoff)
--- ./PYME/Analysis/LMVis/genImageDialog.py	(original)
+++ ./PYME/Analysis/LMVis/genImageDialog.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import wx
-import histLimits
+from . import histLimits
 
 
 class GenImageDialog(wx.Dialog):
--- ./PYME/Analysis/LMVis/gl_render.py	(original)
+++ ./PYME/Analysis/LMVis/gl_render.py	(refactored)
@@ -36,7 +36,7 @@
 #from PYME.Analysis.QuadTree import pointQT
 #import numpy
 
-import statusLog
+from . import statusLog
 import weakref
 
 try:
@@ -585,7 +585,7 @@
 
 
     def setBlobs(self, objects, sizeCutoff):
-        import gen3DTriangs
+        from . import gen3DTriangs
 
         vs, self.c = gen3DTriangs.blobify2D(objects, sizeCutoff)
 
--- ./PYME/Analysis/LMVis/gl_render3D.py	(original)
+++ ./PYME/Analysis/LMVis/gl_render3D.py	(refactored)
@@ -38,7 +38,7 @@
 import pylab
 
 try:
-    from gen3DTriangs import gen3DTriangs, gen3DBlobs, testObj
+    from .gen3DTriangs import gen3DTriangs, gen3DBlobs, testObj
 except:
     pass
 
@@ -142,9 +142,9 @@
 
     def OnPaint(self,event):
         if not self.IsShown():
-            print 'ns'
+            print('ns')
             return
-        print 'foo'
+        print('foo')
         #raise Exception('foo')
         dc = wx.PaintDC(self)
         #print self.GetContext()
--- ./PYME/Analysis/LMVis/h5rNoGui.py	(original)
+++ ./PYME/Analysis/LMVis/h5rNoGui.py	(refactored)
@@ -114,11 +114,11 @@
         else:
             self.imageBounds = ImageBounds.estimateFromSource(self.selectedDataSource)
 
-        if 'fitResults_Ag' in self.selectedDataSource.keys():
+        if 'fitResults_Ag' in list(self.selectedDataSource.keys()):
             #if we used the splitter set up a mapping so we can filter on total amplitude and ratio
             #if not 'fitError_Ag' in self.selectedDataSource.keys():
 
-            if 'fitError_Ag' in self.selectedDataSource.keys():
+            if 'fitError_Ag' in list(self.selectedDataSource.keys()):
                 self.selectedDataSource = inpFilt.mappingFilter(self.selectedDataSource, A='fitResults_Ag + fitResults_Ar', gFrac='fitResults_Ag/(fitResults_Ag + fitResults_Ar)', error_gFrac = 'sqrt((fitError_Ag/fitResults_Ag)**2 + (fitError_Ag**2 + fitError_Ar**2)/(fitResults_Ag + fitResults_Ar)**2)*fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
                 sg = self.selectedDataSource['fitError_Ag']
                 sr = self.selectedDataSource['fitError_Ar']
@@ -146,7 +146,7 @@
             self.dataSources.append(self.selectedDataSource)
 
 
-        elif 'fitResults_sigxl' in self.selectedDataSource.keys():
+        elif 'fitResults_sigxl' in list(self.selectedDataSource.keys()):
             self.selectedDataSource = inpFilt.mappingFilter(self.selectedDataSource)
             self.dataSources.append(self.selectedDataSource)
 
@@ -208,18 +208,18 @@
         if not 'foreShort' in dir(self.selectedDataSource):
             self.selectedDataSource.foreShort = 1.
 
-        if not 'focus' in self.selectedDataSource.mappings.keys():
+        if not 'focus' in list(self.selectedDataSource.mappings.keys()):
             self.selectedDataSource.focus= np.zeros(self.selectedDataSource['x'].shape)
 
-        if 'fitResults_z0' in self.selectedDataSource.keys():
+        if 'fitResults_z0' in list(self.selectedDataSource.keys()):
             self.selectedDataSource.setMapping('z', 'fitResults_z0 + foreShort*focus')
         else:
             self.selectedDataSource.setMapping('z', 'foreShort*focus')
 
         #if we've done a 3d fit
         #print self.selectedDataSource.keys()
-        for k in self.filterKeys.keys():
-            if not k in self.selectedDataSource.keys():
+        for k in list(self.filterKeys.keys()):
+            if not k in list(self.selectedDataSource.keys()):
                 self.filterKeys.pop(k)
 
         #print self.filterKeys
--- ./PYME/Analysis/LMVis/histLimits.py	(original)
+++ ./PYME/Analysis/LMVis/histLimits.py	(refactored)
@@ -183,7 +183,7 @@
         h = (self.Size[1] - self.textSize - 2)*(1.0-(self.h/(1.0*self.h[1:-1].max()+1e-9))) + 2
 
         maxy = self.Size[1] - self.textSize
-        pointlist = [(i,h_i) for i, h_i in zip(range(len(h)), h)]
+        pointlist = [(i,h_i) for i, h_i in zip(list(range(len(h))), h)]
         pointlist = [(0,maxy)] + pointlist + [(self.Size[0], maxy)]
 
         dc.Clear()
--- ./PYME/Analysis/LMVis/imageView.py	(original)
+++ ./PYME/Analysis/LMVis/imageView.py	(refactored)
@@ -105,7 +105,7 @@
         im = im - self.do.Offs[self.chan] #self.clim[0]
         im = im*self.do.Gains[self.chan]    #/(self.clim[1] - self.clim[0])
 
-        print im.shape
+        print(im.shape)
 
         im = (255*self.do.cmaps[self.chan](im)[:,:,:3]).astype('b')
             
@@ -122,7 +122,7 @@
         sc = self.image.pixelSize/self.glCanvas.pixelsize
         
         if self.glCanvas.centreCross:
-            print 'drawing crosshair'
+            print('drawing crosshair')
             dc.SetPen(wx.Pen(wx.GREEN, 2))
 
             dc.DrawLine(.5*self.Size[0], 0, .5*self.Size[0], self.Size[1])
@@ -149,7 +149,7 @@
                 if len(self.do.selection_trace) > 2:
                     x, y = numpy.array(self.do.selection_trace).T
                     pts = numpy.vstack(self._PixelToScreenCoordinates(x, y)).T
-                    print pts.shape
+                    print(pts.shape)
                     dc.DrawSpline(pts)
             elif self.do.selectionWidth == 1:
                 dc.DrawLine(lx,ly, hx,hy)
@@ -409,7 +409,7 @@
         #print self.glCanvas.centreCross
 
         if self.glCanvas.centreCross:
-            print 'drawing crosshair'
+            print('drawing crosshair')
             dc.SetPen(wx.Pen(wx.GREEN, 2))
 
             dc.DrawLine(.5*self.Size[0], 0, .5*self.Size[0], self.Size[1])
--- ./PYME/Analysis/LMVis/importTextDialog.py	(original)
+++ ./PYME/Analysis/LMVis/importTextDialog.py	(refactored)
@@ -123,7 +123,7 @@
         return colNames, dataLines
 
     def CheckColNames(self):
-        reqNotDef = [var for var in self.requiredVariables.keys() if not var in self.colNames]
+        reqNotDef = [var for var in list(self.requiredVariables.keys()) if not var in self.colNames]
 
         if len(reqNotDef) > 0:
             self.btnOK.Enable(False)
@@ -138,7 +138,7 @@
 
         self.stRequiredNotPresent.SetLabel(sreq)
 
-        recNotDef = [var for var in self.recommendedVariables.keys() if not var in self.colNames]
+        recNotDef = [var for var in list(self.recommendedVariables.keys()) if not var in self.colNames]
 
         if len(recNotDef) > 0:
             sreq = 'Recomended variables not yet defined:\n'
@@ -165,7 +165,7 @@
             id = wx.NewId()
             self.comboIDs.append(id)
 
-            cb = wx.ComboBox(self.scrollW, id, size=(120, -1), choices=[cn]+ self.requiredVariables.keys() +self.recommendedVariables.keys() + self.niceVariables.keys())
+            cb = wx.ComboBox(self.scrollW, id, size=(120, -1), choices=[cn]+ list(self.requiredVariables.keys()) +list(self.recommendedVariables.keys()) + list(self.niceVariables.keys()))
             self.combos.append(cb)
             cb.SetSelection(0)
 
--- ./PYME/Analysis/LMVis/inpFilt.py	(original)
+++ ./PYME/Analysis/LMVis/inpFilt.py	(refactored)
@@ -97,17 +97,17 @@
                           'y' : 'fitResults_y0', 'sig' : 'fitResults_sigma',
                           'error_x' : 'fitError_x0', 'error_y' : 'fitError_y0','t':'tIndex'}
 
-        for k in self.transkeys.keys():
+        for k in list(self.transkeys.keys()):
             if not self.transkeys[k] in self._keys:
                 self.transkeys.pop(k)
 
 
     def keys(self):
-        return self._keys + self.transkeys.keys()
+        return self._keys + list(self.transkeys.keys())
 
     def __getitem__(self, key):
         #if we're using an alias replace with actual key
-        if key in self.transkeys.keys():
+        if key in list(self.transkeys.keys()):
             key = self.transkeys[key]
 
         if not key in self._keys:
@@ -158,17 +158,17 @@
                           'y' : 'fitResults_y0', 'sig' : 'fitResults_sigma', 
                           'error_x' : 'fitError_x0', 'error_y' : 'fitError_y0', 't':'tIndex'}
 
-        for k in self.transkeys.keys():
+        for k in list(self.transkeys.keys()):
             if not self.transkeys[k] in self._keys:
                 self.transkeys.pop(k)
 
 
     def keys(self):
-        return self._keys + self.transkeys.keys()
+        return self._keys + list(self.transkeys.keys())
 
     def __getitem__(self, key):
         #if we're using an alias replace with actual key
-        if key in self.transkeys.keys():
+        if key in list(self.transkeys.keys()):
             key = self.transkeys[key]
 
         if not key in self._keys:
@@ -216,11 +216,11 @@
 
 
     def keys(self):
-        return self._keys + self.transkeys.keys()
+        return self._keys + list(self.transkeys.keys())
 
     def __getitem__(self, key):
         #if we're using an alias replace with actual key
-        if key in self.transkeys.keys():
+        if key in list(self.transkeys.keys()):
             key = self.transkeys[key]
 
         if not key in self._keys:
@@ -323,10 +323,10 @@
         self.resultsSource = resultsSource
 
         #by default select everything
-        self.Index = np.ones(self.resultsSource[resultsSource.keys()[0]].shape) >  0.5
-
-        for k in kwargs.keys():
-            if not k in self.resultsSource.keys():
+        self.Index = np.ones(self.resultsSource[list(resultsSource.keys())[0]].shape) >  0.5
+
+        for k in list(kwargs.keys()):
+            if not k in list(self.resultsSource.keys()):
                 raise RuntimeError('Requested key not present: ' + k)
 
             range = kwargs[k]
@@ -340,7 +340,7 @@
         return self.resultsSource[key][self.Index]
 
     def keys(self):
-        return self.resultsSource.keys()
+        return list(self.resultsSource.keys())
 
 class cachingResultsFilter(inputFilter):
     _name = "Caching Results Filter"
@@ -358,10 +358,10 @@
         self.cache = {}
 
         #by default select everything
-        self.Index = np.ones(self.resultsSource[resultsSource.keys()[0]].shape) >  0.5
-
-        for k in kwargs.keys():
-            if not k in self.resultsSource.keys():
+        self.Index = np.ones(self.resultsSource[list(resultsSource.keys())[0]].shape) >  0.5
+
+        for k in list(kwargs.keys()):
+            if not k in list(self.resultsSource.keys()):
                 raise RuntimeError('Requested key not present: ' + k)
 
             range = kwargs[k]
@@ -372,7 +372,7 @@
 
 
     def __getitem__(self, key):
-        if key in self.cache.keys():
+        if key in list(self.cache.keys()):
             return self.cache[key]
         else:
             res = self.resultsSource[key][self.Index]
@@ -380,7 +380,7 @@
             return res
 
     def keys(self):
-        return self.resultsSource.keys()
+        return list(self.resultsSource.keys())
 
 
 class mappingFilter(inputFilter):
@@ -401,24 +401,24 @@
 
         self.mappings = {}
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             v = kwargs[k]
             self.setMapping(k,v)
 
 
     def __getitem__(self, key):
-        if key in self.mappings.keys():
+        if key in list(self.mappings.keys()):
             return self.getMappedResults(key)
         else:
             return self.resultsSource[key]
 
     def keys(self):
-        return self.resultsSource.keys() + self.mappings.keys()
+        return list(self.resultsSource.keys()) + list(self.mappings.keys())
 
     def setMapping(self, key, mapping):
         if type(mapping) == types.CodeType:
             self.mappings[key] = mapping
-        elif type(mapping) == types.StringType:
+        elif type(mapping) == bytes:
             self.mappings[key] = compile(mapping, '/tmp/test1', 'eval')
         else:
             self.__dict__[key] = mapping
@@ -431,11 +431,11 @@
         for vname in varnames:
             if vname in globals():
                 pass
-            if vname in self.resultsSource.keys(): #look at original results first
+            if vname in list(self.resultsSource.keys()): #look at original results first
                 locals()[vname] = self.resultsSource[vname]
             elif vname in dir(self): #look for constants
                 locals()[vname] = self.__dict__[vname]
-            elif vname in self.mappings.keys(): #finally try other mappings
+            elif vname in list(self.mappings.keys()): #finally try other mappings
                 #try to prevent infinite recursion here if mappings have circular references
                 if not vname == key and not key in self.mappings[vname].co_names:
                     locals()[vname] = self.getMappedResults(vname)
@@ -480,19 +480,19 @@
 
             #chromatic shift correction
             #print self.currentColour
-            if self.currentColour in self.visFr.chromaticShifts.keys() and key in self.visFr.chromaticShifts[self.currentColour].keys():
+            if self.currentColour in list(self.visFr.chromaticShifts.keys()) and key in list(self.visFr.chromaticShifts[self.currentColour].keys()):
                 return self.resultsSource[key][ind] + self.visFr.chromaticShifts[self.currentColour][key]
             else:
                 return self.resultsSource[key][ind]
 
     def getColourChans(self):
-        return [k[2:] for k in self.keys() if k.startswith('p_')]
+        return [k[2:] for k in list(self.keys()) if k.startswith('p_')]
 
     def setColour(self, colour):
         self.currentColour = colour
 
     def keys(self):
-        return self.resultsSource.keys()
+        return list(self.resultsSource.keys())
 
     
     
@@ -504,7 +504,7 @@
         resultsSource
         self.cache = {}
 
-        for k in resultsSource.keys():
+        for k in list(resultsSource.keys()):
             self.cache[k] = resultsSource[k]
 
 
@@ -513,4 +513,4 @@
         return self.cache[key]
 
     def keys(self):
-        return self.cache.keys()
+        return list(self.cache.keys())
--- ./PYME/Analysis/LMVis/objectMeasure.py	(original)
+++ ./PYME/Analysis/LMVis/objectMeasure.py	(refactored)
@@ -23,7 +23,7 @@
 
 from numpy import *
 import delaunay
-import gen3DTriangs
+from . import gen3DTriangs
 from PYME.Analysis import moments
 
 def getPrincipalAxis(obj_c, numIters=10):
--- ./PYME/Analysis/LMVis/pipeline.py	(original)
+++ ./PYME/Analysis/LMVis/pipeline.py	(refactored)
@@ -83,7 +83,7 @@
         return self.colourFilter[key]
 
     def keys(self):
-        return self.colourFilter.keys()
+        return list(self.colourFilter.keys())
 
 
     def Rebuild(self):
@@ -169,7 +169,7 @@
         self.selectedDataSource.setMapping('A', 'fitResults_Ag + fitResults_Ar')
         self.selectedDataSource.setMapping('gFrac', 'fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         
-        if 'fitError_Ag' in self.selectedDataSource.keys():    
+        if 'fitError_Ag' in list(self.selectedDataSource.keys()):    
             self.selectedDataSource.setMapping('error_gFrac', 'sqrt((fitError_Ag/fitResults_Ag)**2 + (fitError_Ag**2 + fitError_Ar**2)/(fitResults_Ag + fitResults_Ar)**2)*fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         else:
             self.selectedDataSource.setMapping('error_gFrac','0*x + 0.01')
@@ -274,7 +274,7 @@
                 self.mdh = MetaDataHandler.HDFMDHandler(self.selectedDataSource.h5f)
 
            
-            if ('Events' in self.selectedDataSource.h5f.root) and ('StartTime' in self.mdh.keys()):
+            if ('Events' in self.selectedDataSource.h5f.root) and ('StartTime' in list(self.mdh.keys())):
                 self.events = self.selectedDataSource.h5f.root.Events[:]
 
                         
@@ -285,7 +285,7 @@
 
         elif os.path.splitext(filename)[1] == '.csv': 
             #special case for csv files - tell np.loadtxt to use a comma rather than whitespace as a delimeter
-            if 'SkipRows' in kwargs.keys():
+            if 'SkipRows' in list(kwargs.keys()):
                 ds = inpFilt.textfileSource(filename, kwargs['FieldNames'], delimiter=',', skiprows=kwargs['SkipRows'])
             else:
                 ds = inpFilt.textfileSource(filename, kwargs['FieldNames'], delimiter=',')
@@ -293,7 +293,7 @@
             self.dataSources.append(ds)
             
         else: #assume it's a tab (or other whitespace) delimited text file
-            if 'SkipRows' in kwargs.keys():
+            if 'SkipRows' in list(kwargs.keys()):
                 ds = inpFilt.textfileSource(filename, kwargs['FieldNames'], skiprows=kwargs['SkipRows'])
             else:
                 ds = inpFilt.textfileSource(filename, kwargs['FieldNames'])
@@ -311,7 +311,7 @@
         self.selectedDataSource = inpFilt.mappingFilter(self.selectedDataSource)
         self.dataSources.append(self.selectedDataSource)
         
-        if 'PixelSize' in kwargs.keys():
+        if 'PixelSize' in list(kwargs.keys()):
             self.selectedDataSource.pixelSize = kwargs['PixelSize']
             self.selectedDataSource.setMapping('x', 'x*pixelSize')
             self.selectedDataSource.setMapping('y', 'y*pixelSize')
@@ -342,15 +342,15 @@
         
         #handle special cases which get detected by looking for the presence or
         #absence of certain variables in the data.        
-        if 'fitResults_Ag' in self.selectedDataSource.keys():
+        if 'fitResults_Ag' in list(self.selectedDataSource.keys()):
             #if we used the splitter set up a number of mappings e.g. total amplitude and ratio
             self._processSplitter()
 
-        if 'fitResults_ratio' in self.selectedDataSource.keys():
+        if 'fitResults_ratio' in list(self.selectedDataSource.keys()):
             #if we used the splitter set up a number of mappings e.g. total amplitude and ratio
             self._processPriSplit()
 
-        if 'fitResults_sigxl' in self.selectedDataSource.keys():
+        if 'fitResults_sigxl' in list(self.selectedDataSource.keys()):
             #fast, quickpalm like astigmatic fitting 
             self.selectedDataSource.setMapping('sig', 'fitResults_sigxl + fitResults_sigyu')
             self.selectedDataSource.setMapping('sig_d', 'fitResults_sigxl - fitResults_sigyu')
@@ -358,7 +358,7 @@
             self.selectedDataSource.dsigd_dz = -30.
             self.selectedDataSource.setMapping('fitResults_z0', 'dsigd_dz*sig_d')
             
-        if not 'y' in self.selectedDataSource.keys():
+        if not 'y' in list(self.selectedDataSource.keys()):
             self.selectedDataSource.setMapping('y', '10*t')
             
             
@@ -367,12 +367,12 @@
         if not 'foreShort' in dir(self.selectedDataSource):
             self.selectedDataSource.foreShort = 1.
 
-        if not 'focus' in self.selectedDataSource.mappings.keys():
+        if not 'focus' in list(self.selectedDataSource.mappings.keys()):
             self.selectedDataSource.focus= np.zeros(self.selectedDataSource['x'].shape)
             
-        if 'fitResults_z0' in self.selectedDataSource.keys():
+        if 'fitResults_z0' in list(self.selectedDataSource.keys()):
             self.selectedDataSource.setMapping('z', 'fitResults_z0 + foreShort*focus')
-        elif not 'z' in self.selectedDataSource.keys():
+        elif not 'z' in list(self.selectedDataSource.keys()):
             self.selectedDataSource.setMapping('z', 'foreShort*focus')
 
         
@@ -390,15 +390,15 @@
                 
         
         #remove any keys from the filter which are not present in the data
-        for k in self.filterKeys.keys():
-            if not k in self.selectedDataSource.keys():
+        for k in list(self.filterKeys.keys()):
+            if not k in list(self.selectedDataSource.keys()):
                 self.filterKeys.pop(k)
 
         
         self.Rebuild()
 
 
-        if 'Sample.Labelling' in self.mdh.getEntryNames() and 'gFrac' in self.selectedDataSource.keys():
+        if 'Sample.Labelling' in self.mdh.getEntryNames() and 'gFrac' in list(self.selectedDataSource.keys()):
             self.SpecFromMetadata()
 
 
@@ -416,7 +416,7 @@
     def getNeighbourDists(self, forceRetriang = False):
         from PYME.Analysis.LMVis import visHelpers
         
-        if forceRetriang or not 'neighbourDistances' in self.GeneratedMeasures.keys():
+        if forceRetriang or not 'neighbourDistances' in list(self.GeneratedMeasures.keys()):
             statNeigh = statusLog.StatusLogger("Calculating mean neighbour distances ...")
             self.GeneratedMeasures['neighbourDistances'] = np.array(visHelpers.calcNeighbourDists(self.getTriangles(forceRetriang)))
             
@@ -496,7 +496,7 @@
         
     def save_txt(self, outFile, keys=None):
         if keys == None:
-            keys = self.keys()
+            keys = list(self.keys())
 
         #nRecords = len(ds[keys[0]])
     
--- ./PYME/Analysis/LMVis/progGraph.py	(original)
+++ ./PYME/Analysis/LMVis/progGraph.py	(refactored)
@@ -40,7 +40,7 @@
                 self.subplot2 = self.figure.add_axes([.14,.05,.85,.44])#self.figure.add_subplot( 212 )
 
             a, ed = numpy.histogram(self.fitResults['tIndex'], self.Size[0]/2)
-            print float(numpy.diff(ed[:2]))
+            print(float(numpy.diff(ed[:2])))
 
             self.subplot1.cla()
             self.subplot1.plot(ed[:-1], a/float(numpy.diff(ed[:2])), color='b' )
--- ./PYME/Analysis/LMVis/progGraphVV.py	(original)
+++ ./PYME/Analysis/LMVis/progGraphVV.py	(refactored)
@@ -76,7 +76,7 @@
             
 
             a, ed = numpy.histogram(self.fitResults['tIndex'], self.Size[0]/6)
-            print float(numpy.diff(ed[:2]))
+            print(float(numpy.diff(ed[:2])))
 
             self.subplot1.MakeCurrent()
             vv.cla()
--- ./PYME/Analysis/LMVis/renderers.py	(original)
+++ ./PYME/Analysis/LMVis/renderers.py	(refactored)
@@ -65,11 +65,11 @@
         x1 = min(self.visFr.glCanvas.xmax, self.pipeline.imageBounds.x1)
         y1 = min(self.visFr.glCanvas.ymax, self.pipeline.imageBounds.y1)
 
-        if 'x' in self.pipeline.filterKeys.keys():
+        if 'x' in list(self.pipeline.filterKeys.keys()):
             x0 = max(x0, self.pipeline.filterKeys['x'][0])
             x1 = min(x1, self.pipeline.filterKeys['x'][1])
 
-        if 'y' in self.pipeline.filterKeys.keys():
+        if 'y' in list(self.pipeline.filterKeys.keys()):
             y0 = max(y0, self.pipeline.filterKeys['y'][0])
             y1 = min(y1, self.pipeline.filterKeys['y'][1])
 
@@ -89,7 +89,7 @@
         #print jitParamName
         if jitParamName == '1.0':
             jitVals = np.ones(self.pipeline.colourFilter['x'].shape)
-        elif jitParamName in self.pipeline.colourFilter.keys():
+        elif jitParamName in list(self.pipeline.colourFilter.keys()):
             jitVals = self.pipeline.colourFilter[jitParamName]
         elif jitParamName in self.genMeas:
             #print 'f'
@@ -150,9 +150,9 @@
     
     def Generate(self, event=None):
         jitVars = ['1.0']
-        jitVars += self.pipeline.colourFilter.keys()
-
-        self.genMeas = self.pipeline.GeneratedMeasures.keys()
+        jitVars += list(self.pipeline.colourFilter.keys())
+
+        self.genMeas = list(self.pipeline.GeneratedMeasures.keys())
         if not 'neighbourDistances' in self.genMeas:
             self.genMeas.append('neighbourDistances')
             
@@ -162,7 +162,7 @@
         jitVars += self.genMeas
         
         
-        if 'z' in self.pipeline.mapping.keys():
+        if 'z' in list(self.pipeline.mapping.keys()):
             zvals = self.pipeline.mapping['z']
         else:
             zvals = None
@@ -302,12 +302,12 @@
 
         jitVals = self._genJitVals(jitParamName, jitScale)
         
-        print 'starting render'
+        print('starting render')
 
         im =  visHelpers.rendGaussProd(self.pipeline.colourFilter['x'],self.pipeline.colourFilter['y'], jitVals, imb, pixelSize)
         
-        print 'done rendering'
-        print im.max()
+        print('done rendering')
+        print(im.max())
         
         return im - im.min()
 
--- ./PYME/Analysis/LMVis/visHelpers.py	(original)
+++ ./PYME/Analysis/LMVis/visHelpers.py	(refactored)
@@ -316,7 +316,7 @@
     #l3 = -10
     
     im = len(x)*l3*scipy.ones((len(X), len(Y)), 'd')
-    print im.min()
+    print(im.min())
     
     fac = 1./numpy.sqrt(2*numpy.pi)
 
@@ -343,7 +343,7 @@
             sxi = max(sx[i], delX)
             Xi, Yi = X[(ix - roiSize):(ix + roiSize + 1)][:,None], Y[(iy - roiSize):(iy + roiSize + 1)][None,:]
             imp = numpy.log(fac/sxi) - ((Xi - x[i])**2 + (Yi -y[i])**2)/(2*sxi**2)
-            print imp.max(), imp.min(), l3, imp.shape
+            print(imp.max(), imp.min(), l3, imp.shape)
             imp_ = numpy.maximum(imp, l3)
             im[(ix - roiSize):(ix + roiSize + 1), (iy - roiSize):(iy + roiSize + 1)] += imp_ - l3
 
@@ -425,7 +425,7 @@
         Imc = scipy.rand(len(x)) < mcp
         #print len(jsig), type(jsig)
         if isinstance(jsig, numpy.ndarray):
-            print jsig.shape, Imc.shape
+            print(jsig.shape, Imc.shape)
             jsig2 = jsig[Imc]
         else:
             jsig2 - float(jsig)
@@ -491,13 +491,13 @@
 
         Imc = scipy.rand(len(x)) < mcp
         if type(jsig) == numpy.ndarray:
-            print jsig.shape, Imc.shape
+            print(jsig.shape, Imc.shape)
             jsig = jsig[Imc]
             jsigz = jsigz[Imc]
 
         #gen3DTriangs.renderTetrahedra(im, x[Imc]+ jsig*scipy.randn(Imc.sum()), y[Imc]+ jsig*scipy.randn(Imc.sum()), z[Imc]+ jsigz*scipy.randn(Imc.sum()), scale = [1,1,1], pixelsize=[1,1,1])
         p = numpy.hstack(((x[Imc]+ jsig*scipy.randn(Imc.sum()))[:, None], (y[Imc]+ jsig*scipy.randn(Imc.sum()))[:, None], (z[Imc]+ jsigz*scipy.randn(Imc.sum()))[:, None]))
-        print p.shape
+        print(p.shape)
         RenderTetrahedra(p, im)
 
 if multiProc:
@@ -553,7 +553,7 @@
 
 else:
     def rendJitTet(x,y,z,n,jsig, jsigz, mcp, imageBounds, pixelSize, zb,sliceSize=100):
-        import gen3DTriangs
+        from . import gen3DTriangs
 
         sizeX = (imageBounds.x1 - imageBounds.x0)/pixelSize
         sizeY = (imageBounds.y1 - imageBounds.y0)/pixelSize
--- ./PYME/Analysis/LMVis/visHelpersMin.py	(original)
+++ ./PYME/Analysis/LMVis/visHelpersMin.py	(refactored)
@@ -178,7 +178,7 @@
 
 
 def rendJitTet(x,y,z,n,jsig, jsigz, mcp, imageBounds, pixelSize, zb,sliceSize=100):
-    import gen3DTriangs
+    from . import gen3DTriangs
 
     sizeX = (imageBounds.x1 - imageBounds.x0)/pixelSize
     sizeY = (imageBounds.y1 - imageBounds.y0)/pixelSize
@@ -198,7 +198,7 @@
     for i in range(n):
         Imc = scipy.rand(len(x)) < mcp
         if type(jsig) == numpy.ndarray:
-            print jsig.shape, Imc.shape
+            print(jsig.shape, Imc.shape)
             jsig = jsig[Imc]
             jsigz = jsigz[Imc]
 
--- ./PYME/Analysis/LMVis/workspaceTree.py	(original)
+++ ./PYME/Analysis/LMVis/workspaceTree.py	(refactored)
@@ -25,7 +25,7 @@
 from wx.lib.mixins.treemixin import VirtualTree
 #from pylab import cm, array
 
-import inpFilt
+from . import inpFilt
 
 class WorkWrap:
     def __init__(self, dict):
@@ -91,11 +91,11 @@
             #either list like or dict like
             if 'keys' in dir(item):
                 #dict like
-                return item[item.keys()[n]]
+                return item[list(item.keys())[n]]
             else:
                 return item[n]
         else:
-            return item.__dict__.values()[n]
+            return list(item.__dict__.values())[n]
 
     def _getChildName(self, item, n):
         '''get the nth child of an item'''
@@ -103,11 +103,11 @@
             #either list like or dict like
             if 'keys' in dir(item):
                 #dict like
-                return item.keys()[n]
+                return list(item.keys())[n]
             else:
                 return '[%d]' %n
         else:
-            return item.__dict__.keys()[n]
+            return list(item.__dict__.keys())[n]
 
     def _getChildPathPart(self, item, n):
         '''get the nth child of an item'''
@@ -115,11 +115,11 @@
             #either list like or dict like
             if 'keys' in dir(item):
                 #dict like
-                return "['%s']" % item.keys()[n]
+                return "['%s']" % list(item.keys())[n]
             else:
                 return '[%d]' %n
         else:
-            return '.' + item.__dict__.keys()[n]
+            return '.' + list(item.__dict__.keys())[n]
 
     def _getChildPath(self, index):
         '''get the nth child of an item'''
@@ -144,7 +144,7 @@
                 #dict like
                 return len(item)
             elif 'keys' in dir(item):
-                return len(item.keys())
+                return len(list(item.keys()))
         elif '__dict__' in dir(item):
             return len(item.__dict__)
         else:
--- ./PYME/Analysis/LMVis/Extras/objectMeasurements.py	(original)
+++ ./PYME/Analysis/LMVis/Extras/objectMeasurements.py	(refactored)
@@ -43,7 +43,7 @@
 
         dlg = wx.SingleChoiceDialog(
                 self.visFr, 'choose the image which contains labels', 'Use Segmentation',
-                image.openImages.keys(),
+                list(image.openImages.keys()),
                 wx.CHOICEDLG_STYLE
                 )
 
@@ -97,7 +97,7 @@
 #                    if lab[i][0] in chanNames:
 #                        chanNames[chanNames.index(lab[i][0])] = lab[i][1]
 
-            for ch, i in zip(chans, range(len(chans))):
+            for ch, i in zip(chans, list(range(len(chans)))):
                 self.visFr.colourFilter.setColour(ch)
                 #fitDecayChan(colourFilter, metadata, chanNames[i], i)
                 self.visFr.objectMeasures[chanNames[i]] = objectMeasure.measureObjectsByID(self.visFr.colourFilter, 10,ids)
--- ./PYME/Analysis/LMVis/Extras/particleTracking.py	(original)
+++ ./PYME/Analysis/LMVis/Extras/particleTracking.py	(refactored)
@@ -132,7 +132,7 @@
             alphas[i] = res[0][1]
             alphas_[I] = res[0][1]
 
-            print res[0]#, res[1]
+            print(res[0])#, res[1]
             if not res[1] == None:
                 error_Ds[i] = np.sqrt(res[1][0,0])
             else:
--- ./PYME/Analysis/LMVis/Extras/pointSetGeneration.py	(original)
+++ ./PYME/Analysis/LMVis/Extras/pointSetGeneration.py	(refactored)
@@ -82,7 +82,7 @@
 
     @property
     def values(self):
-        return self.wrdict.keys()
+        return list(self.wrdict.keys())
 
     #def info ( self ):
     #    return ' or '.join( [ repr( x ) for x in self.values ] )
@@ -107,7 +107,7 @@
 
     def getPoints(self):
         from PYMEnf.Simulation import locify
-        print self.image
+        print(self.image)
 
         im = image.openImages[self.image]
         #import numpy as np
--- ./PYME/Analysis/LMVis/Extras/shiftmapGenerator.py	(original)
+++ ./PYME/Analysis/LMVis/Extras/shiftmapGenerator.py	(refactored)
@@ -47,7 +47,7 @@
         twoColourPlot.PlotShiftField2(spx, spy, pipeline.mdh['Splitter.Channel0ROI'][2:], voxelsize=vs)
         twoColourPlot.PlotShiftResiduals(pipeline['x'][good], pipeline['y'][good], pipeline['fitResults_dx'][good], pipeline['fitResults_dy'][good], spx, spy)
 
-        import cPickle
+        import pickle
 
         defFile = os.path.splitext(os.path.split(self.visFr.GetTitle())[-1])[0] + '.sf'
 
@@ -59,7 +59,7 @@
             #save as a pickle containing the data and voxelsize
 
             fid = open(fpath, 'wb')
-            cPickle.dump((spx, spy), fid, 2)
+            pickle.dump((spx, spy), fid, 2)
             fid.close()
 
 def Plug(visFr):
--- ./PYME/Analysis/QuadTree/QTrend.py	(original)
+++ ./PYME/Analysis/QuadTree/QTrend.py	(refactored)
@@ -35,7 +35,7 @@
     Is = [float(l.numRecords)*2**(2*l.depth) for l in lvs]
 
     maxI = max(Is)
-    print maxI
+    print(maxI)
 
     for l in lvs:
         c = cmap((float(l.numRecords)*2**(2*l.depth))/(maxI*maxIsc))
@@ -53,7 +53,7 @@
     Is = [float(l.numRecords)*2**(2*l.depth) for l in lvs]
 
     maxI = max(Is)
-    print maxI
+    print(maxI)
 
     for l in lvs:
         c = cmap((float(l.numRecords)*2**(2*l.depth))/(maxI*maxIsc))
@@ -75,7 +75,7 @@
     dX = max(dX, dY)
     dY = dX
 
-    print dX
+    print(dX)
 
     for l in lvs:
         dx = l.x1 - l.x0
@@ -103,7 +103,7 @@
     dX = max(dX, dY)
     dY = dX
 
-    print dX
+    print(dX)
 
     ar[:,:] = 0 # initialize
     numevts = 0
--- ./PYME/Analysis/QuadTree/__init__.py	(original)
+++ ./PYME/Analysis/QuadTree/__init__.py	(refactored)
@@ -21,5 +21,5 @@
 #
 ##################
 
-from pointQT import * 
-from QTrend import * 
+from .pointQT import * 
+from .QTrend import * 
--- ./PYME/Analysis/QuadTree/pointQT.py	(original)
+++ ./PYME/Analysis/QuadTree/pointQT.py	(refactored)
@@ -90,14 +90,14 @@
         return [r for r in self.records if (r.x > x0) and (r.x < x1) and (r.y > y0) and (r.y < y1)]
 
     def drawTree(self, depth=0):
-        st = u'' + repr(self) +'\n'
+        st = '' + repr(self) +'\n'
         for r in self.records:
             for i in range(depth):
-                st += u'\u2502 '
-            st += u'\u251C\u2500' + str(r) +'\n'
-
-        for i in range(depth):
-                st += u'\u2502 '
+                st += '\u2502 '
+            st += '\u251C\u2500' + str(r) +'\n'
+
+        for i in range(depth):
+                st += '\u2502 '
         st += '\n'
         return st
 
@@ -161,20 +161,20 @@
     def drawTree(self, depth=0):
         st = repr(self) +'\n'
         for i in range(depth):
-            st += u'\u2502 '
-        st += u'\u251C\u2500NW ' + self.NW.drawTree(depth+1)
-        for i in range(depth):
-            st += u'\u2502 '
-        st += u'\u251C\u2500NE ' + self.NE.drawTree(depth+1) 
-        for i in range(depth):
-            st += u'\u2502 '
-        st += u'\u251C\u2500SE ' + self.SE.drawTree(depth+1) 
-        for i in range(depth):
-            st += u'\u2502 '
-        st += u'\u251C\u2500SW ' + self.SW.drawTree(depth+1)
-
-        for i in range(depth):
-                st += u'\u2502 '
+            st += '\u2502 '
+        st += '\u251C\u2500NW ' + self.NW.drawTree(depth+1)
+        for i in range(depth):
+            st += '\u2502 '
+        st += '\u251C\u2500NE ' + self.NE.drawTree(depth+1) 
+        for i in range(depth):
+            st += '\u2502 '
+        st += '\u251C\u2500SE ' + self.SE.drawTree(depth+1) 
+        for i in range(depth):
+            st += '\u2502 '
+        st += '\u251C\u2500SW ' + self.SW.drawTree(depth+1)
+
+        for i in range(depth):
+                st += '\u2502 '
         st += '\n'
 
         return st
--- ./PYME/Analysis/QuadTree/qtUtils.py	(original)
+++ ./PYME/Analysis/QuadTree/qtUtils.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-import pointQT
+from . import pointQT
 import MetaData
 
 def compareOriginalWithRec(ofd, qt, radius = 250, md = MetaData.TIRFDefault):
--- ./PYME/Analysis/QuadTree/rendQT.py	(original)
+++ ./PYME/Analysis/QuadTree/rendQT.py	(refactored)
@@ -35,7 +35,7 @@
     Is = [float(l.numRecords)*2**(2*l.depth) for l in lvs]
 
     maxI = max(Is)
-    print maxI
+    print(maxI)
 
     for l in lvs:
         c = cmap((float(l.numRecords)*2**(2*l.depth))/(maxI*maxIsc))
@@ -53,7 +53,7 @@
     Is = [float(l.numRecords)*2**(2*l.depth) for l in lvs]
 
     maxI = max(Is)
-    print maxI
+    print(maxI)
 
     for l in lvs:
         c = cmap((float(l.numRecords)*2**(2*l.depth))/(maxI*maxIsc))
@@ -75,7 +75,7 @@
     dX = max(dX, dY)
     dY = dX
 
-    print dX
+    print(dX)
 
     for l in lvs:
         dx = l.x1 - l.x0
@@ -103,7 +103,7 @@
     dX = max(dX, dY)
     dY = dX
 
-    print dX
+    print(dX)
 
     ar[:,:] = 0 # initialize
     numevts = 0
--- ./PYME/Analysis/SoftRend/__init__.py	(original)
+++ ./PYME/Analysis/SoftRend/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from triRend import *
+from .triRend import *
--- ./PYME/Analysis/Test/fitTestJig.py	(original)
+++ ./PYME/Analysis/Test/fitTestJig.py	(refactored)
@@ -115,7 +115,7 @@
                 yv += self.__getattribute__(varName)
                 
             me = ((self.ps[varName].ravel() - yv)**2).mean()
-            print '%s: %3.2f' % (varName, me)
+            print('%s: %3.2f' % (varName, me))
             
     def error(self, varName):
         xv = self.ps[varName].ravel()
--- ./PYME/Analysis/Test/fitTestJigWC.py	(original)
+++ ./PYME/Analysis/Test/fitTestJigWC.py	(refactored)
@@ -123,7 +123,7 @@
                 yv = yv + self.__getattribute__(varName)
                 
             me = ((self.ps[varName].ravel() - yv)**2).mean()
-            print '%s: %3.2f' % (varName, me)
+            print('%s: %3.2f' % (varName, me))
             
             
     def error(self, varName):
--- ./PYME/Analysis/cInterp/__init__.py	(original)
+++ ./PYME/Analysis/cInterp/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from cInterp import *
+from .cInterp import *
--- ./PYME/Analysis/cModels/__init__.py	(original)
+++ ./PYME/Analysis/cModels/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from gauss_app import *
+from .gauss_app import *
--- ./PYME/Analysis/qHull/__init__.py	(original)
+++ ./PYME/Analysis/qHull/__init__.py	(refactored)
@@ -24,4 +24,4 @@
 
 
 if __name__ == "__main__":
-    print "Hello";
+    print("Hello");
--- ./PYME/Analysis/qHull/setup.py	(original)
+++ ./PYME/Analysis/qHull/setup.py	(refactored)
@@ -38,10 +38,10 @@
 
     #check for drift correction code
     if os.path.exists(os.path.join(config.local_path, '../DriftCorrection/triangLhood.c')):
-        print yellow_text('compiling with drift correction')
+        print(yellow_text('compiling with drift correction'))
         srcs.append('../DriftCorrection/triangLhood.c')
     else:
-        print yellow_text('compiling without drift correction')
+        print(yellow_text('compiling without drift correction'))
         srcs.append('lhoodStubs.c')
 
     config.add_extension('triangWrap',
--- ./PYME/DSView/DisplayOptionsPanel.py	(original)
+++ ./PYME/DSView/DisplayOptionsPanel.py	(refactored)
@@ -28,7 +28,7 @@
 import numpy as np
 #from matplotlib import cm
 from PYME.Analysis.LMVis import histLimits
-from displayOptions import DisplayOpts, fast_grey, labeled
+from .displayOptions import DisplayOpts, fast_grey, labeled
 
 import os
 dirname = os.path.dirname(__file__)
@@ -370,7 +370,7 @@
         self.do.OnChange()
 
     def OnLineThickness(self, event):
-        print 'foo'
+        print('foo')
         dlg = wx.TextEntryDialog(self, 'Line Thickness', 'Set width of line selection', '%d' % self.do.selectionWidth)
 
         if dlg.ShowModal() == wx.ID_OK:
--- ./PYME/DSView/__init__.py	(original)
+++ ./PYME/DSView/__init__.py	(refactored)
@@ -20,5 +20,5 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 ################
-from dsviewer_npy_nb import View3D, ViewIm3D
-from image import ImageStack
+from .dsviewer_npy_nb import View3D, ViewIm3D
+from .image import ImageStack
--- ./PYME/DSView/arrayViewPanel.py	(original)
+++ ./PYME/DSView/arrayViewPanel.py	(refactored)
@@ -41,7 +41,7 @@
 LUTCache = {}
 
 def getLUT(cmap):
-    if not cmap.name in LUTCache.keys():
+    if not cmap.name in list(LUTCache.keys()):
         #calculate and cache LUT
         LUTCache[cmap.name] = (255*(cmap(numpy.linspace(0,1,256))[:,:3].T)).copy().astype('uint8')
 
@@ -290,7 +290,7 @@
                     dc.DrawRectangle(sc*p[1]-self.psfROISize[1]*sc - x0,sc*p[2]*self.aspect - self.psfROISize[2]*sc*self.aspect - y0, 2*self.psfROISize[1]*sc,2*self.psfROISize[2]*sc*self.aspect)
 
 
-        if self.showTracks and 'filter' in dir(self) and 'clumpIndex' in self.filter.keys():
+        if self.showTracks and 'filter' in dir(self) and 'clumpIndex' in list(self.filter.keys()):
             if(self.do.slice == self.do.SLICE_XY):
                 IFoc = (abs(self.filter['t'] - self.do.zp) < 1)
                                
@@ -676,10 +676,10 @@
         pos = event.GetLogicalPosition(dc)
         pos = self.CalcUnscrolledPosition(*pos)
 
-        print pos
+        print(pos)
         self.do.inOnChange = True
         sc = pow(2.0,(self.do.scale))
-        print sc
+        print(sc)
         if (self.do.slice == self.do.SLICE_XY):
             self.do.xp =int(pos[0]/sc)
             self.do.yp = int(pos[1]/(sc*self.aspect))
--- ./PYME/DSView/dataExporter.py	(original)
+++ ./PYME/DSView/dataExporter.py	(refactored)
@@ -83,7 +83,7 @@
 
         xSize, ySize = data[xslice, yslice, 0].shape[:2]
         
-        print xSize, ySize
+        print(xSize, ySize)
         
         #atm = tables.UInt16Atom()
         atm = tables.Atom.from_dtype(data[xslice, yslice, 0].dtype)
@@ -159,7 +159,7 @@
                     chanNames = metadata['ChannelNames']    
 
                 else:
-                    chanNames = range(data.shape[3])
+                    chanNames = list(range(data.shape[3]))
 
                 chanFiles = [os.path.splitext(os.path.split(outFile)[1])[0] + '__%s.tif' % chanNames[i]  for i in range(data.shape[3])]
                 if not metadata == None:
@@ -179,7 +179,7 @@
             xmd.setEntry('cropping.yslice', yslice.indices(data.shape[1]))
             xmd.setEntry('cropping.zslice', zslice.indices(data.shape[2]))
 
-            print xslice.indices(data.shape[0])
+            print(xslice.indices(data.shape[0]))
             
             xmlFile = os.path.splitext(outFile)[0] + '.xml'
             xmd.writeXML(xmlFile)
@@ -255,9 +255,9 @@
 
     def Export(self, data, outFile, xslice, yslice, zslice, metadata=None, events = None, origName=None):
         #numpy.save(outFile, data[xslice, yslice, zslice])
-        import cPickle
+        import pickle
         fid = open(outFile, 'wb')
-        cPickle.dump((data[xslice, yslice, zslice], metadata.voxelsize), fid, 2)
+        pickle.dump((data[xslice, yslice, zslice], metadata.voxelsize), fid, 2)
         fid.close()
 
 exporter(PSFExporter)
@@ -387,7 +387,7 @@
 
         defIndex = 0
 
-        for i, e in enumerate(exporters.values()):
+        for i, e in enumerate(list(exporters.values())):
             wcs.append(e.descr + '|' + e.extension)
             if e.extension == defaultExt:
                 defIndex = i
@@ -450,8 +450,8 @@
     
     ext = '*' + os.path.splitext(filename)[1]
         
-    if not ext in exportersByExtension.keys():
-        wx.MessageBox('No exporter found for %s files\n Try one of the following file types:\n%s' % (ext, ', '.join(exportersByExtension.keys())), "Error saving data", wx.OK|wx.ICON_HAND)
+    if not ext in list(exportersByExtension.keys()):
+        wx.MessageBox('No exporter found for %s files\n Try one of the following file types:\n%s' % (ext, ', '.join(list(exportersByExtension.keys()))), "Error saving data", wx.OK|wx.ICON_HAND)
         return
 
     exp = exportersByExtension[ext]()
--- ./PYME/DSView/displayOptions.py	(original)
+++ ./PYME/DSView/displayOptions.py	(refactored)
@@ -50,11 +50,11 @@
      
 
 class DisplayOpts(object):
-    UPRIGHT, ROT90 = range(2)
-    SLICE_XY, SLICE_XZ, SLICE_YZ = range(3)
-
-    ACTION_POSITION, ACTION_SELECTION = range(2)
-    SELECTION_RECTANGLE, SELECTION_LINE, SELECTION_SQUIGLE = range(3)
+    UPRIGHT, ROT90 = list(range(2))
+    SLICE_XY, SLICE_XZ, SLICE_YZ = list(range(3))
+
+    ACTION_POSITION, ACTION_SELECTION = list(range(2))
+    SELECTION_RECTANGLE, SELECTION_LINE, SELECTION_SQUIGLE = list(range(3))
 
     def __init__(self, datasource, xp=0, yp=0, zp=0, aspect=1):
         self.WantChangeNotification = []# MyWeakSet() #[]
@@ -158,7 +158,9 @@
         
         self.selection_trace = []
 
-    def SetSelection(self, (b_x,b_y,b_z),(e_x,e_y,e_z)):
+    def SetSelection(self, xxx_todo_changeme, xxx_todo_changeme1):
+        (b_x,b_y,b_z) = xxx_todo_changeme
+        (e_x,e_y,e_z) = xxx_todo_changeme1
         self.selection_begin_x = b_x
         self.selection_begin_y = b_y
         self.selection_begin_z = b_z
@@ -275,7 +277,7 @@
                     syn.Synchronise(self)
             
             except Exception as e: 
-                print e
+                print(e)
             finally:
                 self.inOnChange = False
             
--- ./PYME/DSView/displaySettingsPanel.py	(original)
+++ ./PYME/DSView/displaySettingsPanel.py	(refactored)
@@ -55,7 +55,7 @@
             self.vp.do.Optimise(self.vp.ds)
 
 
-        print self.dsa.size
+        print(self.dsa.size)
         #self.do = vp.do
         
 
@@ -150,7 +150,7 @@
     def __getattr__(self, name):
         if name in dir(self.hlDispMapping):
             return self.hlDispMapping.__dict__[name]
-        else:  raise AttributeError, name  # <<< DON'T FORGET THIS LINE !!
+        else:  raise AttributeError(name)  # <<< DON'T FORGET THIS LINE !!
 
 class dispSettingsPanel2(wx.Panel):
     def __init__(self, parent, vp):
@@ -245,4 +245,4 @@
     def __getattr__(self, name):
         if name in dir(self.hlDispMapping):
             return self.hlDispMapping.__dict__[name]
-        else:  raise AttributeError, name  # <<< DON'T FORGET THIS LINE !!
+        else:  raise AttributeError(name)  # <<< DON'T FORGET THIS LINE !!
--- ./PYME/DSView/dsviewer_npy.py	(original)
+++ ./PYME/DSView/dsviewer_npy.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import wx
-from arrayViewPanel import ArraySettingsAndViewPanel
+from .arrayViewPanel import ArraySettingsAndViewPanel
 
 class DSViewFrame(wx.Frame):
     def __init__(self, parent=None, title='', dstack = None, log = None, filename = None, mdh = None, size = (400,300)):
@@ -74,7 +74,7 @@
         self.statusbar.SetStatusText('Slice No: (%d/%d)  x: %d  y: %d' % (self.do.zp, self.do.ds.shape[2], self.do.xp, self.do.yp))
 
     def OnSave(self, event=None):
-        import dataExporter
+        from . import dataExporter
 
         if 'getEvents' in dir(self.ds):
             evts = self.ds.getEvents()
@@ -88,7 +88,7 @@
         self.saved = True
 
     def OnExport(self, event=None):
-        import dataExporter
+        from . import dataExporter
 
         if 'getEvents' in dir(self.ds):
             evts = self.ds.getEvents()
--- ./PYME/DSView/dsviewer_npy_nb.py	(original)
+++ ./PYME/DSView/dsviewer_npy_nb.py	(refactored)
@@ -24,7 +24,7 @@
 import wx.lib.agw.aui as aui
 
 import pylab
-import modules
+from . import modules
 
 import PYME.misc.autoFoldPanel as afp
 #from PYME.DSView.arrayViewPanel import ArraySettingsAndViewPanel
@@ -42,7 +42,7 @@
 
 class dt(wx.FileDropTarget):
     def OnDropFiles(self, x, y, filenames):
-        print filenames
+        print(filenames)
         
         for filename in filenames:
             im = ImageStack(filename=filename)
@@ -199,7 +199,7 @@
             self._mgr.Update()
             pn = self._mgr.GetPaneByName(self.pane0)
             if pn.IsNotebookPage():
-                print pn.notebook_id
+                print(pn.notebook_id)
                 nbs = self._mgr.GetNotebooks()
                 if len(nbs) > pn.notebook_id:
                     currPage = nbs[pn.notebook_id].GetSelection()
--- ./PYME/DSView/fitInfo.py	(original)
+++ ./PYME/DSView/fitInfo.py	(refactored)
@@ -69,7 +69,7 @@
         self.SetSizerAndFit(vsizer)
 
     def genResultsText(self, index):
-        s =  u''
+        s =  ''
         ns = self.fitResults['fitResults'].dtype.names
 
         nl = max([len(n) for n in ns])
@@ -84,9 +84,9 @@
             for n in ns:
                 #\u00B1 is the plus-minus sign
                 if 'fitError' in r.dtype.names:
-                    s += u'%s %8.2f \u00B1 %3.2f\n' % ((n + ':').ljust(nl+1), r['fitResults'][n], r['fitError'][n])
+                    s += '%s %8.2f \u00B1 %3.2f\n' % ((n + ':').ljust(nl+1), r['fitResults'][n], r['fitError'][n])
                 else:
-                    s += u'%s %8.2f\n' % ((n + ':').ljust(nl+1), r['fitResults'][n])
+                    s += '%s %8.2f\n' % ((n + ':').ljust(nl+1), r['fitResults'][n])
 
             #s = s[:-1]
             if 'resultCode' in r.dtype.names:
@@ -95,16 +95,16 @@
             if 'startParams' in r.dtype.names:
                 s += '\n\nStart Params:\n%s' % str(r['startParams'])
             if 'nchi2' in r.dtype.names:
-                s += u'\n\u03A7\u00B2/\u03BD: %3.2f' % r['nchi2']
+                s += '\n\u03A7\u00B2/\u03BD: %3.2f' % r['nchi2']
         else:    
             for n in ns:
-                s += u'%s:\n' % (n)
+                s += '%s:\n' % (n)
                 
         return s
 
 
     def genGaussPhotonStats(self, index):
-        s =  u''
+        s =  ''
 
         if not index == None:
             r = self.fitResults[index]['fitResults']
@@ -252,7 +252,7 @@
                 dxp = int(DeltaX/vx)
                 dyp = int(DeltaY/vy)
                 
-                print DeltaX, DeltaY, dxp, dyp
+                print(DeltaX, DeltaY, dxp, dyp)
                 
                 x1 -= dxp
                 y1 -= dyp
@@ -264,7 +264,7 @@
             else:
                 sy1 = slice(y1+ sluy[0], y1+sluy[1]) #FIXME
                 
-            print sx0, sx1, sy0, sy1
+            print(sx0, sx1, sy0, sy1)
                 
             g = self.ds[sx0, sy0, int(fri['tIndex'])].squeeze()
             r = self.ds[sx1, sy1, int(fri['tIndex'])].squeeze()
--- ./PYME/DSView/image.py	(original)
+++ ./PYME/DSView/image.py	(refactored)
@@ -304,7 +304,7 @@
         else:
             self.mdh = MetaData.TIRFDefault
             wx.MessageBox("Carrying on with defaults - no gaurantees it'll work well", 'ERROR: No metadata found in file ...', wx.OK)
-            print "ERROR: No metadata fond in file ... Carrying on with defaults - no gaurantees it'll work well"
+            print("ERROR: No metadata fond in file ... Carrying on with defaults - no gaurantees it'll work well")
 
         #attempt to estimate any missing parameters from the data itself        
         MetaData.fillInBlanks(self.mdh, self.dataSource)
@@ -316,7 +316,7 @@
         #try and find a previously performed analysis
         fns = filename.split(os.path.sep)
         cand = os.path.sep.join(fns[:-2] + ['analysis',] + fns[-2:]) + 'r'
-        print cand
+        print(cand)
         if os.path.exists(cand):
             h5Results = tables.openFile(cand)
 
@@ -404,7 +404,7 @@
                 self.mdh['voxelsize.z'] = lsm_info['plane_spacing']
                 
                 def lsm_pop(basename, dic):
-                    for k, v in dic.items():
+                    for k, v in list(dic.items()):
                         if isinstance(v, list):
                             #print k, v
                             for i, l_i in enumerate(v):
@@ -417,7 +417,7 @@
                 lsm_pop('LSM.', lsm_info)
                 
 
-        if self.haveGUI and not ('voxelsize.x' in self.mdh.keys() and 'voxelsize.y' in self.mdh.keys()):
+        if self.haveGUI and not ('voxelsize.x' in list(self.mdh.keys()) and 'voxelsize.y' in list(self.mdh.keys())):
             from PYME.DSView.voxSizeDialog import VoxSizeDialog
 
             dlg = VoxSizeDialog(None)
@@ -466,7 +466,7 @@
             from PYME.DSView.dataWrap import ListWrap
             chans = [numpy.atleast_3d(self.data.getSlice(i)) for i in range(len(self.mdh['ChannelNames']))]
             self.data = ListWrap(chans)
-        elif filename.endswith('.lsm') and 'LSM.images_number_channels' in self.mdh.keys() and self.mdh['LSM.images_number_channels'] > 1:
+        elif filename.endswith('.lsm') and 'LSM.images_number_channels' in list(self.mdh.keys()) and self.mdh['LSM.images_number_channels'] > 1:
             from PYME.DSView.dataWrap import ListWrap
             nChans = self.mdh['LSM.images_number_channels']
             
@@ -508,7 +508,7 @@
         self.mode = 'default'
 
     def Load(self, filename=None):
-        print filename
+        print(filename)
         if (filename == None):
             import wx #only introduce wx dependency here - so can be used non-interactively
             global lastdir
@@ -540,7 +540,7 @@
             self.saved = True
 
     def Save(self, filename=None, crop=False, view=None):
-        import dataExporter
+        from . import dataExporter
 
         ofn = self.filename
 
--- ./PYME/DSView/logparser.py	(original)
+++ ./PYME/DSView/logparser.py	(refactored)
@@ -86,12 +86,12 @@
         
         s = ''
         
-        cats = log.keys()
+        cats = list(log.keys())
         cats.sort()
         for category in cats:
             s = s + '[%s]\n' % category
             
-            entries = log[category].keys()
+            entries = list(log[category].keys())
             entries.sort()
             for entry in entries:
                 s = s + '%s=%s\n' % (entry, log[category][entry])
--- ./PYME/DSView/scrolledImagePanel.py	(original)
+++ ./PYME/DSView/scrolledImagePanel.py	(refactored)
@@ -145,7 +145,7 @@
 
     def OnScrollY(self,event):
         self.yOff = event.GetPosition()
-        print self.yOff
+        print(self.yOff)
 
         self.imagepanel.Refresh()
 
--- ./PYME/DSView/viewpanellite.py	(original)
+++ ./PYME/DSView/viewpanellite.py	(refactored)
@@ -230,7 +230,7 @@
 
         pos = event.GetLogicalPosition(dc)
 
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale))
 
         if (self.do.getSliceAxis() == self.do.SLICE_XY):
@@ -250,7 +250,7 @@
 
         pos = event.GetLogicalPosition(dc)
 
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale))
 
         if (self.do.getSliceAxis() == self.do.SLICE_XY):
@@ -303,7 +303,9 @@
         self.selection_end_y = self.ds.getHeight() - 1
         self.selection_end_z = self.ds.getDepth() - 1
         
-    def SetSelection(self, (b_x,b_y,b_z),(e_x,e_y,e_z)):
+    def SetSelection(self, xxx_todo_changeme, xxx_todo_changeme1):
+        (b_x,b_y,b_z) = xxx_todo_changeme
+        (e_x,e_y,e_z) = xxx_todo_changeme1
         self.selection_begin_x = b_x
         self.selection_begin_y = b_y
         self.selection_begin_z = b_z
--- ./PYME/DSView/voxSizeDialog.py	(original)
+++ ./PYME/DSView/voxSizeDialog.py	(refactored)
@@ -31,7 +31,7 @@
         #sizer2 = wx.BoxSizer(wx.HORIZONTAL)
 
         sizer2 = wx.BoxSizer(wx.HORIZONTAL)
-        sizer2.Add(wx.StaticText(self, -1, u'x [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
+        sizer2.Add(wx.StaticText(self, -1, 'x [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
         self.tVoxX = wx.TextCtrl(self, -1, '0.08')
 
         sizer2.Add(self.tVoxX, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
@@ -39,7 +39,7 @@
         sizer1.Add(sizer2, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 0)
 
         sizer2 = wx.BoxSizer(wx.HORIZONTAL)
-        sizer2.Add(wx.StaticText(self, -1, u'y [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
+        sizer2.Add(wx.StaticText(self, -1, 'y [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
         self.tVoxY = wx.TextCtrl(self, -1, '0.08')
 
         sizer2.Add(self.tVoxY, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
@@ -47,7 +47,7 @@
         sizer1.Add(sizer2, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 0)
 
         sizer2 = wx.BoxSizer(wx.HORIZONTAL)
-        sizer2.Add(wx.StaticText(self, -1, u'z [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
+        sizer2.Add(wx.StaticText(self, -1, 'z [\u03BCm]:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
         self.tVoxZ = wx.TextCtrl(self, -1, '0.2')
 
         sizer2.Add(self.tVoxZ, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
--- ./PYME/DSView/LUT/__init__.py	(original)
+++ ./PYME/DSView/LUT/__init__.py	(refactored)
@@ -21,7 +21,7 @@
 #
 ##################
 
-from lut import *
+from .lut import *
 
 def applyLUT(seg, gain, offset, lut, ima):
     if seg.dtype == 'uint8':
--- ./PYME/DSView/LUT/test_lut.py	(original)
+++ ./PYME/DSView/LUT/test_lut.py	(refactored)
@@ -22,10 +22,10 @@
 
 from pylab import *
 
-import lut
+from . import lut
 
 lut1 = (255*cm.gray(linspace(0,1,256))[:,:3].T).astype('uint8').copy()
-print lut1.shape
+print(lut1.shape)
 
 def testLut():
     d = (100*rand(5,5)).astype('uint16')
@@ -35,6 +35,6 @@
     lut.applyLUTu16(d, .01, 0,lut1, o)
     lut.applyLUTf(d.astype('uint16'), .01, 0,lut1, o)
     
-    print o
-    print lut1.T[((d + 0)*.01*256).astype('i')]
+    print(o)
+    print(lut1.T[((d + 0)*.01*256).astype('i')])
 
--- ./PYME/DSView/loft/dCrop.py	(original)
+++ ./PYME/DSView/loft/dCrop.py	(refactored)
@@ -24,7 +24,7 @@
  wxID_DCROPSTATICTEXT4, wxID_DCROPSTATICTEXT5, wxID_DCROPSTATICTEXT6, 
  wxID_DCROPSTSIZE, wxID_DCROPTXEND, wxID_DCROPTXSTART, wxID_DCROPTYEND, 
  wxID_DCROPTYSTART, wxID_DCROPTZEND, wxID_DCROPTZSTART, 
-] = map(lambda _init_ctrls: wx.NewId(), range(17))
+] = [wx.NewId() for _init_ctrls in range(17)]
 
 class dCrop(wx.Dialog):
     def _init_ctrls(self, prnt):
--- ./PYME/DSView/loft/dsviewer.py	(original)
+++ ./PYME/DSView/loft/dsviewer.py	(refactored)
@@ -151,7 +151,7 @@
 class MyApp(wx.App):
     def OnInit(self):
         #wx.InitAllImageHandlers()
-        print sys.argv
+        print(sys.argv)
         if (len(sys.argv) > 1):
             vframe = DSViewFrame(None, sys.argv[1], filename=sys.argv[1])
         else:
--- ./PYME/DSView/loft/dsviewer_seq.py	(original)
+++ ./PYME/DSView/loft/dsviewer_seq.py	(refactored)
@@ -160,8 +160,8 @@
                     dsa -= dsa.min()
             
             if (not self.bg == None) and self.bgSub:
-                print dsa.shape
-                print self.bg.shape
+                print(dsa.shape)
+                print(self.bg.shape)
                 if self.numAvg == 0:
                     dsa -= self.bg
                 else:
@@ -198,7 +198,7 @@
 class MyApp(wx.App):
     def OnInit(self):
         #wx.InitAllImageHandlers()
-        print sys.argv
+        print(sys.argv)
         bg = None
         if (len(sys.argv) > 1):
             fnms = os.listdir(sys.argv[1])
--- ./PYME/DSView/loft/fth5.py	(original)
+++ ./PYME/DSView/loft/fth5.py	(refactored)
@@ -21,7 +21,7 @@
 from PYME.FileUtils.nameUtils import genResultFileName
 
 if not 'tq' in locals():
-    if 'PYME_TASKQUEUENAME' in os.environ.keys():
+    if 'PYME_TASKQUEUENAME' in list(os.environ.keys()):
         taskQueueName = os.environ['PYME_TASKQUEUENAME']
     else:
         taskQueueName = 'taskQueue'
@@ -68,11 +68,11 @@
     
 
 def testFrame(detThresh = 0.9):
-    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), cFitType.GetString(cFitType.GetSelection()), bgindices=range(max(vp.zp-10, mdh.getEntry('EstimatedLaserOnFrameNo')),vp.zp), SNThreshold=True)
+    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), cFitType.GetString(cFitType.GetSelection()), bgindices=list(range(max(vp.zp-10, mdh.getEntry('EstimatedLaserOnFrameNo')),vp.zp)), SNThreshold=True)
     return ft(True)
 
 def testFrameTQ(detThresh = 0.9):
-    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', 'TQDataSource', bgindices=range(max(vp.zp-10, mdh.getEntry('EstimatedLaserOnFrameNo')),vp.zp), SNThreshold=True)
+    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', 'TQDataSource', bgindices=list(range(max(vp.zp-10, mdh.getEntry('EstimatedLaserOnFrameNo')),vp.zp)), SNThreshold=True)
     return ft(True, tq)
 
 def pushImagesD(startingAt=0, detThresh = .9):
@@ -80,11 +80,11 @@
     mdhQ = MetaDataHandler.QueueMDHandler(tq, seriesName, mdh)
     mdhQ.setEntry('Analysis.DetectionThreshold', detThresh)
     for i in range(startingAt, ds.shape[0]):
-        tq.postTask(remFitBuf.fitTask(seriesName,i, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', bgindices=range(max(i-10,mdh.getEntry('EstimatedLaserOnFrameNo') ),i), SNThreshold=True,driftEstInd=range(max(i-5, mdh.getEntry('EstimatedLaserOnFrameNo')),min(i + 5, ds.shape[0])), dataSourceModule=dataSource.moduleName), queueName=seriesName)
+        tq.postTask(remFitBuf.fitTask(seriesName,i, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', bgindices=list(range(max(i-10,mdh.getEntry('EstimatedLaserOnFrameNo') ),i)), SNThreshold=True,driftEstInd=list(range(max(i-5, mdh.getEntry('EstimatedLaserOnFrameNo')),min(i + 5, ds.shape[0]))), dataSourceModule=dataSource.moduleName), queueName=seriesName)
 
 
 def testFrameD(detThresh = 0.9):
-    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', bgindices=range(max(vp.zp-10, md.EstimatedLaserOnFrameNo),vp.zp), SNThreshold=True,driftEstInd=range(max(vp.zp-5, md.EstimatedLaserOnFrameNo),min(vp.zp + 5, ds.shape[0])))
+    ft = remFitBuf.fitTask(seriesName,vp.zp, detThresh, MetaDataHandler.NestedClassMDHandler(mdh), 'LatGaussFitFR', bgindices=list(range(max(vp.zp-10, md.EstimatedLaserOnFrameNo),vp.zp)), SNThreshold=True,driftEstInd=list(range(max(vp.zp-5, md.EstimatedLaserOnFrameNo),min(vp.zp + 5, ds.shape[0]))))
     return ft(True)
 
 def testFrames(detThresh = 0.9, offset = 0):
@@ -92,7 +92,7 @@
     matplotlib.interactive(False)
     clf()
     sq = min(mdh.getEntry('EstimatedLaserOnFrameNo') + 1000, dataSource.getNumSlices()/4)
-    zps = array(range(mdh.getEntry('EstimatedLaserOnFrameNo') + 20, mdh.getEntry('EstimatedLaserOnFrameNo') + 24)  + range(sq, sq + 4) + range(dataSource.getNumSlices()/2,dataSource.getNumSlices() /2+4))
+    zps = array(list(range(mdh.getEntry('EstimatedLaserOnFrameNo') + 20, mdh.getEntry('EstimatedLaserOnFrameNo') + 24))  + list(range(sq, sq + 4)) + list(range(dataSource.getNumSlices()/2,dataSource.getNumSlices() /2+4)))
     zps += offset
     fitMod = cFitType.GetStringSelection()
     #bgFrames = int(tBackgroundFrames.GetValue())
@@ -100,7 +100,7 @@
     for i in range(12):
         #if 'Analysis.NumBGFrames' in md.getEntryNames():
         #bgi = range(max(zps[i] - bgFrames,mdh.getEntry('EstimatedLaserOnFrameNo')), zps[i])
-        bgi = range(max(zps[i] + bgFrames[0],mdh.getEntry('EstimatedLaserOnFrameNo')), max(zps[i] + bgFrames[1],mdh.getEntry('EstimatedLaserOnFrameNo')))
+        bgi = list(range(max(zps[i] + bgFrames[0],mdh.getEntry('EstimatedLaserOnFrameNo')), max(zps[i] + bgFrames[1],mdh.getEntry('EstimatedLaserOnFrameNo'))))
         #else:
         #    bgi = range(max(zps[i] - 10,md.EstimatedLaserOnFrameNo), zps[i])
         if 'Splitter' in fitMod:
--- ./PYME/DSView/loft/myviewpanel.py	(original)
+++ ./PYME/DSView/loft/myviewpanel.py	(refactored)
@@ -405,7 +405,7 @@
 
         pos = event.GetLogicalPosition(dc)
 
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale-2))
 
         if (self.do.getSliceAxis() == self.do.SLICE_XY):
@@ -424,7 +424,7 @@
 
         pos = event.GetLogicalPosition(dc)
 
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale-2))
 
         if (self.do.getSliceAxis() == self.do.SLICE_XY):
@@ -451,7 +451,9 @@
         self.selection_end_y = self.ds.getHeight() - 1
         self.selection_end_z = self.ds.getDepth() - 1
         
-    def SetSelection(self, (b_x,b_y,b_z),(e_x,e_y,e_z)):
+    def SetSelection(self, xxx_todo_changeme, xxx_todo_changeme1):
+        (b_x,b_y,b_z) = xxx_todo_changeme
+        (e_x,e_y,e_z) = xxx_todo_changeme1
         self.selection_begin_x = b_x
         self.selection_begin_y = b_y
         self.selection_begin_z = b_z
--- ./PYME/DSView/loft/myviewpanel_numarray.py	(original)
+++ ./PYME/DSView/loft/myviewpanel_numarray.py	(refactored)
@@ -99,8 +99,8 @@
         return r
         
 class DisplayOpts:
-    UPRIGHT, ROT90 = range(2)
-    SLICE_XY, SLICE_XZ, SLICE_YZ = range(3)
+    UPRIGHT, ROT90 = list(range(2))
+    SLICE_XY, SLICE_XZ, SLICE_YZ = list(range(3))
     
     def __init__(self, nchans=1):
         if nchans ==1:
@@ -708,7 +708,7 @@
         dc = wx.ClientDC(self.imagepanel.impanel)
         self.imagepanel.impanel.PrepareDC(dc)
         pos = event.GetLogicalPosition(dc)
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale-2))
         if (self.do.slice == self.do.SLICE_XY):
             self.selection_begin_x = int(pos[0]/sc)
@@ -724,7 +724,7 @@
         dc = wx.ClientDC(self.imagepanel.impanel)
         self.imagepanel.impanel.PrepareDC(dc)
         pos = event.GetLogicalPosition(dc)
-        print pos
+        print(pos)
         sc = pow(2.0,(self.scale-2))
         if (self.do.slice == self.do.SLICE_XY):
             self.selection_end_x = int(pos[0]/sc)
@@ -749,7 +749,9 @@
         self.selection_end_y = self.ds.shape[1] - 1
         self.selection_end_z = self.ds.shape[2] - 1
         
-    def SetSelection(self, (b_x,b_y,b_z),(e_x,e_y,e_z)):
+    def SetSelection(self, xxx_todo_changeme, xxx_todo_changeme1):
+        (b_x,b_y,b_z) = xxx_todo_changeme
+        (e_x,e_y,e_z) = xxx_todo_changeme1
         self.selection_begin_x = b_x
         self.selection_begin_y = b_y
         self.selection_begin_z = b_z
--- ./PYME/DSView/loft/viewpanelN.py	(original)
+++ ./PYME/DSView/loft/viewpanelN.py	(refactored)
@@ -268,7 +268,7 @@
 
     def OnScrollY(self,event):
         self.yOff = event.GetPosition()
-        print self.yOff
+        print(self.yOff)
 
         self.impanel.Refresh()
 
--- ./PYME/DSView/modules/LMAnalysis.py	(original)
+++ ./PYME/DSView/modules/LMAnalysis.py	(refactored)
@@ -46,7 +46,7 @@
 
 def debugPrint(msg):
     if debug:
-        print msg
+        print(msg)
         
 
 
@@ -137,7 +137,7 @@
         else:
             self.do.zp = self.image.mdh.getEntry('EstimatedLaserOnFrameNo')
         
-        if (len(self.fitResults) > 0) and not 'PYME_BUGGYOPENGL' in os.environ.keys():
+        if (len(self.fitResults) > 0) and not 'PYME_BUGGYOPENGL' in list(os.environ.keys()):
             self.GenResultsView()
 
     def GenResultsView(self):
@@ -297,7 +297,7 @@
 
         #find out what fit factories we have
         self.fitFactories = PYME.Analysis.FitFactories.resFitFactories
-        print self.fitFactories
+        print(self.fitFactories)
 
         vsizer = wx.BoxSizer(wx.VERTICAL)
         hsizer = wx.BoxSizer(wx.HORIZONTAL)
@@ -396,7 +396,7 @@
 
             
         if debug:
-            print 'About to push images'
+            print('About to push images')
 
         if not driftEst:
             self.pushImages(startAt, threshold, fitMod)
@@ -404,7 +404,7 @@
             self.pushImagesD(startAt, threshold)
             
         if debug:
-            print 'Images pushed'
+            print('Images pushed')
 
         #############
         #set up real time display
@@ -629,7 +629,7 @@
                 self.fitInf.UpdateDisp(self.view.PointsHitTest())
             except:
                 import traceback
-                print traceback.format_exc()
+                print(traceback.format_exc())
 
 
     #from fth5.py
@@ -662,7 +662,7 @@
     def pushImages(self, startingAt=0, detThresh = .9, fitFcn = 'LatGaussFitFR'):
         self.checkTQ()
         if debug:
-            print 'TQ checked'
+            print('TQ checked')
         if self.image.dataSource.moduleName == 'HDFDataSource':
             self.pushImagesHDF(startingAt, detThresh, fitFcn)
         elif self.image.dataSource.moduleName == 'TQDataSource':
@@ -754,11 +754,11 @@
         for i in range(startingAt, self.image.dataSource.getNumSlices()):
             debugPrint('Posting task %d' %i)
             if 'Analysis.BGRange' in md.getEntryNames():
-                bgi = range(max(i + md.Analysis.BGRange[0],md.EstimatedLaserOnFrameNo), max(i + md.Analysis.BGRange[1],md.EstimatedLaserOnFrameNo))
+                bgi = list(range(max(i + md.Analysis.BGRange[0],md.EstimatedLaserOnFrameNo), max(i + md.Analysis.BGRange[1],md.EstimatedLaserOnFrameNo)))
             elif 'Analysis.NumBGFrames' in md.getEntryNames():
-                bgi = range(max(i - md.Analysis.NumBGFrames, md.EstimatedLaserOnFrameNo), i)
+                bgi = list(range(max(i - md.Analysis.NumBGFrames, md.EstimatedLaserOnFrameNo), i))
             else:
-                bgi = range(max(i - 10, md.EstimatedLaserOnFrameNo), i)
+                bgi = list(range(max(i - 10, md.EstimatedLaserOnFrameNo), i))
 
             #task = fitTask(self.queueID, taskNum, self.metaData.Analysis.DetectionThreshold, self.metaData, self.metaData.Analysis.FitModule, 'TQDataSource', bgindices =bgi, SNThreshold = True)
             
@@ -796,17 +796,17 @@
         matplotlib.interactive(False)
         clf()
         sq = min(self.image.mdh.getEntry('EstimatedLaserOnFrameNo') + 1000, self.image.dataSource.getNumSlices()/4)
-        zps = array(range(self.image.mdh.getEntry('EstimatedLaserOnFrameNo') + 20, self.image.mdh.getEntry('EstimatedLaserOnFrameNo') + 24)  + range(sq, sq + 4) + range(self.image.dataSource.getNumSlices()/2,self.image.dataSource.getNumSlices() /2+4))
+        zps = array(list(range(self.image.mdh.getEntry('EstimatedLaserOnFrameNo') + 20, self.image.mdh.getEntry('EstimatedLaserOnFrameNo') + 24))  + list(range(sq, sq + 4)) + list(range(self.image.dataSource.getNumSlices()/2,self.image.dataSource.getNumSlices() /2+4)))
         zps += offset
         fitMod = self.fitFactories[self.cFitType.GetSelection()]
         #bgFrames = int(tBackgroundFrames.GetValue())
         bgFrames = [int(v) for v in self.tBackgroundFrames.GetValue().split(':')]
-        print zps
+        print(zps)
         for i in range(12):
-            print i
+            print(i)
             #if 'Analysis.NumBGFrames' in md.getEntryNames():
             #bgi = range(max(zps[i] - bgFrames,mdh.getEntry('EstimatedLaserOnFrameNo')), zps[i])
-            bgi = range(max(zps[i] + bgFrames[0],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')), max(zps[i] + bgFrames[1],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')))
+            bgi = list(range(max(zps[i] + bgFrames[0],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')), max(zps[i] + bgFrames[1],self.image.mdh.getEntry('EstimatedLaserOnFrameNo'))))
             #else:
             #    bgi = range(max(zps[i] - 10,md.EstimatedLaserOnFrameNo), zps[i])
             mn = self.image.dataSource.moduleName
@@ -866,7 +866,7 @@
         #bgFrames = int(tBackgroundFrames.GetValue())
         bgFrames = [int(v) for v in self.tBackgroundFrames.GetValue().split(':')]
         #print zps
-        bgi = range(max(zp + bgFrames[0],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')), max(zp + bgFrames[1],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')))
+        bgi = list(range(max(zp + bgFrames[0],self.image.mdh.getEntry('EstimatedLaserOnFrameNo')), max(zp + bgFrames[1],self.image.mdh.getEntry('EstimatedLaserOnFrameNo'))))
             #else:
             #    bgi = range(max(zps[i] - 10,md.EstimatedLaserOnFrameNo), zps[i])
         mn = self.image.dataSource.moduleName
--- ./PYME/DSView/modules/__init__.py	(original)
+++ ./PYME/DSView/modules/__init__.py	(refactored)
@@ -55,7 +55,7 @@
 def loadMode(mode, dsviewer):
     '''install the relevant modules for a particular mode'''
 
-    if mode in modeModules.keys():
+    if mode in list(modeModules.keys()):
         mods = modeModules[mode]
     else:
         mods = modeModules['default']
--- ./PYME/DSView/modules/blobFinding.py	(original)
+++ ./PYME/DSView/modules/blobFinding.py	(refactored)
@@ -297,7 +297,7 @@
                 dy = y - y0
                 dz = z - z0
                 
-                print 'dz:', numpy.median(dz[mask])
+                print('dz:', numpy.median(dz[mask]))
                 
                 
                 spx, spy = twoColour.genShiftVectorFieldLinear(x[mask], y[mask], dx[mask], dy[mask], err_x[mask], err_y[mask])
@@ -312,15 +312,15 @@
         X, Y = numpy.meshgrid(numpy.linspace(0., 70.*self.image.data.shape[0], 20), numpy.linspace(0., 70.*self.image.data.shape[1], 20))
         X = X.ravel()
         Y = Y.ravel()
-        for k in self.shiftfields.keys():
+        for k in list(self.shiftfields.keys()):
             spx, spy, dz = self.shiftfields[k]
             pylab.quiver(X, Y, spx.ev(X, Y), spy.ev(X, Y), color=['r', 'g', 'b'][k], scale=2e3)
             
         pylab.axis('equal')
         
     def saveShiftmaps(self, event=None):
-        import cPickle
-        for k in self.shiftfields.keys():
+        import pickle
+        for k in list(self.shiftfields.keys()):
             fdialog = wx.FileDialog(None, 'Save Positions ...',
                 wildcard='Shiftmap|*.sm', defaultFile=os.path.splitext(self.image.names[k])[0] + '.sm', style=wx.SAVE|wx.HIDE_READONLY)
             succ = fdialog.ShowModal()
@@ -328,7 +328,7 @@
                 outFilename = fdialog.GetPath().encode()
                 
                 fid = open(outFilename, 'wb')
-                cPickle.dump(self.shiftfields[k], fid, 2)
+                pickle.dump(self.shiftfields[k], fid, 2)
                 fid.close()
                 
 
--- ./PYME/DSView/modules/blobMeasure.py	(original)
+++ ./PYME/DSView/modules/blobMeasure.py	(refactored)
@@ -36,7 +36,7 @@
 ig = iGen()
 
 def getNewID():
-    return ig.next()
+    return next(ig)
 
 
 class DataBlock(object):
@@ -117,7 +117,7 @@
             #use thresholded data for determining principle axis
             m = self.data
             m = m > 0.2*m.max()
-            print m.sum()
+            print(m.sum())
             l, nl = ndimage.label(m)
             
             #take only the largest contiguous region
@@ -127,7 +127,7 @@
                 if r.sum() > m.sum():
                     m = r
             b = b[m.ravel()>0.5, :]
-            print m.sum(), b.shape
+            print(m.sum(), b.shape)
             if b.shape[0] < 2:
                 self._principalAxis = np.NaN*np.ones(3)
             #print b.shape
@@ -446,7 +446,7 @@
             
     def getImage(self):
         import Image
-        import StringIO
+        import io
         import cherrypy
         cherrypy.response.headers["Content-Type"]="image/png"
         
@@ -481,7 +481,7 @@
 
         zoom = 200./max(xsize, ysize)
         
-        out = StringIO.StringIO()
+        out = io.StringIO()
         Image.fromarray(im).resize((int(zoom*ysize), int(zoom*xsize))).save(out, 'PNG')
         s = out.getvalue()
         out.close()
@@ -491,7 +491,7 @@
         #import Image
         from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
         from matplotlib.figure import Figure
-        import StringIO
+        import io
         import cherrypy
         cherrypy.response.headers["Content-Type"]="image/png"
         
@@ -510,7 +510,7 @@
             ax.plot(xv[:-1], yv[i], c = cols[i], lw=2)
         ax.set_xlabel(getattr(self, graphName).xlabel)
         
-        out = StringIO.StringIO()
+        out = io.StringIO()
         canvas.print_png(out, dpi=100)
         s = out.getvalue()
         out.close()
@@ -521,7 +521,7 @@
         from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
         from matplotlib.figure import Figure
         from matplotlib.patches import Rectangle
-        import StringIO
+        import io
         import cherrypy
         cherrypy.response.headers["Content-Type"]="image/png"
 
@@ -565,7 +565,7 @@
         
         ax.set_axis_off()
         
-        out = StringIO.StringIO()
+        out = io.StringIO()
         canvas.print_png(out, dpi=100)
         s = out.getvalue()
         out.close()
@@ -576,7 +576,7 @@
         from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
         from mpl_toolkits.mplot3d import Axes3D
         from matplotlib.figure import Figure
-        import StringIO
+        import io
         import cherrypy
         cherrypy.response.headers["Content-Type"]="image/png"
 
@@ -618,7 +618,7 @@
         #ax.axis('equal')
         #ax.set_axis_off()
         
-        out = StringIO.StringIO()
+        out = io.StringIO()
         canvas.print_png(out, dpi=100)
         s = out.getvalue()
         out.close()
@@ -733,7 +733,7 @@
         webbrowser.open('http://localhost:8080/measure/%d' % self.ID)
         
     def OnSaveObjects(self, event):
-        import cPickle
+        import pickle
         import zipfile
         
         zf = zipfile()
--- ./PYME/DSView/modules/coloc.py	(original)
+++ ./PYME/DSView/modules/coloc.py	(refactored)
@@ -128,13 +128,13 @@
 
         voxelsize = voxelsize[:imA.ndim] #trunctate to number of dimensions
 
-        print 'Calculating Pearson and Manders coefficients ...'        
+        print('Calculating Pearson and Manders coefficients ...')        
         pearson = correlationCoeffs.pearson(imA, imB)
         MA, MB = correlationCoeffs.thresholdedManders(imA, imB, tA, tB)
 
-        print 'Performing distance transform ...'        
+        print('Performing distance transform ...')        
         bnA, bmA, binsA = edtColoc.imageDensityAtDistance(imB, imA > tA, voxelsize, bins)
-        print 'Performing distance transform (reversed) ...' 
+        print('Performing distance transform (reversed) ...') 
         bnB, bmB, binsB = edtColoc.imageDensityAtDistance(imA, imB > tB, voxelsize, bins)
         
         #print binsB, bmB
--- ./PYME/DSView/modules/composite.py	(original)
+++ ./PYME/DSView/modules/composite.py	(refactored)
@@ -220,7 +220,7 @@
         return self.filectrls[chan].GetPath()
         
 def _getImage(name):
-    if name in image.openImages.keys():
+    if name in list(image.openImages.keys()):
         img = image.openImages[name]
         chan = 0
     else:
@@ -327,7 +327,7 @@
         wx.Dialog.__init__(self, parent, title='Composite')
         #nChans = image.data.shape[3]
         
-        self.imageNames =  image.openImages.keys()
+        self.imageNames =  list(image.openImages.keys())
         
         self.dispNames = []
         
@@ -619,7 +619,7 @@
                 order = 0
                 
             shape, origin, voxelsize = dlg.shape, dlg.origin, dlg.voxelsize
-            print shape, origin, voxelsize
+            print(shape, origin, voxelsize)
             
             if len(others) > 0:    
                 newNames = []
@@ -653,14 +653,14 @@
                     
                     if not np.allclose(other.pixelSize, voxelsize[0], rtol=.001) or not (other.data.shape[:3] == shape[:3]) or not originsEqual or shiftField:
                         #need to rescale ...
-                        print 'Remapping ', otherN, originsEqual, other.origin, np.allclose(other.pixelSize, voxelsize[0], rtol=.001), other.pixelSize, ignoreZ
+                        print('Remapping ', otherN, originsEqual, other.origin, np.allclose(other.pixelSize, voxelsize[0], rtol=.001), other.pixelSize, ignoreZ)
                         #print origin, voxelsize
                         od = self.RemapData(other, chan, shape, voxelsize, origin, shiftField = shiftField, ignoreZ=ignoreZ, order=order)
                         
                     newData += [od]
     
                 pre = common_prefix(newNames)
-                print pre
+                print(pre)
                 lPre = len(pre)
                 newNames = [n[lPre:] for n in newNames]                
                 
@@ -736,7 +736,7 @@
             Ynm += dy
             Znm += dz
             
-        print vx, vy, vz, data.shape
+        print(vx, vy, vz, data.shape)
             
         return ndimage.map_coordinates(data, [(Xnm - x0)/vx, (Ynm - y0)/vy, (Znm - z0)/vz], mode='nearest', order = order)
         
--- ./PYME/DSView/modules/deconvolution.py	(original)
+++ ./PYME/DSView/modules/deconvolution.py	(refactored)
@@ -125,7 +125,7 @@
 
                 psf = psf[:,:,numpy.floor(dz/2):(psf.shape[2]-numpy.ceil(dz/2))]
 
-            print data.shape, psf.shape
+            print(data.shape, psf.shape)
 
             if dlg.GetPadding():
                 padsize = numpy.array(dlg.GetPadSize())
@@ -310,7 +310,7 @@
         sizer2.Add(sizer3, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL | wx.ALL, 0)
 
         sizer3 = wx.BoxSizer(wx.HORIZONTAL)
-        sizer3.Add(wx.StaticText(self, -1, u'Regularisation \u03BB:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
+        sizer3.Add(wx.StaticText(self, -1, 'Regularisation \u03BB:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
         self.tRegLambda = wx.TextCtrl(self, -1, '1e-8')
 
         sizer3.Add(self.tRegLambda, 1, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
@@ -356,7 +356,7 @@
 
             psf = psf[:,:,numpy.floor(dz/2):(psf.shape[2]-numpy.ceil(dz/2))]
             
-        print psf.shape, self.sourceImage.data.shape
+        print(psf.shape, self.sourceImage.data.shape)
             
         self.dw.psf_calc(psf, self.sourceImage.data.shape)
         
--- ./PYME/DSView/modules/filtering.py	(original)
+++ ./PYME/DSView/modules/filtering.py	(refactored)
@@ -281,7 +281,7 @@
                 
     def OnSetLabels(self, event):
         from PYME.DSView import image
-        names = image.openImages.keys()
+        names = list(image.openImages.keys())
         
         dlg = wx.SingleChoiceDialog(self.dsviewer, 'Select an image', 'Set Labels', names)
         
--- ./PYME/DSView/modules/graphViewPanel.py	(original)
+++ ./PYME/DSView/modules/graphViewPanel.py	(refactored)
@@ -143,7 +143,7 @@
             try:
                 self.canvas.print_figure(
                     os.path.join(dirname, filename), format=format)
-            except Exception, e:
+            except Exception as e:
                 #print str(e)
                 error_msg_wx(str(e))
 
--- ./PYME/DSView/modules/manualSegment.py	(original)
+++ ./PYME/DSView/modules/manualSegment.py	(refactored)
@@ -100,7 +100,7 @@
         
     def FillSelection(self, event=None):
         if self.mask == None:
-            print 'Create a mask first'
+            print('Create a mask first')
             return
         
 #        import Image, ImageDraw
--- ./PYME/DSView/modules/profileFitting.py	(original)
+++ ./PYME/DSView/modules/profileFitting.py	(refactored)
@@ -81,7 +81,7 @@
             pylab.plot(xv, I, cols[chan] + 'x', label=self.image.names[chan])
             pylab.plot(xv, gmod(res[0], self.image.xvals), cols[chan], label='%2.3g, %2.3g, \n%2.3g, %2.3g' % tuple(res[0]))
             
-            print res[0]
+            print(res[0])
             #imo = self.image.parent
         pylab.legend()
         #rawIntensity.processIntensityTrace(I, imo.mdh, dt=imo.mdh['Camera.CycleTime'])
@@ -136,7 +136,7 @@
         plot(ti, Ii)
         
         n100 = abs(ti-100).argmin()
-        print n100, Ii[n100]
+        print(n100, Ii[n100])
         figtext(.5, .8, 'I100/Imax = %3.4f'%(Ii[n100]))
         plot(ti[n100], Ii[n100], 'xr')
         
--- ./PYME/DSView/modules/profilePlotting.py	(original)
+++ ./PYME/DSView/modules/profilePlotting.py	(refactored)
@@ -95,7 +95,7 @@
             d__x = abs(d_x) + 1
             d__y = abs(d_y) + 1
 
-            print dx, dy, d__x, d__y, w
+            print(dx, dy, d__x, d__y, w)
 
             if(self.do.slice == self.do.SLICE_XY):
                 ims = self.image.data[(min(lx, hx) - d__x):(max(lx,hx)+d__x+1), (min(ly, hy)-d__y):(max(ly,hy)+d__y+1), self.do.zp, chanNum].squeeze()
@@ -108,7 +108,7 @@
             x_c = t*dx + lx - x_0
             y_c = t*dy + ly - y_0
 
-            print splf.shape
+            print(splf.shape)
 
 
             for i in range(-w, w+1):
--- ./PYME/DSView/modules/psfExtraction.py	(original)
+++ ./PYME/DSView/modules/psfExtraction.py	(refactored)
@@ -201,7 +201,7 @@
             
             dz = z1 - z0
 
-            print 'z0: %f, z1: %f, dz: %f' % (z0,z1,dz)
+            print('z0: %f, z1: %f, dz: %f' % (z0,z1,dz))
             
             pylab.plot(z_, p_0)
             pylab.plot(z_, p_1)
--- ./PYME/DSView/modules/psfTools.py	(original)
+++ ./PYME/DSView/modules/psfTools.py	(refactored)
@@ -33,7 +33,7 @@
     from traitsui.api import View, Item
     from traitsui.menu import OKButton
 
-from graphViewPanel import *
+from .graphViewPanel import *
 from PYME.PSFEst import psfQuality
 
 def remove_newlines(s):
@@ -150,7 +150,7 @@
         #self.draw()
         
     def OnChangeBackground(self, event):
-        print 'b'
+        print('b')
         self.background = float(self.tBackground.GetValue())
         self.calcCRB()
         
@@ -317,7 +317,7 @@
         z_ = np.arange(d.shape[2])*self.image.mdh['voxelsize.z']*1.0e3
         z_ = z_ - z_.mean()
         
-        print 'p'
+        print('p')
         pylab.figure()
         pylab.plot(z_, np.sqrt(crb[:,0]), label='x')
         pylab.plot(z_, np.sqrt(crb[:,1]), label='y')
--- ./PYME/DSView/modules/pupilTools.py	(original)
+++ ./PYME/DSView/modules/pupilTools.py	(refactored)
@@ -40,7 +40,7 @@
         xm = np.where(mag.max(1) > 0)[0]
         ym = np.where(mag.max(0) > 0)[0]
         
-        print xm, ym, mag.shape
+        print(xm, ym, mag.shape)
 
         mag = mag[xm[0]:(xm[-1]+1), ym[0]:(ym[-1]+1)]        
         phase = phase[xm[0]:(xm[-1]+1), ym[0]:(ym[-1]+1)]
@@ -66,7 +66,7 @@
         self.gZern.SetColLabelValue(1, "Coefficient")
         self.gZern.SetColLabelValue(2, "Residual")
         
-        for i, c, r, in zip(xrange(len(coeffs)), coeffs, res):
+        for i, c, r, in zip(range(len(coeffs)), coeffs, res):
             self.gZern.SetRowLabelValue(i, '%d' %i)
             self.gZern.SetCellValue(i, 0, zernike.NameByNumber[i])
             self.gZern.SetCellValue(i, 1, '%3.3g' % c)
--- ./PYME/DSView/modules/pupilView.py	(original)
+++ ./PYME/DSView/modules/pupilView.py	(refactored)
@@ -143,7 +143,7 @@
             try:
                 self.canvas.print_figure(
                     os.path.join(dirname, filename), format=format)
-            except Exception, e:
+            except Exception as e:
                 #print str(e)
                 error_msg_wx(str(e))
 
--- ./PYME/DSView/modules/synchronise.py	(original)
+++ ./PYME/DSView/modules/synchronise.py	(refactored)
@@ -55,7 +55,7 @@
     def OnSynchronise(self, event):
         dlg = wx.SingleChoiceDialog(
                 self.dsviewer, 'choose the image to composite with', 'Make Composite',
-                dsviewer_npy_nb.openViewers.keys(),
+                list(dsviewer_npy_nb.openViewers.keys()),
                 wx.CHOICEDLG_STYLE
                 )
 
--- ./PYME/DSView/modules/visgui.py	(original)
+++ ./PYME/DSView/modules/visgui.py	(refactored)
@@ -73,7 +73,7 @@
     if not 'ivps' in dir(dsviewer):
         dsviewer.ivps = []
 
-    for name, i in zip(dsviewer.image.names, xrange(dsviewer.image.data.shape[3])):
+    for name, i in zip(dsviewer.image.names, range(dsviewer.image.data.shape[3])):
         dsviewer.ivps.append(ImageViewPanel(dsviewer, dsviewer.image, dsviewer.glCanvas, dsviewer.do, chan=i))
         if dsviewer.image.data.shape[3] > 1 and len(cmaps) > 0:
             dsviewer.do.cmaps[i] = cmaps.pop(0)
--- ./PYME/DSView/modules/measure/filterPan.py	(original)
+++ ./PYME/DSView/modules/measure/filterPan.py	(refactored)
@@ -50,8 +50,8 @@
         self.lFiltKeys.InsertColumn(1, 'Min')
         self.lFiltKeys.InsertColumn(2, 'Max')
 
-        for key, value in self.filterKeys.items():
-            ind = self.lFiltKeys.InsertStringItem(sys.maxint, key)
+        for key, value in list(self.filterKeys.items()):
+            ind = self.lFiltKeys.InsertStringItem(sys.maxsize, key)
             self.lFiltKeys.SetStringItem(ind,1, '%3.2f' % value[0])
             self.lFiltKeys.SetStringItem(ind,2, '%3.2f' % value[1])
 
@@ -135,14 +135,14 @@
         event.Skip()
 
     def OnFilterClipToSelection(self, event):
-        if 'x' in self.filterKeys.keys() or 'y' in self.filterKeys.keys():
-            if 'x' in self.filterKeys.keys():
+        if 'x' in list(self.filterKeys.keys()) or 'y' in list(self.filterKeys.keys()):
+            if 'x' in list(self.filterKeys.keys()):
                 i = 0
                 while not self.lFiltKeys.GetItemText(i) == 'x':
                     i +=1
                 self.lFiltKeys.DeleteItem(i)
                 self.filterKeys.pop('x')
-            if 'y' in self.filterKeys.keys():
+            if 'y' in list(self.filterKeys.keys()):
                 i = 0
                 while not self.lFiltKeys.GetItemText(i) == 'y':
                     i +=1
@@ -154,13 +154,13 @@
             x0, y0 = self.visFr.glCanvas.selectionStart
             x1, y1 = self.visFr.glCanvas.selectionFinish
 
-            if not 'x' in self.filterKeys.keys():
-                indx = self.lFiltKeys.InsertStringItem(sys.maxint, 'x')
+            if not 'x' in list(self.filterKeys.keys()):
+                indx = self.lFiltKeys.InsertStringItem(sys.maxsize, 'x')
             else:
                 indx = [self.lFiltKeys.GetItemText(i) for i in range(self.lFiltKeys.GetItemCount())].index('x')
 
-            if not 'y' in self.filterKeys.keys():
-                indy = self.lFiltKeys.InsertStringItem(sys.maxint, 'y')
+            if not 'y' in list(self.filterKeys.keys()):
+                indy = self.lFiltKeys.InsertStringItem(sys.maxsize, 'y')
             else:
                 indy = [self.lFiltKeys.GetItemText(i) for i in range(self.lFiltKeys.GetItemCount())].index('y')
 
@@ -183,7 +183,7 @@
 
         possibleKeys = []
         if not self.pipeline.selectedDataSource == None:
-            possibleKeys = self.pipeline.selectedDataSource.keys()
+            possibleKeys = list(self.pipeline.selectedDataSource.keys())
 
         dlg = editFilterDialog.FilterEditDialog(self, mode='new', possibleKeys=possibleKeys)
 
@@ -200,7 +200,7 @@
 
             self.filterKeys[key] = (minVal, maxVal)
 
-            ind = self.lFiltKeys.InsertStringItem(sys.maxint, key)
+            ind = self.lFiltKeys.InsertStringItem(sys.maxsize, key)
             self.lFiltKeys.SetStringItem(ind,1, '%3.2f' % minVal)
             self.lFiltKeys.SetStringItem(ind,2, '%3.2f' % maxVal)
 
--- ./PYME/Deconv/block_dec.py	(original)
+++ ./PYME/Deconv/block_dec.py	(refactored)
@@ -22,8 +22,8 @@
 ##################
 
 #f = f3
-import tcluster
-import dec
+from . import tcluster
+from . import dec
 from scipy import *
 class blocking_deconv:
     def __init__(self, nodes, data, psf, alpha, blocksize = {'x':64, 'y':64, 'z':256}, blockoverlap = {'x':10, 'y':10, 'z':50}):        
@@ -43,7 +43,7 @@
         if (self.width > self.blocksize['y']):
             #self.sp_y = [0,]
             #print self.sp_y
-            self.sp_y = range(0,(self.width-self.blocksize['y']), (self.blocksize['y'] -2*self.blockoverlap['y']))
+            self.sp_y = list(range(0,(self.width-self.blocksize['y']), (self.blocksize['y'] -2*self.blockoverlap['y'])))
             #self.sp_y.extend(range((self.blocksize['y'] -2*self.blockoverlap['y']),(self.width-self.blocksize['y']), self.blocksize['y']))
             #print self.sp_y
             self.sp_y.append(self.width-self.blocksize['y'])
@@ -53,7 +53,7 @@
             
         if (self.height > self.blocksize['x']):
             #self.sp_x = [0,]
-            self.sp_x = range(0,(self.height-self.blocksize['x']), (self.blocksize['x'] -2*self.blockoverlap['x']))
+            self.sp_x = list(range(0,(self.height-self.blocksize['x']), (self.blocksize['x'] -2*self.blockoverlap['x'])))
             #self.sp_x.extend(range((self.blocksize['x'] -2*self.blockoverlap['x']),(self.width-self.blocksize['x']), self.blocksize['x']))
             self.sp_x.append(self.height-self.blocksize['x'])
         else:
@@ -62,7 +62,7 @@
             
         if (self.depth > self.blocksize['z']):
             #self.sp_z = [0,]
-            self.sp_z = range(0,(self.depth-self.blocksize['z']), (self.blocksize['z'] -2*self.blockoverlap['z']))
+            self.sp_z = list(range(0,(self.depth-self.blocksize['z']), (self.blocksize['z'] -2*self.blockoverlap['z'])))
             #self.sp_z.extend(range((self.blocksize['z'] -2*self.blockoverlap['z']),(self.width-self.blocksize['z']), self.blocksize['z']))
             self.sp_z.append(self.depth-self.blocksize['z'])
         else:
@@ -178,37 +178,37 @@
 		    self.blockno[(sl_start_a + sel_x1):(sl_start_a + sel_x2),(sl_start_b + sel_y1):(sl_start_b + sel_y2), (sl_start + sel_z1):(sl_start + sel_z2)] = cast['f'](real(block_n[sel_x1:sel_x2,sel_y1:sel_y2, sel_z1:sel_z2]))
                     
     def go(self, kz = 1, lamb = 2e-2, num_iters = 10):
-        print 'Dividing into blocks ...'
+        print('Dividing into blocks ...')
         self.blockify()
-        print 'Doing some PSF related precomutations ...'
+        print('Doing some PSF related precomutations ...')
         self.init_psf(kz)
-        print 'Sending precomputed info to cluster ...'
+        print('Sending precomputed info to cluster ...')
         self.init_cluster()
-        print 'Starting the deconvolution ....'
+        print('Starting the deconvolution ....')
         self.do_deconv(lamb, num_iters)
         self.cleanup_cluster()
-        print 'Finished deconvolution, putting blocks back together ...'
+        print('Finished deconvolution, putting blocks back together ...')
         self.deblock()
     
     def sim(self, kz = 1):
-        print 'Dividing into blocks ...'
+        print('Dividing into blocks ...')
         self.blockify()
-        print 'Doing some PSF related precomutations ...'
+        print('Doing some PSF related precomutations ...')
         self.init_psf(kz)
-        print 'Sending precomputed info to cluster ...'
+        print('Sending precomputed info to cluster ...')
         self.init_cluster()
-        print 'Starting the simulation ....'
+        print('Starting the simulation ....')
         self.do_sim()
         self.cleanup_cluster()
-        print 'Finished simulation, putting blocks back together ...'
+        print('Finished simulation, putting blocks back together ...')
         self.deblock()
             
 if __name__ == '__main__':
     import sys
     import os
     from optparse import OptionParser
-    import read_kdf
-    import write_kdf
+    from . import read_kdf
+    from . import write_kdf
     import time
 
     parser = OptionParser()
@@ -225,16 +225,16 @@
     (options, args) = parser.parse_args()
     
     if options.data == None:
-        print 'Must give a file containing the data'
+        print('Must give a file containing the data')
         sys.exit(1)
     if options.psf == None:
-        print 'Must give a file containing the psf'
+        print('Must give a file containing the psf')
         sys.exit(1)
     if options.out == None:
-        print 'Must give an output file'
+        print('Must give an output file')
         sys.exit(1)
     if options.kz == None:
-        print 'Must give the wavelength parameter'
+        print('Must give the wavelength parameter')
         sys.exit(1)
         
     data = squeeze(read_kdf.ReadKdfData(options.data))
@@ -245,9 +245,9 @@
     else:
         alpha = zeros(shape(data), 'f')
         
-    print shape(data)
-    print shape(alpha)
-    print(shape(psf))
+    print(shape(data))
+    print(shape(alpha))
+    print((shape(psf)))
     
     servers = []    
     if not options.servers == None:
@@ -256,7 +256,7 @@
             (host,port)=s.split(':')
             servers.append((host, int(port)))
     else:
-        print 'Creating a server on local machine'
+        print('Creating a server on local machine')
         #fid
         os.spawnl(os.P_NOWAIT, '/usr/bin/python', 'python', '/usr/lib/python/site-packages/scipy/cow/sync_cluster.py', 'server', '10001')
 	#os.spawnl(os.P_NOWAIT, '/usr/bin/python', 'python', '/usr/lib/python/site-packages/scipy/cow/sync_cluster.py', 'server', '10002')
--- ./PYME/Deconv/dec.py	(original)
+++ ./PYME/Deconv/dec.py	(refactored)
@@ -26,7 +26,7 @@
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 from scipy import ndimage
 import fftw3f
-import fftwWisdom
+from . import fftwWisdom
 
 fftwWisdom.load_wisdom()
 #import weave
@@ -34,7 +34,7 @@
 #from PYME import pad
 import numpy
 
-from wiener import resizePSF
+from .wiener import resizePSF
 
 class dec:
     '''Base deconvolution class, implementing a variant of the ICTM algorithm.
@@ -179,7 +179,7 @@
             test = 1 - abs(dot(S[:,0], S[:,1])/(norm(S[:,0])*norm(S[:,1])))
 
             #print & log some statistics
-            print 'Test Statistic %f' % (test,)
+            print('Test Statistic %f' % (test,))
             self.tests.append(test)
             self.ress.append(norm(self.res))
             self.prefs.append(norm(pref))
--- ./PYME/Deconv/decTask.py	(original)
+++ ./PYME/Deconv/decTask.py	(refactored)
@@ -57,7 +57,7 @@
             decObj.prep()
             queueID = self.queueName
 
-        print self.blocknum, self.lamb
+        print(self.blocknum, self.lamb)
 
         res = decObj.deconv(self.block, self.lamb, self.num_iters)
         return decResult(self, res, queueID)
--- ./PYME/Deconv/decThread.py	(original)
+++ ./PYME/Deconv/decThread.py	(refactored)
@@ -64,7 +64,7 @@
             return self._thread_id
 
         # no, look for it in the _active dict
-        for tid, tobj in threading._active.items():
+        for tid, tobj in list(threading._active.items()):
             if tobj is self:
                 self._thread_id = tid
                 return tid
--- ./PYME/Deconv/dec_test.py	(original)
+++ ./PYME/Deconv/dec_test.py	(refactored)
@@ -24,7 +24,7 @@
 __test__= False
 
 if __name__ == '__main__':
-    import dec
+    from . import dec
     from scipy import *
     import profile
     (x,y,z) = mgrid[-32:31,-32:31,-128:127]
--- ./PYME/Deconv/deccs.py	(original)
+++ ./PYME/Deconv/deccs.py	(refactored)
@@ -26,7 +26,7 @@
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 from scipy import ndimage
 import fftw3f
-import fftwWisdom
+from . import fftwWisdom
 
 fftwWisdom.load_wisdom()
 #import weave
@@ -36,7 +36,7 @@
 
 from pylab import *
 
-from wiener import resizePSF
+from .wiener import resizePSF
 
 show_plots = False
 from PYME.DSView import View3D
@@ -215,7 +215,7 @@
             test = 1 - abs(dot(S[:,0], S[:,1])/(norm(S[:,0])*norm(S[:,1])))
 
             #print & log some statistics
-            print 'Test Statistic %f' % (test,)
+            print('Test Statistic %f' % (test,))
             self.tests.append(test)
             self.ress.append(norm(self.res))
             self.prefs.append(norm(pref))
@@ -253,7 +253,7 @@
                 plot(self.f)
                 plot(fn)
                 plot(fn1)
-                raw_input()
+                input()
             
             #v.view.Redraw()
             #raw_input()
--- ./PYME/Deconv/deccs2.py	(original)
+++ ./PYME/Deconv/deccs2.py	(refactored)
@@ -26,7 +26,7 @@
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 from scipy import ndimage
 import fftw3f
-import fftwWisdom
+from . import fftwWisdom
 
 fftwWisdom.load_wisdom()
 #import weave
@@ -37,7 +37,7 @@
 
 from pylab import *
 
-from wiener import resizePSF
+from .wiener import resizePSF
 
 show_plots = False
 from PYME.DSView import View3D
@@ -272,7 +272,7 @@
                     plot(self.estimateMask)
                     #plot(fn)
                     #plot(fn1)
-                    raw_input()
+                    input()
             #remove zero entries from the estimate mask
             discard = self.estimateMask*(self.f <= 0)
             if np.any(discard):
@@ -282,7 +282,7 @@
                     self.x.remove(xi)
                     self.y.remove(yi)
                     self.z.remove(zi)
-            print self.loopcount
+            print(self.loopcount)
             
             #v.view.Redraw()
             #raw_input()
@@ -520,7 +520,7 @@
         for xi, yi, zi in zip(self.x,self.y,self.z):
             key = (xi, yi, zi)
             
-            if key in self.ACache.keys():
+            if key in list(self.ACache.keys()):
                 A, x0, x1, y0, y1 = self.ACache[key]
             else: 
                 xif = int(xi/ss)
@@ -554,7 +554,7 @@
         for xi, yi, zi in zip(self.x,self.y,self.z):
             key = (xi, yi, zi)
             
-            if key in self.AhCache.keys():
+            if key in list(self.AhCache.keys()):
                 A, x0, x1, y0, y1 = self.AhCache[key]
             else: 
                 xif = int(xi/ss)
--- ./PYME/Deconv/deccs_mc.py	(original)
+++ ./PYME/Deconv/deccs_mc.py	(refactored)
@@ -26,7 +26,7 @@
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 from scipy import ndimage
 import fftw3f
-import fftwWisdom
+from . import fftwWisdom
 
 fftwWisdom.load_wisdom()
 #import weave
@@ -36,7 +36,7 @@
 
 from pylab import *
 
-from wiener import resizePSF
+from .wiener import resizePSF
 
 show_plots = False
 from PYME.DSView import View3D
@@ -217,7 +217,7 @@
             test = 1 - abs(dot(S[:,0], S[:,1])/(norm(S[:,0])*norm(S[:,1])))
 
             #print & log some statistics
-            print 'Test Statistic %f' % (test,)
+            print('Test Statistic %f' % (test,))
             self.tests.append(test)
             self.ress.append(norm(self.res))
             self.prefs.append(norm(pref))
@@ -256,7 +256,7 @@
                 plot(self.f)
                 plot(fn)
                 plot(fn1)
-                raw_input()
+                input()
             
             #v.view.Redraw()
             #raw_input()
--- ./PYME/Deconv/deconvDialogs.py	(original)
+++ ./PYME/Deconv/deconvDialogs.py	(refactored)
@@ -40,7 +40,7 @@
 
         sizer2 = wx.BoxSizer(wx.VERTICAL)
         
-        print 'nchans:', nChans
+        print('nchans:', nChans)
         
         if nChans > 1:
             sizer3 = wx.BoxSizer(wx.HORIZONTAL)
@@ -91,7 +91,7 @@
         sizer2.Add(sizer3, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL | wx.ALL, 0)
 
         sizer3 = wx.BoxSizer(wx.HORIZONTAL)
-        sizer3.Add(wx.StaticText(pan1, -1, u'Regularisation \u03BB:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
+        sizer3.Add(wx.StaticText(pan1, -1, 'Regularisation \u03BB:'), 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
         self.tRegLambda = wx.TextCtrl(pan1, -1, '1e-1')
 
         sizer3.Add(self.tRegLambda, 1, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
--- ./PYME/Deconv/read_kdf.py	(original)
+++ ./PYME/Deconv/read_kdf.py	(refactored)
@@ -103,7 +103,7 @@
           DimZ = SegDims[2]
           DimE = SegDims[4]
           TypeString = SegType
-          print TypeString
+          print(TypeString)
           
         
         #continue;
--- ./PYME/Deconv/richardsonLucy.py	(original)
+++ ./PYME/Deconv/richardsonLucy.py	(refactored)
@@ -26,9 +26,9 @@
 import numpy
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 import fftw3f
-import fftwWisdom
-
-from wiener import resizePSF
+from . import fftwWisdom
+
+from .wiener import resizePSF
 
 fftwWisdom.load_wisdom()
 #import weave
@@ -107,7 +107,7 @@
 
             #set the current estimate to out new estimate
             self.f[:] = fnew
-            print 'Sum = %f' % self.f.sum()
+            print('Sum = %f' % self.f.sum())
 
         return real(self.fs)
 
@@ -319,7 +319,7 @@
 
         self.shape = data_size
         
-        print 'Calculating OTF' 
+        print('Calculating OTF') 
 
         FTshape = [self.shape[0], self.shape[1], self.shape[2]/2 + 1]
 
@@ -344,7 +344,7 @@
         self.Ht /= g.size;
         self.H /= g.size;
         
-        print 'Creating plans for FFTs - this might take a while'
+        print('Creating plans for FFTs - this might take a while')
 
         #calculate plans for other ffts
         self._plan_r_F = fftw3f.Plan(self._r, self._F, 'forward', flags = FFTWFLAGS, nthreads=NTHREADS)
@@ -352,7 +352,7 @@
         
         fftwWisdom.save_wisdom()
         
-        print 'Done planning'
+        print('Done planning')
 
 
     def Lfunc(self, f):
--- ./PYME/Deconv/tcluster.py	(original)
+++ ./PYME/Deconv/tcluster.py	(refactored)
@@ -24,7 +24,7 @@
 import threading
 import scipy.cow
 import scipy.cow.sync_cluster
-import Queue 
+import queue 
 import time
 
 class tTask:
@@ -75,7 +75,7 @@
         #addendums = []
         results = {}
         
-        taskQueue = Queue.Queue()
+        taskQueue = queue.Queue()
         
         tThreads = []
         Tasks = []
@@ -125,11 +125,11 @@
 class tMachine(scipy.cow.sync_cluster.standard_sync_client):
     def executeTask(self, task):
         start_time = time.time()
-        print 'Starting task: %s on host: %s:%s' % (task.name, self.host, self.port)
+        print('Starting task: %s on host: %s:%s' % (task.name, self.host, self.port))
         self.send(task.package, task.addendum)
         ret = self.recv()
         end_time = time.time()
-        print 'Task: %s completed on host: %s:%s, Elapsed time: %s seconds' % (task.name, self.host, self.port, end_time - start_time)
+        print('Task: %s completed on host: %s:%s, Elapsed time: %s seconds' % (task.name, self.host, self.port, end_time - start_time))
         return ret
     
     def is_running(self):
@@ -154,19 +154,19 @@
         while len(self.results) < self.num_tasks:
            try: 
                 self.task = self.task_queue.get_nowait()
-                print '%s tasks remaining ' % (self.task_queue.qsize() + 1,) 
+                print('%s tasks remaining ' % (self.task_queue.qsize() + 1,)) 
                 #if there are no items left then the exception thrown
                 #should get us out of the while loop
                 try:
                     res = self.machine.executeTask(self.task)
                     self.results[self.task.name] = res
-                except Exception, ex: # if something went wrong put task back
+                except Exception as ex: # if something went wrong put task back
                     #pass
                     self.task_queue.put(self.task)
                     self.task = None
                     raise ex
                 
-           except Queue.Empty:
+           except queue.Empty:
                 time.sleep(1)
                 #pass
         #except Timeout:
--- ./PYME/Deconv/tq_block_dec.py	(original)
+++ ./PYME/Deconv/tq_block_dec.py	(refactored)
@@ -23,9 +23,9 @@
 
 #f = f3
 #import tcluster
-import dec
+from . import dec
 from scipy import *
-import decTask #import decTask
+from . import decTask #import decTask
 
 
 
@@ -51,7 +51,7 @@
         if (self.width > self.blocksize['y']):
             #self.sp_y = [0,]
             #print self.sp_y
-            self.sp_y = range(0,(self.width-self.blocksize['y']), (self.blocksize['y'] -2*self.blockoverlap['y']))
+            self.sp_y = list(range(0,(self.width-self.blocksize['y']), (self.blocksize['y'] -2*self.blockoverlap['y'])))
             #self.sp_y.extend(range((self.blocksize['y'] -2*self.blockoverlap['y']),(self.width-self.blocksize['y']), self.blocksize['y']))
             #print self.sp_y
             self.sp_y.append(self.width-self.blocksize['y'])
@@ -61,7 +61,7 @@
             
         if (self.height > self.blocksize['x']):
             #self.sp_x = [0,]
-            self.sp_x = range(0,(self.height-self.blocksize['x']), (self.blocksize['x'] -2*self.blockoverlap['x']))
+            self.sp_x = list(range(0,(self.height-self.blocksize['x']), (self.blocksize['x'] -2*self.blockoverlap['x'])))
             #self.sp_x.extend(range((self.blocksize['x'] -2*self.blockoverlap['x']),(self.width-self.blocksize['x']), self.blocksize['x']))
             self.sp_x.append(self.height-self.blocksize['x'])
         else:
@@ -70,7 +70,7 @@
             
         if (self.depth > self.blocksize['z']):
             #self.sp_z = [0,]
-            self.sp_z = range(0,(self.depth-self.blocksize['z']), (self.blocksize['z'] -2*self.blockoverlap['z']))
+            self.sp_z = list(range(0,(self.depth-self.blocksize['z']), (self.blocksize['z'] -2*self.blockoverlap['z'])))
             #self.sp_z.extend(range((self.blocksize['z'] -2*self.blockoverlap['z']),(self.width-self.blocksize['z']), self.blocksize['z']))
             self.sp_z.append(self.depth-self.blocksize['z'])
         else:
@@ -118,7 +118,7 @@
         self.tq.removeQueue(self.name)
         
     def push_deconv_tasks(self, lamb = 2e-2, num_iters = 10):
-        for block, blocknum in zip(self.blocks, range(len(self.blocks))):
+        for block, blocknum in zip(self.blocks, list(range(len(self.blocks)))):
             task = decTask.decTask(self.name, block[0], blocknum, lamb=lamb, num_iters=num_iters)
             self.tq.postTask(task, self.name)
         #self.results = self.tc.loop_code('f = d4.deconv(ravel(a[0]), lamb, alpha=a[1], num_iters=num_it)', 'a', {'a':self.blocks, 'lamb':lamb, 'num_it':num_iters}, ('f',))
@@ -132,7 +132,7 @@
         #decTask.decObj = self.d4
         #decTask.queueID = self.name
 
-        for block, blocknum in zip(self.blocks, range(len(self.blocks))):
+        for block, blocknum in zip(self.blocks, list(range(len(self.blocks)))):
             task = decTask.decTask(self.name, block[0], blocknum, lamb=lamb, num_iters=num_iters)
             t = task(taskQueue=self.tq)
             self.results[t.blocknum] = t.results
@@ -206,13 +206,13 @@
 		    self.blockno[(sl_start_a + sel_x1):(sl_start_a + sel_x2),(sl_start_b + sel_y1):(sl_start_b + sel_y2), (sl_start + sel_z1):(sl_start + sel_z2)] = cast['f'](real(block_n[sel_x1:sel_x2,sel_y1:sel_y2, sel_z1:sel_z2]))
                     
     def go(self, kz = 1, lamb = 2e-2, num_iters = 10):
-        print 'Dividing into blocks ...'
+        print('Dividing into blocks ...')
         self.blockify()
-        print 'Doing some PSF related precomutations ...'
+        print('Doing some PSF related precomutations ...')
         self.init_psf(kz)
-        print 'Sending precomputed info to cluster ...'
+        print('Sending precomputed info to cluster ...')
         self.init_cluster()
-        print 'Starting the deconvolution ....'
+        print('Starting the deconvolution ....')
         #self.push_deconv_tasks(lamb, num_iters)
 
     def retrieve(self):
--- ./PYME/Deconv/wiener.py	(original)
+++ ./PYME/Deconv/wiener.py	(refactored)
@@ -27,7 +27,7 @@
 from scipy.fftpack import fftn, ifftn, fftshift, ifftshift
 import scipy
 import fftw3f
-import fftwWisdom
+from . import fftwWisdom
 
 fftwWisdom.load_wisdom()
 
@@ -44,7 +44,7 @@
 def resizePSF(psf, data_size):
     if not psf.shape == data_size:
         #Expand PSF to data size by fourier domain interpolation
-        print 'Resizing PSF to match data size'
+        print('Resizing PSF to match data size')
         g_ = fftw3f.create_aligned_array(data_size, 'complex64')
         H_ = fftw3f.create_aligned_array(data_size, 'complex64')
         
@@ -60,7 +60,7 @@
         
         g =  ifftshift(g_.real)
     
-        print 'PSF resizing complete'
+        print('PSF resizing complete')
     else:
         g = psf
     #View3D(psf)
--- ./PYME/Deconv/write_kdf.py	(original)
+++ ./PYME/Deconv/write_kdf.py	(refactored)
@@ -138,7 +138,7 @@
         TypeString = 'Unsigned Short'
     else:
         fid.close()
-        print 'Dont know about %ss ... fixme' % (d.typecode(),)
+        print('Dont know about %ss ... fixme' % (d.typecode(),))
         error()
     
     
--- ./PYME/FileUtils/KdfSeqToHdf5.py	(original)
+++ ./PYME/FileUtils/KdfSeqToHdf5.py	(refactored)
@@ -23,7 +23,7 @@
 
 #!/usr/bin/python
 
-import read_kdf
+from . import read_kdf
 import tables
 import os
 import sys
--- ./PYME/FileUtils/KdfStackToHdf5.py	(original)
+++ ./PYME/FileUtils/KdfStackToHdf5.py	(refactored)
@@ -23,7 +23,7 @@
 
 #!/usr/bin/python
 
-import read_kdf
+from . import read_kdf
 import tables
 import os
 import sys
--- ./PYME/FileUtils/RawToHdf5.py	(original)
+++ ./PYME/FileUtils/RawToHdf5.py	(refactored)
@@ -23,7 +23,7 @@
 
 #!/usr/bin/python
 
-import read_kdf
+from . import read_kdf
 import tables
 import os
 import sys
@@ -68,7 +68,7 @@
             d1 = numpy.fromfile(f1, '>u2', xSize*ySize) >> 4
             imageData.append(d1.reshape(1, xSize, ySize))
             if i % 100 == 0:
-                print '%d of %d frames' % (i, nFrames)
+                print('%d of %d frames' % (i, nFrames))
 
         f1.close()
 
--- ./PYME/FileUtils/batchConvertKdf.py	(original)
+++ ./PYME/FileUtils/batchConvertKdf.py	(refactored)
@@ -24,7 +24,7 @@
 import sys
 import os
 
-import KdfStackToHdf5
+from . import KdfStackToHdf5
 
 
 if __name__ == '__main__':
--- ./PYME/FileUtils/h5r-thumbnailer.py	(original)
+++ ./PYME/FileUtils/h5r-thumbnailer.py	(refactored)
@@ -48,7 +48,7 @@
 
     #print f1.keys()
 
-    if 'fitResults_Ag' in f1.keys():
+    if 'fitResults_Ag' in list(f1.keys()):
         #if we used the splitter set up a mapping so we can filter on total amplitude and ratio
         f1_ = inpFilt.mappingFilter(f1, A='fitResults_Ag + fitResults_Ar', gFrac='fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         #f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
@@ -56,12 +56,12 @@
     else:
         f1_ = f1
         
-    if 'fitResults_sigma' in f1.keys():
+    if 'fitResults_sigma' in list(f1.keys()):
         f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
     else:
         f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5])
 
-    if 'fitResults_z0' in f1_.keys():
+    if 'fitResults_z0' in list(f1_.keys()):
         threeD = True
 
     if 'Events' in dir(f1.h5f.root):
--- ./PYME/FileUtils/h5rToTxt.py	(original)
+++ ./PYME/FileUtils/h5rToTxt.py	(refactored)
@@ -29,7 +29,7 @@
 def convertFile(inFile, outFile):
     ds = inpFilt.h5rSource(inFile)
 
-    nRecords = len(ds[ds.keys()[0]])
+    nRecords = len(ds[list(ds.keys())[0]])
 
     of = open(outFile, 'w')
 
@@ -43,7 +43,7 @@
 
 def saveFilter(ds, outFile, keys = None):
     if keys == None:
-        keys = ds.keys()
+        keys = list(ds.keys())
 
     #nRecords = len(ds[keys[0]])
 
@@ -72,6 +72,6 @@
         outFile = os.path.splitext(inFile)[0] + '.txt'
 
     if os.path.exists(outFile):
-        print 'Output file already exists - please remove'
+        print('Output file already exists - please remove')
     else:
         convertFile(inFile, outFile)
--- ./PYME/FileUtils/kdfToFloat32Tiff.py	(original)
+++ ./PYME/FileUtils/kdfToFloat32Tiff.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import Image
-import read_kdf
+from . import read_kdf
 
 if not (len(sys.argv) == 3):
     raise RuntimeError('Usage: procStack inDir resDir')
--- ./PYME/FileUtils/kdfToImage.py	(original)
+++ ./PYME/FileUtils/kdfToImage.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import Image
-import read_kdf
+from . import read_kdf
 import sys
 
 if not (len(sys.argv) == 3):
--- ./PYME/FileUtils/nameUtils.py	(original)
+++ ./PYME/FileUtils/nameUtils.py	(refactored)
@@ -45,15 +45,15 @@
 dtn = datetime.datetime.now()
 
 homedir = os.path.expanduser('~') #unix & possibly others ...
-if 'USERPROFILE' in os.environ.keys(): #windows
+if 'USERPROFILE' in list(os.environ.keys()): #windows
     homedir = os.environ['USERPROFILE']
 
 datadir = os.path.join(homedir, 'PYMEData')
-if 'PYMEDATADIR' in os.environ.keys() and os.access(os.environ['PYMEDATADIR'], os.W_OK):
+if 'PYMEDATADIR' in list(os.environ.keys()) and os.access(os.environ['PYMEDATADIR'], os.W_OK):
     datadir = os.environ['PYMEDATADIR']
 
 dirSuffix=''
-if 'PYMEDIRSUFFIX' in os.environ.keys():
+if 'PYMEDIRSUFFIX' in list(os.environ.keys()):
     dirSuffix = '_' + os.environ['PYMEDIRSUFFIX']
 
         
--- ./PYME/FileUtils/readTiff.py	(original)
+++ ./PYME/FileUtils/readTiff.py	(refactored)
@@ -42,7 +42,7 @@
     #ima = np.array(im.getdata(), 'int16').newbyteorder('BE')
     ima = np.array(im.getdata()).newbyteorder(endedness)
 
-    print ima.dtype
+    print(ima.dtype)
     
     #print ima.shape
 
--- ./PYME/FileUtils/sf-thumbnailer.py	(original)
+++ ./PYME/FileUtils/sf-thumbnailer.py	(refactored)
@@ -30,7 +30,7 @@
 import sys
 import gnomevfs
 
-import cPickle
+import pickle
 
 import matplotlib
 matplotlib.use('Agg')
@@ -50,7 +50,7 @@
 
 #def generateThumbnail(inputFile, thumbsize):
 fid = open(inputFile)
-spx, spy = cPickle.load(fid)
+spx, spy = pickle.load(fid)
 fid.close()
 
 f = figure(figsize=(thumbSize/dpi, 0.5*thumbSize/dpi))
--- ./PYME/FileUtils/thumbnailDatabase.py	(original)
+++ ./PYME/FileUtils/thumbnailDatabase.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import sqlite3
-import cPickle as pickle
+import pickle as pickle
 import os
 import zlib
 from numpy import ndarray
@@ -73,7 +73,7 @@
     if ret == None:
         ext = os.path.splitext(filename)[-1]
 
-        if ext in thumbnailers.keys():
+        if ext in list(thumbnailers.keys()):
             #print ext
             #try:
             #thumbMod = __import__(thumbnailers[ext])
--- ./PYME/FileUtils/write_kdf.py	(original)
+++ ./PYME/FileUtils/write_kdf.py	(refactored)
@@ -171,7 +171,7 @@
         TypeString = 'Unsigned Short'
     else:
         fid.close()
-        print 'Dont know about %ss ... fixme' % (d.dtype,)
+        print('Dont know about %ss ... fixme' % (d.dtype,))
         error()
     
     
--- ./PYME/PSFEst/dec.py	(original)
+++ ./PYME/PSFEst/dec.py	(refactored)
@@ -97,7 +97,7 @@
 
             test = 1 - abs(dot(S[:,0], S[:,1])/(norm(S[:,0])*norm(S[:,1])))
 
-            print 'Test Statistic %f\n' % (test,)
+            print('Test Statistic %f\n' % (test,))
 
             (fnew, cpred, spred) = self.subsearch(f, res, fdef, self.Afunc, self.Lfunc, lamb, S[:, 0:nsrch])
 
--- ./PYME/PSFEst/extractImages.py	(original)
+++ ./PYME/PSFEst/extractImages.py	(refactored)
@@ -90,7 +90,7 @@
     
 
     d = zeros((height, width, len(zvals)))
-    print d.shape
+    print(d.shape)
 
     for i in range(len(points)):
         F = fftn(ims[:,:,i])
@@ -144,15 +144,15 @@
 
 
     d = zeros((height, width, depth))
-    print d.shape
+    print(d.shape)
 
     for px,py,pz in points:
-        print px, py, pz
+        print(px, py, pz)
         px = int(px)
         py = int(py)
         pz = int(pz)
         imi = im[(px-sx):(px+sx+1),(py-sy):(py+sy+1),(pz-sz):(pz+sz+1)]
-        print imi.shape
+        print(imi.shape)
         dx, dy, dz = getIntCenter(imi)
         dz -= sz
         F = fftn(imi)
--- ./PYME/PSFEst/psfQuality.py	(original)
+++ ./PYME/PSFEst/psfQuality.py	(refactored)
@@ -164,7 +164,7 @@
     crb_3D = np.sqrt(psft.crb.sum(1))[(zf - dz):(zf + dz +1)].mean()
     crb_3D_as = np.sqrt(psft.crb_as.sum(1))[(zf - dz):(zf + dz +1)].mean()
     
-    print crb_3D, crb_3D_as
+    print(crb_3D, crb_3D_as)
     
     ratio = crb_3D/crb_3D_as
     
@@ -195,11 +195,11 @@
 
     loc_res = {}
     
-    for k, v in localisation_tests.items():
+    for k, v in list(localisation_tests.items()):
         loc_res[k] = v(image, psft)
         
     dec_res = {}
-    for k, v in deconvolution_tests.items():
+    for k, v in list(deconvolution_tests.items()):
         dec_res[k] = v(image, psft)
         
     return loc_res, dec_res
--- ./PYME/PSFGen/__init__.py	(original)
+++ ./PYME/PSFGen/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from ps_app import *
+from .ps_app import *
--- ./PYME/PSFGen/fourierHNA.py	(original)
+++ ./PYME/PSFGen/fourierHNA.py	(refactored)
@@ -57,7 +57,7 @@
         self._F = fftw3f.create_aligned_array(u.shape, 'complex64')
         self._f = fftw3f.create_aligned_array(u.shape, 'complex64')
         
-        print 'Creating plans for FFTs - this might take a while'
+        print('Creating plans for FFTs - this might take a while')
 
         #calculate plans for other ffts
         self._plan_f_F = fftw3f.Plan(self._f, self._F, 'forward', flags = FFTWFLAGS, nthreads=NTHREADS)
@@ -66,7 +66,7 @@
         
         fftwWisdom.save_wisdom()
         
-        print 'Done planning'
+        print('Done planning')
          #print isnan(self.propFac).sum()
 
     def propagate(self, F, z):
@@ -110,7 +110,7 @@
     R = sqrt(u**2 + v**2)
     
     #print R.max()*lamb
-    print (R/(n*lamb)).max()
+    print((R/(n*lamb)).max())
     
     #imshow(R*lamb)
     #colorbar()
@@ -152,7 +152,7 @@
 def PsfFromPupil(pupil, zs, dx, lamb):
     dx = float(dx)
     X, Y = meshgrid(dx*arange(-pupil.shape[0]/2, pupil.shape[0]/2),dx*arange(-pupil.shape[1]/2, pupil.shape[1]/2))
-    print X.min(), X.max()
+    print(X.min(), X.max())
     
     X = X - X.mean()
     Y = Y - Y.mean()
@@ -177,7 +177,7 @@
 def PsfFromPupilVect(pupil, zs, dx, lamb, shape = [61,61]):
     dx = float(dx)
     X, Y = meshgrid(dx*arange(-pupil.shape[0]/2, pupil.shape[0]/2),dx*arange(-pupil.shape[1]/2, pupil.shape[1]/2))
-    print X.min(), X.max()
+    print(X.min(), X.max())
     
     X = X - X.mean()
     Y = Y - Y.mean()
@@ -288,7 +288,7 @@
         bps = []
         abp = []
         
-        print i#, abs(pupil).sum()
+        print(i)#, abs(pupil).sum()
         
         #figure()
         #imshow(abs(pupil))
@@ -330,7 +330,7 @@
         #View3D(bps)
         #View3D(abp)
         
-        print 'res = %f' % (res/ps.shape[2])
+        print('res = %f' % (res/ps.shape[2]))
         #print abs(new_pupil).sum()
         
         #np_A = abs(new_pupil)
@@ -438,7 +438,7 @@
 def GenSAAstigPSF(zs, dx=5, strength=1.0, SA=0, X=None, Y=None, lamb=700, n=1.51, NA = 1.47):
     from PYME.misc import zernike
     Xk = X.ctypes.data
-    if not Xk in fps.keys():
+    if not Xk in list(fps.keys()):
         fpset = GenWidefieldAP(dx, X, Y, lamb=lamb, n=n, NA = NA)
         X, Y, R, FP, F, u, v = fpset
         r = R/R[abs(F)>0].max()
@@ -468,7 +468,7 @@
 def GenSAPRIPSF(zs, dx=5, strength=1.0, SA=0, X=None, Y=None, lamb=700, n=1.51, NA = 1.47):
     from PYME.misc import zernike
     Xk = X.ctypes.data
-    if not Xk in fps.keys():
+    if not Xk in list(fps.keys()):
         fpset = GenWidefieldAP(dx, X, Y, lamb=lamb, n=n, NA = NA)
         fps[Xk] = fpset
     else:
--- ./PYME/PSFGen/genCRBcurves.py	(original)
+++ ./PYME/PSFGen/genCRBcurves.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 from pylab import *
 
-import fourierHNA
+from . import fourierHNA
 from PYME.Analysis import cramerRao
 
 
@@ -167,7 +167,7 @@
 def genScSurface(sc, genfcn):
     crb_vs_sc = []
     for s in sc:
-        print s
+        print(s)
         ps = genfcn(zs, 70., s)
         crb_vs_sc.append(crb3DvBG(ps[13:46, 13:46, :], bgvals)[0])
         
--- ./PYME/PSFGen/nijboer_zernike.py	(original)
+++ ./PYME/PSFGen/nijboer_zernike.py	(refactored)
@@ -56,9 +56,9 @@
     
     s1 = em*np.exp(1j*f)
     
-    for l in xrange(1, lmax):
+    for l in range(1, lmax):
         t1 = 0*r
-        for j in xrange(p + 1):
+        for j in range(p + 1):
             t1 += vlj(l,j,m_a,p, q)*jn(m_a + l + 2*j, mu)/(l*mu**l)
             
         V+= ((-2j*f)**(l-1))*t1
--- ./PYME/PSFGen/test_ps_app.py	(original)
+++ ./PYME/PSFGen/test_ps_app.py	(refactored)
@@ -11,14 +11,14 @@
 
 
 import numpy as np
-import ps_app
+from . import ps_app
 
 
 def test_ps_app():
     X = np.arange(-5e3, 5e3, 70)
     P = np.arange(0, 1, .1)
     ps = ps_app.genWidefieldPSF(X, X, X, P)
-    print ps
+    print(ps)
     
 if __name__ == '__main__':
     test_ps_app()
--- ./PYME/ParallelTasks/HDFTaskQueue.py	(original)
+++ ./PYME/ParallelTasks/HDFTaskQueue.py	(refactored)
@@ -22,7 +22,7 @@
 ##################
 
 import tables
-from taskQueue import *
+from .taskQueue import *
 from PYME.Analysis.remFitBuf import fitTask
 
 from PYME.Analysis import MetaData
@@ -35,7 +35,7 @@
 import logging
 
 import time
-import Queue
+import queue
 
 from PYME.FileUtils.nameUtils import genResultFileName
 from PYME.ParallelTasks.relativeFiles import getFullFilename
@@ -87,7 +87,7 @@
         global bufferMisses
         #print self.bufferedSlices, self.insertAt, ind
         #return self.dataSource.getSlice(ind)
-        if ind in self.bufferedSlices.keys(): #return from buffer
+        if ind in list(self.bufferedSlices.keys()): #return from buffer
             #print int(numpy.where(self.bufferedSlices == ind)[0])
             return self.buffer[ind]
         else: #get from our data source and store in buffer
@@ -362,7 +362,7 @@
     def fileResult(self, res):
         #print res, res.results, res.driftResults, self.h5ResultsFile
         if res == None:
-            print 'res == None'
+            print('res == None')
             
         if res.results == [] and res.driftResults == []: #if we had a dud frame
             return
@@ -569,7 +569,7 @@
                 self.openTasks.append(self.imNum)
             self.imNum += 1
         else:
-            print "can't post new tasks"
+            print("can't post new tasks")
 			
 
     def postTasks(self,tasks):
@@ -600,7 +600,7 @@
                 
             #print len(tasks), t2 - t1, t3 - t2
         else:
-            print "can't post new tasks"
+            print("can't post new tasks")
         #print 'posting tasks not implemented yet'
 
     def getNumberOpenTasks(self, exact=True):
@@ -642,7 +642,7 @@
         taskNum = self.openTasks.pop(self.fTaskToPop(workerN, NWorkers, len(self.openTasks)))
 
         #if 'Analysis.BGRange' in self.metaData.getEntryNames():
-        bgi = range(max(taskNum + self.metaData.Analysis.BGRange[0],self.metaData.EstimatedLaserOnFrameNo), max(taskNum + self.metaData.Analysis.BGRange[1],self.metaData.EstimatedLaserOnFrameNo))
+        bgi = list(range(max(taskNum + self.metaData.Analysis.BGRange[0],self.metaData.EstimatedLaserOnFrameNo), max(taskNum + self.metaData.Analysis.BGRange[1],self.metaData.EstimatedLaserOnFrameNo)))
         #elif 'Analysis.NumBGFrames' in self.metaData.getEntryNames():
         #    bgi = range(max(taskNum - self.metaData.Analysis.NumBGFrames,self.metaData.EstimatedLaserOnFrameNo), taskNum)
         #else:
@@ -695,7 +695,7 @@
             taskNum = self.openTasks.pop(self.fTaskToPop(workerN, NWorkers, len(self.openTasks)))
 
             #if 'Analysis.BGRange' in self.metaData.getEntryNames():
-            bgi = range(max(taskNum + self.metaData.Analysis.BGRange[0],self.metaData.EstimatedLaserOnFrameNo), max(taskNum + self.metaData.Analysis.BGRange[1],self.metaData.EstimatedLaserOnFrameNo))
+            bgi = list(range(max(taskNum + self.metaData.Analysis.BGRange[0],self.metaData.EstimatedLaserOnFrameNo), max(taskNum + self.metaData.Analysis.BGRange[1],self.metaData.EstimatedLaserOnFrameNo)))
             #elif 'Analysis.NumBGFrames' in self.metaData.getEntryNames():
             #    bgi = range(max(taskNum - self.metaData.Analysis.NumBGFrames,self.metaData.EstimatedLaserOnFrameNo), taskNum)
             #else:
@@ -814,5 +814,5 @@
 
 
     def releaseTasks(self, startingAt = 0):
-        self.openTasks += range(startingAt, self.imNum)
+        self.openTasks += list(range(startingAt, self.imNum))
         self.releaseNewTasks = True
--- ./PYME/ParallelTasks/fitMon.py	(original)
+++ ./PYME/ParallelTasks/fitMon.py	(refactored)
@@ -32,10 +32,10 @@
 import time
 import os
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
-if 'PYME_TASKQUEUENAME' in os.environ.keys():
+if 'PYME_TASKQUEUENAME' in list(os.environ.keys()):
     taskQueueName = os.environ['PYME_TASKQUEUENAME']
 else:
     taskQueueName = 'taskQueue'
@@ -154,7 +154,7 @@
             nt = self.tq.getNumTasksProcessed(workers[i])
             #print nt
             self.gWorkers.SetCellValue(i, 1, '%d' % nt)
-            if workers[i] in self.workerProc.keys():
+            if workers[i] in list(self.workerProc.keys()):
                 fps =  (nt - self.workerProc[workers[i]])/dt
                 self.gWorkers.SetCellValue(i, 2, '%3.3f' % fps)
             self.workerProc[workers[i]] = nt
@@ -164,7 +164,7 @@
         nt = self.tq.getNumTasksProcessed()
         #print nt
         self.gWorkers.SetCellValue(n -1, 1, '%d' % nt)
-        if 'Total' in self.workerProc.keys():   
+        if 'Total' in list(self.workerProc.keys()):   
             self.gWorkers.SetCellValue(n - 1, 2, '%3.3f' % ((nt - int(self.workerProc['Total']))/dt,))
         self.workerProc['Total'] = nt
 
--- ./PYME/ParallelTasks/fitMonP.py	(original)
+++ ./PYME/ParallelTasks/fitMonP.py	(refactored)
@@ -35,7 +35,7 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 #if 'PYME_TASKQUEUENAME' in os.environ.keys():
@@ -163,7 +163,7 @@
             nt = self.tq.getNumTasksProcessed(workers[i])
             #print nt
             self.gWorkers.SetCellValue(i, 1, '%d' % nt)
-            if workers[i] in self.workerProc.keys():
+            if workers[i] in list(self.workerProc.keys()):
                 fps =  (nt - self.workerProc[workers[i]])/dt
                 self.gWorkers.SetCellValue(i, 2, '%3.3f' % fps)
             self.workerProc[workers[i]] = nt
@@ -175,7 +175,7 @@
         nt = self.tq.getNumTasksProcessed()
         #print nt
         self.gWorkers.SetCellValue(n -1, 1, '%d' % nt)
-        if 'Total' in self.workerProc.keys():   
+        if 'Total' in list(self.workerProc.keys()):   
             self.gWorkers.SetCellValue(n - 1, 2, '%3.3f' % ((nt - int(self.workerProc['Total']))/dt,))
         self.workerProc['Total'] = nt
 
--- ./PYME/ParallelTasks/hdfWatcher.py	(original)
+++ ./PYME/ParallelTasks/hdfWatcher.py	(refactored)
@@ -48,8 +48,8 @@
 
     if l > curpos:
         for i in range(curpos, l):
-            print i
-            tq.postTask(remFitHDF.fitTask(seriesName,i, thresh, MetaData.TIRFDefault, 'LatGaussFitF', bgindices=range(max(i-10, 0),i), SNThreshold=True), queueName=seriesName)
+            print(i)
+            tq.postTask(remFitHDF.fitTask(seriesName,i, thresh, MetaData.TIRFDefault, 'LatGaussFitF', bgindices=list(range(max(i-10, 0),i)), SNThreshold=True), queueName=seriesName)
             
     if 'EndTime' in h5file.root.MetaData._v_attrs:
         break
--- ./PYME/ParallelTasks/launchOnlyWorkers.py	(original)
+++ ./PYME/ParallelTasks/launchOnlyWorkers.py	(refactored)
@@ -52,7 +52,7 @@
     if num >= 1:
         return num
     else:
-        raise NotImplementedError, 'cannot determine number of cpus'
+        raise NotImplementedError('cannot determine number of cpus')
 
 
 #get rid of any previously started queues etc...
--- ./PYME/ParallelTasks/launchWorkers.py	(original)
+++ ./PYME/ParallelTasks/launchWorkers.py	(refactored)
@@ -53,7 +53,7 @@
     if num >= 1:
         return num
     else:
-        raise NotImplementedError, 'cannot determine number of cpus'
+        raise NotImplementedError('cannot determine number of cpus')
 
 
 #get rid of any previously started queues etc...
@@ -72,7 +72,7 @@
     try: #try and find the name server
         ns=Pyro.naming.NameServerLocator().getNS()
     except: #launch our own
-        print '''Could not find PYRO nameserver - launching a local copy:
+        print('''Could not find PYRO nameserver - launching a local copy:
             
         This should work if you are only using one computer, or if you are 
         really, really careful not to close this process before all other 
@@ -80,7 +80,7 @@
         
         I highly recommend running the pyro nameserver as a seperate process, 
         ideally on a server somewhere where it's not likely to get interrupted.
-        '''
+        ''')
         
         subprocess.Popen('pyro-ns', shell=True)
         #wait for server to come up
--- ./PYME/ParallelTasks/relativeFiles.py	(original)
+++ ./PYME/ParallelTasks/relativeFiles.py	(refactored)
@@ -43,7 +43,7 @@
     assumes path is absolute.'''
     relFilename = translateSeparators(relFilename)
 
-    if 'PYMEDATADIR' in os.environ.keys():
+    if 'PYMEDATADIR' in list(os.environ.keys()):
         return os.path.join(os.environ['PYMEDATADIR'], relFilename)
     else:
         return relFilename
@@ -73,7 +73,7 @@
         filename= os.path.abspath(filename)
 
     #print filename
-    if 'PYMEDATADIR' in os.environ.keys():
+    if 'PYMEDATADIR' in list(os.environ.keys()):
         dataDir = os.environ['PYMEDATADIR']
         if not dataDir[-1] in [os.sep, os.altsep]:
             dataDir = dataDir + os.sep
--- ./PYME/ParallelTasks/taskDef.py	(original)
+++ ./PYME/ParallelTasks/taskDef.py	(refactored)
@@ -40,4 +40,4 @@
  	def __init__(self):
  		Task.__init__(self)
  	def __call__(self):
- 		print "Hello"
+ 		print("Hello")
--- ./PYME/ParallelTasks/taskServerM.py	(original)
+++ ./PYME/ParallelTasks/taskServerM.py	(refactored)
@@ -28,19 +28,19 @@
 import random
 import threading
 import numpy
-from taskQueue import *
-from HDFTaskQueue import *
+from .taskQueue import *
+from .HDFTaskQueue import *
 
 import os
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
-    print Pyro.config.PYRO_NS_HOSTNAME
+    print(Pyro.config.PYRO_NS_HOSTNAME)
 
 #from PYME.mProfile import mProfile
 #mProfile.profileOn(['taskServerM.py', 'HDFTaskQueue.py'])
 
-if 'PYME_TASKQUEUENAME' in os.environ.keys():
+if 'PYME_TASKQUEUENAME' in list(os.environ.keys()):
     taskQueueName = os.environ['PYME_TASKQUEUENAME']
 else:
     taskQueueName = 'taskQueue'
@@ -83,13 +83,13 @@
 
     def postTask(self, task, queueName='Default'):
         #print queueName
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName] = TaskQueue(queueName)
 
         self.taskQueues[queueName].postTask(task)
 
     def postTasks(self, tasks, queueName='Default'):
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName] = TaskQueue(queueName)
 
         self.taskQueues[queueName].postTasks(tasks)
@@ -104,7 +104,7 @@
         if not workerName in self.activeWorkers:
             self.activeWorkers.append(workerName)
             
-        queuesWithOpenTasks = [q for q in self.taskQueues.values() if q.getNumberOpenTasks() > 0]
+        queuesWithOpenTasks = [q for q in list(self.taskQueues.values()) if q.getNumberOpenTasks() > 0]
 
         res = queuesWithOpenTasks[int(numpy.round(len(queuesWithOpenTasks)*numpy.random.rand() - 0.5))].getTask(self.activeWorkers.index(workerName), len(self.activeWorkers))
         self.getTaskLock.release()
@@ -120,7 +120,7 @@
         if not workerName in self.activeWorkers:
             self.activeWorkers.append(workerName)
 
-        queuesWithOpenTasks = [q for q in self.taskQueues.values() if q.getNumberOpenTasks() > 0]
+        queuesWithOpenTasks = [q for q in list(self.taskQueues.values()) if q.getNumberOpenTasks() > 0]
 
         res = queuesWithOpenTasks[int(numpy.round(len(queuesWithOpenTasks)*numpy.random.rand() - 0.5))].getTasks(self.activeWorkers.index(workerName), len(self.activeWorkers))
         self.getTaskLock.release()
@@ -129,7 +129,7 @@
     def returnCompletedTask(self, taskResult, workerName='Unspecified'):
         self.taskQueues[taskResult.queueID].returnCompletedTask(taskResult)
         self.numTasksProcessed += 1
-        if not workerName in self.numTasksProcByWorker.keys():
+        if not workerName in list(self.numTasksProcByWorker.keys()):
             self.numTasksProcByWorker[workerName] = 0
 
         self.numTasksProcByWorker[workerName] += 1
@@ -138,32 +138,32 @@
     def returnCompletedTasks(self, taskResult, workerName='Unspecified'):
         self.taskQueues[taskResult[0].queueID].returnCompletedTasks(taskResult)
         self.numTasksProcessed += len(taskResult)
-        if not workerName in self.numTasksProcByWorker.keys():
+        if not workerName in list(self.numTasksProcByWorker.keys()):
             self.numTasksProcByWorker[workerName] = 0
 
         self.numTasksProcByWorker[workerName] += len(taskResult)
         self.lastTaskByWorker[workerName] = time.time()
 
     def getCompletedTask(self, queueName = 'Default'):
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             return None
         else:
             return self.taskQueues[queueName].getCompletedTask()
 
     def checkTimeouts(self):
-        for q in self.taskQueues.values():
+        for q in list(self.taskQueues.values()):
             q.checkTimeouts()
 
         t = time.time()
         for w in self.activeWorkers:
-            if self.lastTaskByWorker.has_key(w) and self.lastTaskByWorker[w] < (t - self.activeTimeout):
+            if w in self.lastTaskByWorker and self.lastTaskByWorker[w] < (t - self.activeTimeout):
                 self.activeWorkers.remove(w)
 
     def getNumberOpenTasks(self, queueName = None):
         #print queueName
         if queueName == None:
             nO = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nO += q.getNumberOpenTasks()
             return nO
         else:
@@ -172,7 +172,7 @@
     def getNumberTasksInProgress(self, queueName = None):
         if queueName == None:
             nP = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nP += q.getNumberTasksInProgress()
             return nP
         else:
@@ -181,14 +181,14 @@
     def getNumberTasksCompleted(self, queueName = None):
         if queueName == None:
             nC = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nC += q.getNumberTasksCompleted()
             return nC
         else:
             return self.taskQueues[queueName].getNumberTasksCompleted()
 
     def purge(self, queueName = 'Default'):
-        if queueName in self.taskQueues.keys():
+        if queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName].purge()
 
     def removeQueue(self, queueName):
@@ -202,10 +202,10 @@
             return self.numTasksProcByWorker[workerName]
 
     def getWorkerNames(self):
-        return self.numTasksProcByWorker.keys()
+        return list(self.numTasksProcByWorker.keys())
 
     def getQueueNames(self):
-        return self.taskQueues.keys()
+        return list(self.taskQueues.keys())
 
     def setPopFcn(self, queueName, fcn):
         self.taskQueues[queueName].setPopFcn(fcn)
@@ -243,7 +243,7 @@
         return self.taskQueues[queueName].releaseTasks(*args)
 
     def createQueue(self, queueType, queueName, *args, **kwargs):
-        if queueName in self.taskQueues.keys():
+        if queueName in list(self.taskQueues.keys()):
             raise RuntimeError('queue with same name already present')
 
         self.taskQueues[queueName] = eval(queueType)(queueName, *args, **kwargs)
--- ./PYME/ParallelTasks/taskServerML.py	(original)
+++ ./PYME/ParallelTasks/taskServerML.py	(refactored)
@@ -11,13 +11,13 @@
 ##################
 
 
-from taskServerMP import *
+from .taskServerMP import *
 taskQueueName = 'PrivateTaskQueues.%s' % compName
 def main():
-    print 'foo'
+    print('foo')
     profile = False
     if len(sys.argv) > 1 and sys.argv[1] == '-p':
-        print 'profiling'
+        print('profiling')
         profile = True
         from PYME.mProfile import mProfile
         mProfile.profileOn(['taskServerMP.py', 'HDFTaskQueue.py', 'TaskQueue.py'])
--- ./PYME/ParallelTasks/taskServerMP.py	(original)
+++ ./PYME/ParallelTasks/taskServerMP.py	(refactored)
@@ -28,8 +28,8 @@
 import random
 import threading
 import numpy
-from taskQueue import *
-from HDFTaskQueue import *
+from .taskQueue import *
+from .HDFTaskQueue import *
 
 import logging
 logging.basicConfig(level=logging.DEBUG)
@@ -40,9 +40,9 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
-    print Pyro.config.PYRO_NS_HOSTNAME
+    print(Pyro.config.PYRO_NS_HOSTNAME)
 
 from PYME import mProfile
 #mProfile.profileOn(['taskServerMP.py', 'HDFTaskQueue.py'])
@@ -101,13 +101,13 @@
 
     def postTask(self, task, queueName='Default'):
         #print queueName
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName] = TaskQueue(queueName)
 
         self.taskQueues[queueName].postTask(task)
 
     def postTasks(self, tasks, queueName='Default'):
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName] = TaskQueue(queueName)
 
         self.taskQueues[queueName].postTasks(tasks)
@@ -122,7 +122,7 @@
             if not workerName in self.activeWorkers:
                 self.activeWorkers.append(workerName)
                 
-            queuesWithOpenTasks = [q for q in self.taskQueues.values() if q.getNumberOpenTasks() > 0]
+            queuesWithOpenTasks = [q for q in list(self.taskQueues.values()) if q.getNumberOpenTasks() > 0]
     
             res = queuesWithOpenTasks[int(numpy.round(len(queuesWithOpenTasks)*numpy.random.rand() - 0.5))].getTask(self.activeWorkers.index(workerName), len(self.activeWorkers))
         
@@ -142,7 +142,7 @@
                 if not workerName in self.activeWorkers:
                     self.activeWorkers.append(workerName)
     
-                queuesWithOpenTasks = [q for q in self.taskQueues.values() if q.getNumberOpenTasks(False) > 0]
+                queuesWithOpenTasks = [q for q in list(self.taskQueues.values()) if q.getNumberOpenTasks(False) > 0]
     
                 res = queuesWithOpenTasks[int(numpy.round(len(queuesWithOpenTasks)*numpy.random.rand() - 0.5))].getTasks(self.activeWorkers.index(workerName), len(self.activeWorkers))
         
@@ -153,7 +153,7 @@
     def returnCompletedTask(self, taskResult, workerName='Unspecified', timeTaken=None):
         self.taskQueues[taskResult.queueID].returnCompletedTask(taskResult)
         self.numTasksProcessed += 1
-        if not workerName in self.numTasksProcByWorker.keys():
+        if not workerName in list(self.numTasksProcByWorker.keys()):
             self.numTasksProcByWorker[workerName] = 0
 
         self.numTasksProcByWorker[workerName] += 1
@@ -166,7 +166,7 @@
     def returnCompletedTasks(self, taskResult, workerName='Unspecified', timeTaken=None):
         self.taskQueues[taskResult[0].queueID].returnCompletedTasks(taskResult)
         self.numTasksProcessed += len(taskResult)
-        if not workerName in self.numTasksProcByWorker.keys():
+        if not workerName in list(self.numTasksProcByWorker.keys()):
             self.numTasksProcByWorker[workerName] = 0
 
         self.numTasksProcByWorker[workerName] += len(taskResult)
@@ -179,25 +179,25 @@
 
 
     def getCompletedTask(self, queueName = 'Default'):
-        if not queueName in self.taskQueues.keys():
+        if not queueName in list(self.taskQueues.keys()):
             return None
         else:
             return self.taskQueues[queueName].getCompletedTask()
 
     def checkTimeouts(self):
-        for q in self.taskQueues.values():
+        for q in list(self.taskQueues.values()):
             q.checkTimeouts()
 
         t = time.time()
         for w in self.activeWorkers:
-            if self.lastTaskByWorker.has_key(w) and self.lastTaskByWorker[w] < (t - self.activeTimeout):
+            if w in self.lastTaskByWorker and self.lastTaskByWorker[w] < (t - self.activeTimeout):
                 self.activeWorkers.remove(w)
 
     def getNumberOpenTasks(self, queueName = None, exact=True):
         #print queueName
         if queueName == None:
             nO = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nO += q.getNumberOpenTasks(exact)
             return nO
         else:
@@ -206,7 +206,7 @@
     def getNumberTasksInProgress(self, queueName = None):
         if queueName == None:
             nP = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nP += q.getNumberTasksInProgress()
             return nP
         else:
@@ -215,14 +215,14 @@
     def getNumberTasksCompleted(self, queueName = None):
         if queueName == None:
             nC = 0
-            for q in self.taskQueues.values():
+            for q in list(self.taskQueues.values()):
                 nC += q.getNumberTasksCompleted()
             return nC
         else:
             return self.taskQueues[queueName].getNumberTasksCompleted()
 
     def purge(self, queueName = 'Default'):
-        if queueName in self.taskQueues.keys():
+        if queueName in list(self.taskQueues.keys()):
             self.taskQueues[queueName].purge()
 
     def removeQueue(self, queueName):
@@ -236,7 +236,7 @@
             return self.numTasksProcByWorker[workerName]
 
     def getWorkerNames(self):
-        return self.numTasksProcByWorker.keys()
+        return list(self.numTasksProcByWorker.keys())
 
     def getWorkerFPS(self, workerName):
         if workerName in self.activeWorkers and not self.lastTimeByWorker[workerName] == None:
@@ -245,7 +245,7 @@
             return 0
 
     def getQueueNames(self):
-        return self.taskQueues.keys()
+        return list(self.taskQueues.keys())
 
     def setPopFcn(self, queueName, fcn):
         self.taskQueues[queueName].setPopFcn(fcn)
@@ -283,7 +283,7 @@
         return self.taskQueues[queueName].releaseTasks(*args)
 
     def createQueue(self, queueType, queueName, *args, **kwargs):
-        if queueName in self.taskQueues.keys():
+        if queueName in list(self.taskQueues.keys()):
             raise RuntimeError('queue with same name already present')
 
         self.taskQueues[queueName] = eval(queueType)(queueName, *args, **kwargs)
@@ -296,10 +296,10 @@
 			
 
 def main():
-    print 'foo'
+    print('foo')
     profile = False
     if len(sys.argv) > 1 and sys.argv[1] == '-p':
-        print 'profiling'
+        print('profiling')
         profile = True
         from PYME.mProfile import mProfile
         mProfile.profileOn(['taskServerMP.py', 'HDFTaskQueue.py', 'TaskQueue.py'])
--- ./PYME/ParallelTasks/taskWorkerM.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerM.py	(refactored)
@@ -25,12 +25,12 @@
 import os
 import sys
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=1
 
-if 'PYME_TASKQUEUENAME' in os.environ.keys():
+if 'PYME_TASKQUEUENAME' in list(os.environ.keys()):
     taskQueueName = os.environ['PYME_TASKQUEUENAME']
 else:
     taskQueueName = 'taskQueue'
--- ./PYME/ParallelTasks/taskWorkerML.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerML.py	(refactored)
@@ -32,7 +32,7 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=0
@@ -83,14 +83,14 @@
             if e.message == 'connection failed':
                 #remember that the server failed - and put it 'on notice'
                 nFails = 1
-                if qName in serverFails.keys():
+                if qName in list(serverFails.keys()):
                     nFails += serverFails[qName]
 
                 serverFails[qName] = nFails
 
                 if False:#nFails >= 4:
                     #server is dead in the water - put it out of it's misery
-                    print 'Killing:', qName
+                    print('Killing:', qName)
                     try:
                         ns.unregister('TaskQueues.%s' % qName)
                     except Pyro.errors.NamingError:
--- ./PYME/ParallelTasks/taskWorkerMP.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerMP.py	(refactored)
@@ -32,7 +32,7 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=0
@@ -85,14 +85,14 @@
             if e.message == 'connection failed':
                 #remember that the server failed - and put it 'on notice'
                 nFails = 1
-                if qName in serverFails.keys():
+                if qName in list(serverFails.keys()):
                     nFails += serverFails[qName]
 
                 serverFails[qName] = nFails
 
                 if False:#nFails >= 4:
                     #server is dead in the water - put it out of it's misery
-                    print 'Killing:', qName
+                    print('Killing:', qName)
                     try:
                         ns.unregister('TaskQueues.%s' % qName)
                     except Pyro.errors.NamingError:
--- ./PYME/ParallelTasks/taskWorkerMPP.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerMPP.py	(refactored)
@@ -36,7 +36,7 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=0
--- ./PYME/ParallelTasks/taskWorkerMS.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerMS.py	(refactored)
@@ -26,12 +26,12 @@
 import os
 import sys
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=1
 
-if 'PYME_TASKQUEUENAME' in os.environ.keys():
+if 'PYME_TASKQUEUENAME' in list(os.environ.keys()):
     taskQueueName = os.environ['PYME_TASKQUEUENAME']
 else:
     taskQueueName = 'taskQueue'
--- ./PYME/ParallelTasks/taskWorkerP.py	(original)
+++ ./PYME/ParallelTasks/taskWorkerP.py	(refactored)
@@ -28,8 +28,8 @@
 import random
 import threading
 import numpy
-from taskQueue import *
-from HDFTaskQueue import *
+from .taskQueue import *
+from .HDFTaskQueue import *
 
 import os
 import sys
--- ./PYME/ParallelTasks/Loft/WorkerApp.py	(original)
+++ ./PYME/ParallelTasks/Loft/WorkerApp.py	(refactored)
@@ -28,7 +28,7 @@
 
 import WorkerFrame
 
-modules ={u'WorkerFrame': [1, 'Main frame of Application', u'WorkerFrame.py']}
+modules ={'WorkerFrame': [1, 'Main frame of Application', 'WorkerFrame.py']}
 
 class BoaApp(wx.App):
     def OnInit(self):
--- ./PYME/ParallelTasks/Loft/WorkerFrame.py	(original)
+++ ./PYME/ParallelTasks/Loft/WorkerFrame.py	(refactored)
@@ -81,7 +81,7 @@
         self.tGetTask.Start(1000)
 
     def OnTGetTaskTimer(self, event):
-        print 'Getting Task ...'
+        print('Getting Task ...')
         time.sleep(0.01) #to improve GUI responsiveness
         self.tq.returnCompletedTask(self.tq.getTask()(gui=True))
-        print 'Completed Task'
+        print('Completed Task')
--- ./PYME/ParallelTasks/Loft/taskServer.py	(original)
+++ ./PYME/ParallelTasks/Loft/taskServer.py	(refactored)
@@ -36,7 +36,7 @@
 	def run(self):
 		while True:
 			self.tQueue.checkTimeouts()
-			print '%d tasks in queue' % self.tQueue.getNumberOpenTasks()
+			print('%d tasks in queue' % self.tQueue.getNumberOpenTasks())
 			time.sleep(10)
 
 class TaskQueue(Pyro.core.ObjBase):
@@ -48,11 +48,11 @@
                 
 	def postTask(self,task):
 		self.openTasks.append(task)
-		print 'Recieved new task'
+		print('Recieved new task')
 
 	def getTask(self):
 		"""get task from front of list, blocks"""
-		print 'Task requested'
+		print('Task requested')
 		while len(self.openTasks) < 1:
 			time.sleep(0.01)
 
@@ -60,7 +60,7 @@
 
 		task.initializeWorkerTimeout(time.clock())
 		self.tasksInProgress.append(task)
-		print 'Task given to worker'
+		print('Task given to worker')
 		return task
 
 	def returnCompletedTask(self, taskResult):
--- ./PYME/ParallelTasks/Loft/taskWorker.py	(original)
+++ ./PYME/ParallelTasks/Loft/taskWorker.py	(refactored)
@@ -29,6 +29,6 @@
 tq = Pyro.core.getProxyForURI("PYRONAME://taskQueue")
 
 while 1:
-    print 'Geting Task ...'
+    print('Geting Task ...')
     tq.returnCompletedTask(tq.getTask()())
-    print 'Completed Task'
+    print('Completed Task')
--- ./PYME/ParallelTasks/Screensaver/PYMEScreensaver.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/PYMEScreensaver.py	(refactored)
@@ -59,7 +59,7 @@
     if num >= 1:
         return num
     else:
-        raise NotImplementedError, 'cannot determine number of cpus'
+        raise NotImplementedError('cannot determine number of cpus')
 
 
 
@@ -106,23 +106,23 @@
 
         w,h = self.dc.getSize()
         
-        self.dc.setColor(0xffffffL)
-        self.dc.setTextColor(0x00ff00L)
-        self.dc.setBgColor(0x000000L)
+        self.dc.setColor(0xffffff)
+        self.dc.setTextColor(0x00ff00)
+        self.dc.setBgColor(0x000000)
         self.dc.setFont("courier new")
         #~ self.dc.setBgTransparent(True)
         #self.dc.drawLine((0+self.x, 0), (self.x*5, 50))
         self.dc.drawText((100,50), "Your computer has been assimilated into the...")
-        self.dc.setTextColor(0xffffffL)
+        self.dc.setTextColor(0xffffff)
         self.dc.setFont("arial", 50, bold=True)
         self.dc.drawText((w/2 - 300,100), "PYthon Microscopy Environment")
-        self.dc.setTextColor(0xff4f3fL)
+        self.dc.setTextColor(0xff4f3f)
         self.dc.setFont("arial", 250, bold=True)
         self.dc.drawText((w/2 - 250,150), "PYME")
-        self.dc.setTextColor(0xffffffL)
+        self.dc.setTextColor(0xffffff)
         self.dc.setFont("arial", 50, bold=True)
         self.dc.drawText((w/2 - 300,400), "Distributed Data Analysis Collective")
-        self.dc.setTextColor(0x00ff00L)
+        self.dc.setTextColor(0x00ff00)
         self.dc.setFont("courier new")
         self.dc.drawText((100,470), "To exit move mouse or press a key")
         self.dc.drawText((100,490), "Queries: d.baddeley@auckland.ac.nz")
--- ./PYME/ParallelTasks/Screensaver/buildScr.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/buildScr.py	(refactored)
@@ -39,12 +39,12 @@
     )
 except getopt.GetoptError:
     # print help information and exit:
-    print __doc__
+    print(__doc__)
     sys.exit(2)
 
 for o, a in opts:
     if o in ("-h", "--help"):
-        print __doc__
+        print(__doc__)
         sys.exit()
     elif o in ("-g", "--pygame"):
         pygameMode = True
@@ -54,7 +54,7 @@
             data_files.append(filename)
 
 if not args:
-    print __doc__
+    print(__doc__)
     sys.exit(1)
 
 name = args[0]
--- ./PYME/ParallelTasks/Screensaver/pyscr.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/pyscr.py	(refactored)
@@ -20,7 +20,7 @@
 This is distributed under a free software license, see license.txt.
 """
 
-import sys, traceback, StringIO
+import sys, traceback, io
 from ctypes import *
 from winuser import*
 from wingdi import *
@@ -95,12 +95,12 @@
                 self.initialize()
             except:
                 PostMessage(self.hWnd, WM_CLOSE, 0, 0)
-                exinfo = StringIO.StringIO()
+                exinfo = io.StringIO()
                 traceback.print_exc(file=exinfo)
-                print "-"*78
-                print "Exception in users initialiaztion code:"
-                print exinfo.getvalue()
-                print "-"*78
+                print("-"*78)
+                print("Exception in users initialiaztion code:")
+                print(exinfo.getvalue())
+                print("-"*78)
                 self.closing = True
                 self.finalize()
                 windll.user32.MessageBoxA(self.hWnd, exinfo.getvalue(), "Error in pyscr startup", 0, 0, 0)
@@ -284,7 +284,7 @@
     is there it's random which one is used... so only define one per file."""
     
     import __main__
-    for name, value in __main__.__dict__.items():
+    for name, value in list(__main__.__dict__.items()):
         if type(value) == type(Screensaver) and issubclass(value, Screensaver):
             saver = value()
             break
--- ./PYME/ParallelTasks/Screensaver/taskWorkerME.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/taskWorkerME.py	(refactored)
@@ -41,7 +41,7 @@
 from PYME.misc.computerName import GetComputerName
 compName = GetComputerName()
 
-if 'PYRO_NS_HOSTNAME' in os.environ.keys():
+if 'PYRO_NS_HOSTNAME' in list(os.environ.keys()):
     Pyro.config.PYRO_NS_HOSTNAME=os.environ['PYRO_NS_HOSTNAME']
 
 Pyro.config.PYRO_MOBILE_CODE=0
@@ -77,7 +77,7 @@
         except Pyro.core.ProtocolError as e:
             if e.message == 'connection failed':
                 #server is dead in the water - put it out of it's misery
-                print 'Killing:', qName
+                print('Killing:', qName)
                 try:
                     ns.unregister('TaskQueues.%s' % qName)
                 except Pyro.errors.NamingError:
--- ./PYME/ParallelTasks/Screensaver/windc.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/windc.py	(refactored)
@@ -48,24 +48,33 @@
     # drawing functions
     #------------------------------------------------------------------------
     
-    def drawLine(self, (x1,y1), (x2,y2)):
+    def drawLine(self, xxx_todo_changeme, xxx_todo_changeme1):
+        (x1,y1) = xxx_todo_changeme
+        (x2,y2) = xxx_todo_changeme1
         windll.gdi32.MoveToEx(self.dc, x1, y1, NULL)
         windll.gdi32.LineTo(self.dc, x2, y2)
 
-    def drawText(self, (x,y), text):
+    def drawText(self, xxx_todo_changeme2, text):
+        (x,y) = xxx_todo_changeme2
         windll.gdi32.TextOutA(self.dc, int(x), int(y), text, len(text))
 
-    def drawRect(self, (x1,y1), (x2,y2)):
+    def drawRect(self, xxx_todo_changeme3, xxx_todo_changeme4):
+        (x1,y1) = xxx_todo_changeme3
+        (x2,y2) = xxx_todo_changeme4
         windll.gdi32.MoveToEx(self.dc, x1, y1, NULL);
         windll.gdi32.LineTo(self.dc, x1, y2);
         windll.gdi32.LineTo(self.dc, x2, y2);
         windll.gdi32.LineTo(self.dc, x2, y1);
         windll.gdi32.LineTo(self.dc, x1, y1);
     
-    def fillRect(self, (x1,y1), (x2,y2)):
+    def fillRect(self, xxx_todo_changeme5, xxx_todo_changeme6):
+        (x1,y1) = xxx_todo_changeme5
+        (x2,y2) = xxx_todo_changeme6
         windll.gdi32.Rectangle(self.dc, x1, y1, x2, y2)
         
-    def invertRect(self, (x1,y1), (x2,y2)):
+    def invertRect(self, xxx_todo_changeme7, xxx_todo_changeme8):
+        (x1,y1) = xxx_todo_changeme7
+        (x2,y2) = xxx_todo_changeme8
         rc = RECT()
         rc.left = x1
         rc.top = y1
@@ -73,7 +82,9 @@
         rc.bottom = y2
         windll.gdi32.InvertRect(self.dc, byref(rc))
     
-    def fillEllipse(self, (x1,y1), (x2,y2)):
+    def fillEllipse(self, xxx_todo_changeme9, xxx_todo_changeme10):
+        (x1,y1) = xxx_todo_changeme9
+        (x2,y2) = xxx_todo_changeme10
         windll.gdi32.Ellipse(self.dc, x1, y1, x2, y2)
     
     
--- ./PYME/ParallelTasks/Screensaver/wingdi.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/wingdi.py	(refactored)
@@ -238,7 +238,7 @@
 PFD_GENERIC_ACCELERATED = 0x00001000
 PFD_DEPTH_DONTCARE = 0x20000000
 PFD_DOUBLEBUFFER_DONTCARE = 0x40000000
-PFD_STEREO_DONTCARE = 0x80000000L
+PFD_STEREO_DONTCARE = 0x80000000
 SP_ERROR = (-1)
 SP_OUTOFDISK = (-4)
 SP_OUTOFMEMORY = (-5)
@@ -479,7 +479,7 @@
 FS_WANSUNG = 0x80000
 FS_CHINESETRAD = 0x100000
 FS_JOHAB = 0x200000
-FS_SYMBOL = 0x80000000L
+FS_SYMBOL = 0x80000000
 HS_BDIAGONAL = 3
 HS_CROSS = 4
 HS_DIAGCROSS = 5
@@ -757,9 +757,9 @@
 PC_EXPLICIT = 2
 PC_NOCOLLAPSE = 4
 PC_RESERVED = 1
-CLR_NONE = 0xffffffffL
+CLR_NONE = 0xffffffff
 CLR_INVALID = CLR_NONE
-CLR_DEFAULT = 0xff000000L
+CLR_DEFAULT = 0xff000000
 PT_MOVETO = 6
 PT_LINETO = 2
 PT_BEZIERTO = 4
@@ -1088,7 +1088,7 @@
 DMDITHER_RESERVED9 = 9
 DMDITHER_GRAYSCALE = 10
 DMDITHER_USER = 256
-GDI_ERROR = 0xFFFFFFFFL
+GDI_ERROR = 0xFFFFFFFF
 TMPF_FIXED_PITCH = 1
 TMPF_VECTOR = 2
 TMPF_TRUETYPE = 4
@@ -1100,7 +1100,7 @@
 TT_PRIM_LINE = 1
 TT_PRIM_QSPLINE = 2
 FONTMAPPER_MAX = 10
-ENHMETA_STOCK_OBJECT = 0x80000000L
+ENHMETA_STOCK_OBJECT = 0x80000000
 WGL_FONT_LINES = 0
 WGL_FONT_POLYGONS = 1
 LPD_DOUBLEBUFFER = 1
--- ./PYME/ParallelTasks/Screensaver/winuser.py	(original)
+++ ./PYME/ParallelTasks/Screensaver/winuser.py	(refactored)
@@ -168,7 +168,7 @@
 DESKTOP_READOBJECTS = 1
 DESKTOP_SWITCHDESKTOP = 256
 DESKTOP_WRITEOBJECTS = 128
-CW_USEDEFAULT = 0x80000000L
+CW_USEDEFAULT = 0x80000000
 WS_BORDER = 0x800000
 WS_CAPTION = 0xc00000
 WS_CHILD = 0x40000000
@@ -186,8 +186,8 @@
 WS_MINIMIZEBOX = 0x20000
 WS_OVERLAPPED = 0
 WS_OVERLAPPEDWINDOW = 0xcf0000
-WS_POPUP = 0x80000000L
-WS_POPUPWINDOW = 0x80880000L
+WS_POPUP = 0x80000000
+WS_POPUPWINDOW = 0x80880000
 WS_SIZEBOX = 0x40000
 WS_SYSMENU = 0x80000
 WS_TABSTOP = 0x10000
@@ -301,11 +301,11 @@
 SS_WHITEFRAME = 9
 SS_WHITERECT = 6
 SS_USERITEM = 10
-SS_TYPEMASK = 0x0000001FL
-SS_ENDELLIPSIS = 0x00004000L
-SS_PATHELLIPSIS = 0x00008000L
-SS_WORDELLIPSIS = 0x0000C000L
-SS_ELLIPSISMASK = 0x0000C000L
+SS_TYPEMASK = 0x0000001F
+SS_ENDELLIPSIS = 0x00004000
+SS_PATHELLIPSIS = 0x00008000
+SS_WORDELLIPSIS = 0x0000C000
+SS_ELLIPSISMASK = 0x0000C000
 DS_3DLOOK = 4
 DS_ABSALIGN = 1
 DS_CENTER = 0x800
@@ -554,7 +554,7 @@
 MFT_RADIOCHECK = 512
 MFT_RIGHTJUSTIFY = 0x4000
 MFT_SEPARATOR = 0x800
-MFT_RIGHTORDER = 0x2000L
+MFT_RIGHTORDER = 0x2000
 MFT_STRING = 0
 MFS_CHECKED = 8
 MFS_DEFAULT = 4096
@@ -1566,8 +1566,8 @@
 TME_HOVER = 1
 TME_LEAVE = 2
 TME_QUERY = 0x40000000
-TME_CANCEL = 0x80000000L
-HOVER_DEFAULT = 0xFFFFFFFFL
+TME_CANCEL = 0x80000000
+HOVER_DEFAULT = 0xFFFFFFFF
 MK_LBUTTON = 1
 MK_RBUTTON = 2
 MK_SHIFT = 4
--- ./PYME/SampleDB/batchDrift.py	(original)
+++ ./PYME/SampleDB/batchDrift.py	(refactored)
@@ -38,7 +38,7 @@
 filename = sys.argv[1]
 
 def fitDrift(filename):
-    print filename
+    print(filename)
     pipe = pipeline.Pipeline(filename)
 
     im = Image.objects.get(pk=pipe.mdh['imageID'])
@@ -53,7 +53,7 @@
                       parameters=dc.driftCorrParams, auto=True)
         df.save()
         
-        print df
+        print(df)
         
     pipe.CloseFiles()
 
--- ./PYME/SampleDB/manage.py	(original)
+++ ./PYME/SampleDB/manage.py	(refactored)
@@ -24,7 +24,7 @@
 #!/usr/bin/env python
 from django.core.management import execute_manager
 try:
-    import settings # Assumed to be in the same directory.
+    from . import settings # Assumed to be in the same directory.
 except ImportError:
     import sys
     sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
--- ./PYME/SampleDB/populate.py	(original)
+++ ./PYME/SampleDB/populate.py	(refactored)
@@ -50,7 +50,7 @@
                         f.filesize = os.path.getsize(filename)
                         f.save()
                 except ValueError as e:
-                    print e
+                    print(e)
 
 
 if __name__ == '__main__':
--- ./PYME/SampleDB/settings.py	(original)
+++ ./PYME/SampleDB/settings.py	(refactored)
@@ -43,7 +43,7 @@
 DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.
 
 #look for database host in environment variable
-if 'PYME_DATABASE_HOST' in os.environ.keys():
+if 'PYME_DATABASE_HOST' in list(os.environ.keys()):
     DATABASE_HOST = os.environ['PYME_DATABASE_HOST']
 
 # Local time zone for this installation. Choices can be found here:
--- ./PYME/SampleDB/autocomplete/utils.py	(original)
+++ ./PYME/SampleDB/autocomplete/utils.py	(refactored)
@@ -25,8 +25,8 @@
 from django.forms.models import modelform_factory
 from django.db import models
 
-import widgets
-from views import autocomplete as default_view
+from . import widgets
+from .views import autocomplete as default_view
 
 
 def autocomplete_formfield(ac_id, formfield=None, view=default_view,
--- ./PYME/SampleDB/autocomplete/views.py	(original)
+++ ./PYME/SampleDB/autocomplete/views.py	(refactored)
@@ -28,6 +28,7 @@
 from django.http import Http404, HttpResponse, HttpResponseForbidden
 from django.utils import simplejson
 from django.utils.encoding import smart_str
+from functools import reduce
 
 
 class AlreadyRegistered(Exception):
@@ -47,12 +48,12 @@
     login_required = False
  
     def label(self, obj):
-        return unicode(obj)
+        return str(obj)
     value = label
    
 
     def __init__(self, id, current_app, **kwargs):
-        for (k, v) in kwargs.items():
+        for (k, v) in list(kwargs.items()):
             setattr(self, k, v)
         self.id = id
         self.current_app = current_app
@@ -71,7 +72,7 @@
                 self.key = self.field.rel.get_related_field().name
             if self.reverse_label is None:
                 self.reverse_label = True
-        elif isinstance(id, (str, unicode)):
+        elif isinstance(id, str):
             self.field = None
             self.model = self.queryset.model
             self.id = id
@@ -90,7 +91,7 @@
 
         for name in ('value', 'label'):
             attr = getattr(self, name)
-            if isinstance(attr, (str, unicode)):
+            if isinstance(attr, str):
                 setattr(self, name, build_func(attr))
 
     def view(self, request):
--- ./PYME/SampleDB/autocomplete/widgets.py	(original)
+++ ./PYME/SampleDB/autocomplete/widgets.py	(refactored)
@@ -27,7 +27,7 @@
 from django.utils.safestring import mark_safe
 from django.conf import settings
 
-from views import autocomplete as default_view
+from .views import autocomplete as default_view
 
 
 class AutocompleteWidget(forms.Widget):
@@ -56,7 +56,7 @@
         self.js_options.update(js_options)
         super(AutocompleteWidget, self).__init__(attrs)
 
-    def render(self, name, value, attrs=None, hattrs=None, initial_objects=u''):
+    def render(self, name, value, attrs=None, hattrs=None, initial_objects=''):
         if value is None:
             value = ''
         hidden_id = 'id_hidden_%s' % name
@@ -70,13 +70,13 @@
         if not self.js_options.get('source'):
             self.js_options['source'] = self.settings.get_absolute_url()
         options = simplejson.dumps(self.js_options)
-        return mark_safe(u''.join((
-            u'<input%s />\n' % flatatt(hidden_attrs),
-            u'<input%s />\n' % flatatt(normal_attrs),
+        return mark_safe(''.join((
+            '<input%s />\n' % flatatt(hidden_attrs),
+            '<input%s />\n' % flatatt(normal_attrs),
             initial_objects,
-            u'<script type="text/javascript">',
-            u'django.autocomplete("#id_%s", %s);' % (name, options),
-            u'</script>\n',
+            '<script type="text/javascript">',
+            'django.autocomplete("#id_%s", %s);' % (name, options),
+            '</script>\n',
         )))
 
     def label_for_value(self, value):
@@ -102,7 +102,7 @@
             value = ','.join([str(v) for v in value])
         else:
             value = None
-            initial_objects = u''
+            initial_objects = ''
         return super(MultipleAutocompleteWidget, self).render(
             name, value, attrs, hattrs, initial_objects)
 
@@ -117,8 +117,8 @@
     
     def initial_objects(self, value):
         settings = self.settings
-        output = [u'<ul class="ui-autocomplete-values">']
+        output = ['<ul class="ui-autocomplete-values">']
         for obj in settings.queryset.filter(**{'%s__in' % settings.key: value}):
-            output.append(u'<li>%s</li>' % settings.label(obj))
-        output.append(u'</ul>\n')
-        return mark_safe(u'\n'.join(output))
+            output.append('<li>%s</li>' % settings.label(obj))
+        output.append('</ul>\n')
+        return mark_safe('\n'.join(output))
--- ./PYME/SampleDB/samples/autocomp_settings.py	(original)
+++ ./PYME/SampleDB/samples/autocomp_settings.py	(refactored)
@@ -37,7 +37,7 @@
     key='creator'
 
     def label(self, o):
-        return unicode(o.creator)
+        return str(o.creator)
     value = label
 
 class StructureAutocomplete(AutocompleteSettings):
@@ -46,7 +46,7 @@
     key='structure'
 
     def label(self, o):
-        return unicode(o.structure)
+        return str(o.structure)
     value = label
 
 #class CustomRenderingAutocomplete(SimpleAutocomplete):
--- ./PYME/SampleDB/samples/calcEventStats.py	(original)
+++ ./PYME/SampleDB/samples/calcEventStats.py	(refactored)
@@ -21,7 +21,7 @@
 
 #
 ################
-import models
+from . import models
 from PYME.Analysis.LMVis.h5rNoGui import Pipeline
 from PYME.Analysis.BleachProfile.kinModels import getPhotonNums
 import numpy as np
@@ -49,7 +49,7 @@
 
 def getStats(file):
     if file.filename.endswith('.h5r'):
-        print file.filename
+        print(file.filename)
         try:
             p = Pipeline(file.filename)
             getStatsChan(p, 'Everything', file)
@@ -60,7 +60,7 @@
 
         except Exception as e:
             #traceback.print_exc()
-            print e
+            print(e)
         finally:
             try:
                 p.selectedDataSource.resultsSource.close()
--- ./PYME/SampleDB/samples/dategraph.py	(original)
+++ ./PYME/SampleDB/samples/dategraph.py	(refactored)
@@ -45,14 +45,14 @@
     usernames = set([i.userID for i in Image.objects.all()])
     usernames = [u for u in usernames if (u.find('-') == -1) and (u.find(' ') ==-1)]
 
-    users = [i[0].split('_')[1] for i in request.REQUEST.items() if i[0].startswith('user_') and i[1] == '1']
+    users = [i[0].split('_')[1] for i in list(request.REQUEST.items()) if i[0].startswith('user_') and i[1] == '1']
     #print users
     if len(users) >  0:
         filters['userID__in'] = users
 
     tagnames = [t.name for t in TagName.objects.all()]
 
-    tags = [i[0].split('__')[1] for i in request.REQUEST.items() if i[0].startswith('tag__') and i[1] == '1']
+    tags = [i[0].split('__')[1] for i in list(request.REQUEST.items()) if i[0].startswith('tag__') and i[1] == '1']
     #print users
 #    if len(tags) >  0:
 #        filters['userID__in'] = users
--- ./PYME/SampleDB/samples/fields.py	(original)
+++ ./PYME/SampleDB/samples/fields.py	(refactored)
@@ -26,8 +26,9 @@
 from copy import deepcopy
 from base64 import b64encode, b64decode
 from zlib import compress, decompress
+import collections
 try:
-    from cPickle import loads, dumps
+    from pickle import loads, dumps
 except ImportError:
     from pickle import loads, dumps
 
@@ -72,7 +73,7 @@
         value = loads(decompress(b64decode(value)))
     return value
 
-class PickledObjectField(models.Field):
+class PickledObjectField(models.Field, metaclass=models.SubfieldBase):
     """
     A field that will accept *any* python object and store it in the
     database. PickledObjectField will optionally compress it's values if
@@ -85,7 +86,6 @@
     None values since they aren't pickled and encoded.
     
     """
-    __metaclass__ = models.SubfieldBase
     
     def __init__(self, *args, **kwargs):
         self.compress = kwargs.pop('compress', False)
@@ -107,7 +107,7 @@
         
         """
         if self.has_default():
-            if callable(self.default):
+            if isinstance(self.default, collections.Callable):
                 return self.default()
             return self.default
         # If the field doesn't have a default, then we punt to models.Field.
--- ./PYME/SampleDB/samples/models.py	(original)
+++ ./PYME/SampleDB/samples/models.py	(refactored)
@@ -27,7 +27,7 @@
 
 from PYME.misc.hash32 import hashString32
 
-from fields import PickledObjectField
+from .fields import PickledObjectField
 
 # Create your models here.
 class Species(models.Model):
@@ -44,7 +44,7 @@
     strain = models.CharField(max_length=200, default='', blank=True, help_text='Strain of animal / cell culture line (sugest stable transfections = different strain, transient tranf. same strain)')
 
     def __unicode__(self):
-        return u'%s - %s' % (self.speciesName, self.strain)
+        return '%s - %s' % (self.speciesName, self.strain)
 
 class Sample(models.Model):
     SAMPLE_TYPES = (('Cell Culture', 'Cultured Cells'),
@@ -59,7 +59,7 @@
     notes = models.TextField(blank=True, help_text='Any other information about the sample, e.g. manipulations, transfections, disease type (free form)', default='')
 
     def __unicode__(self):
-        return u'%s - %s [%s]' % (self.species, self.sampleType, self.patientID)
+        return '%s - %s [%s]' % (self.species, self.sampleType, self.patientID)
 
 class Dye(models.Model):
     try:
@@ -75,7 +75,7 @@
     spectraDBName = models.CharField(max_length=200, choices=DYE_NAMES, help_text='Name that identifies the spectra in Omegas spectra database')
 
     def __unicode__(self):
-        return u'Dye: %s' % self.shortName
+        return 'Dye: %s' % self.shortName
 
 def _getMostRecentCreator():
         return Slide._GetMostRecent().creator
@@ -127,7 +127,7 @@
         return self.creator, self.reference, self.labels()
 
     def __unicode__(self):
-        return u'Slide %d: %s, %s' % (self.slideID, self.creator, self.reference)
+        return 'Slide %d: %s, %s' % (self.slideID, self.creator, self.reference)
 
     @classmethod
     def _GetMostRecent(cls):
@@ -214,7 +214,7 @@
         f = File.GetOrCreate(filename, fileID=fileID, imageID=self)
 
     def __unicode__(self):
-        return u'Image %d: %s' % (self.imageID, ', '.join([n.filename for n in self.files.all()]))
+        return 'Image %d: %s' % (self.imageID, ', '.join([n.filename for n in self.files.all()]))
 
     @classmethod
     def GetOrCreate(cls, imageID, userGuess='N/A', slideID=None, timestamp=0):
@@ -243,7 +243,7 @@
         FileTag.AddTag(self, tagName)
 
     def __unicode__(self):
-        return u'File %d: %s' % (self.fileID, self.filename)
+        return 'File %d: %s' % (self.fileID, self.filename)
 
     @classmethod
     def GetOrCreate(cls, filename, fileID=None, imageID=None):
@@ -256,7 +256,7 @@
         except:
             import PYME.FileUtils.fileID as file_ID
 
-            print filename
+            print(filename)
 
             mdh = file_ID.getFileMetadata(filename)
             
@@ -268,7 +268,7 @@
                 if 'imageID' in mdh.getEntryNames():
                     imageID = mdh.imageID
                 else:
-                    print 'guessing image id', filename
+                    print('guessing image id', filename)
                     imageID = file_ID.genImageID(filename, guess=True)
 
                 #print imageID
@@ -329,13 +329,13 @@
             return self.label
 
     def __unicode__(self):
-        return u'%s, %s (Slide %d)' % (self.structure, self.label, self.slideID.slideID)
+        return '%s, %s (Slide %d)' % (self.structure, self.label, self.slideID.slideID)
 
 class TagName(models.Model):
     name = models.CharField(max_length=200)
 
     def __unicode__(self):
-        return u'%s' % self.name
+        return '%s' % self.name
 
     @classmethod
     def GetOrCreate(cls, tagName):
@@ -411,7 +411,7 @@
     parameters = PickledObjectField()
     
     def __unicode__(self):
-        s =  u'%s - x = %s, y = %s' % (self.timestamp, self.exprX, self.exprY)
+        s =  '%s - x = %s, y = %s' % (self.timestamp, self.exprX, self.exprY)
         if len(s) > 60:
             s = s[:60] + ' ...'
             
@@ -430,7 +430,7 @@
     
 
     def __unicode__(self):
-        return u'Stats for %s: %s\t%d\t%3.1f\t%3.2f\t%3.1f' % (self.fileID.filename, self.label, self.nEvents, self.meanPhotons, self.tMax, self.tMedian)
+        return 'Stats for %s: %s\t%d\t%3.1f\t%3.2f\t%3.1f' % (self.fileID.filename, self.label, self.nEvents, self.meanPhotons, self.tMax, self.tMedian)
 
     
 #print Slide.creator
--- ./PYME/SampleDB/samples/views.py	(original)
+++ ./PYME/SampleDB/samples/views.py	(refactored)
@@ -50,7 +50,7 @@
     creatornames = set([s.creator for s in Slide.objects.all()])
     creatornames = [u for u in creatornames if (u.find('-') == -1) and (u.find(' ') ==-1) and (u.find('.') ==-1)]
 
-    creator = [i[0].split('_')[1] for i in request.REQUEST.items() if i[0].startswith('creator_') and i[1] == '1']
+    creator = [i[0].split('_')[1] for i in list(request.REQUEST.items()) if i[0].startswith('creator_') and i[1] == '1']
     #print users
     if len(creator) >  0:
         filters['creator__in'] = creator
@@ -59,7 +59,7 @@
 
     structures = set([l.structure for l in Labelling.objects.all()])
 
-    structure = [i[0].split('_')[1] for i in request.REQUEST.items() if i[0].startswith('structure_') and i[1] == '1']
+    structure = [i[0].split('_')[1] for i in list(request.REQUEST.items()) if i[0].startswith('structure_') and i[1] == '1']
 
     if len(structure) >  0:
         filters['labelling__structure__in'] = structure
@@ -126,7 +126,7 @@
     usernames = set([i.userID for i in Image.objects.all()])
     usernames = [u for u in usernames if (u.find('-') == -1) and (u.find(' ') ==-1)]
 
-    users = [i[0].split('_')[1] for i in request.REQUEST.items() if i[0].startswith('user_') and i[1] == '1']
+    users = [i[0].split('_')[1] for i in list(request.REQUEST.items()) if i[0].startswith('user_') and i[1] == '1']
     #print users
     if len(users) >  0:
         filters['userID__in'] = users
@@ -136,7 +136,7 @@
     structures = list(set([l.structure for l in Labelling.objects.all()]))
     structures.sort()
 
-    structure = [i[0].split('_')[1] for i in request.REQUEST.items() if i[0].startswith('structure_') and i[1] == '1']
+    structure = [i[0].split('_')[1] for i in list(request.REQUEST.items()) if i[0].startswith('structure_') and i[1] == '1']
 
     if len(structure) >  0:
         filters['slideID__labelling__structure__in'] = structure
@@ -152,7 +152,7 @@
 
     tagnames = [t.name for t in TagName.objects.order_by('name')]
 
-    tags = [i[0].split('__')[1] for i in request.REQUEST.items() if i[0].startswith('tag__') and i[1] == '1']
+    tags = [i[0].split('__')[1] for i in list(request.REQUEST.items()) if i[0].startswith('tag__') and i[1] == '1']
     #print users
 #    if len(tags) >  0:
 #        filters['userID__in'] = users
@@ -192,7 +192,7 @@
     #    imgs = [i for i in imgs if i.HasTags(tags)]
 
     totalResultsNum = len(imgs)
-    startNums = range(0,totalResultsNum, numResults)
+    startNums = list(range(0,totalResultsNum, numResults))
     numResults = min(totalResultsNum, startNum + numResults) - startNum
 
     if not totalResultsNum == 0:
--- ./PYME/SampleDB/samples/migrations/0009_trans_dye.py	(original)
+++ ./PYME/SampleDB/samples/migrations/0009_trans_dye.py	(refactored)
@@ -34,16 +34,16 @@
         dyes = orm.Dye.objects.all()
         for lab in orm.Labelling.objects.all():
             n =  lab.label.upper()
-            print n
+            print(n)
 
             for d in dyes:
                #nominally n should be A680 or similar - people have also used things
                #like 'a680', '680', or 'A680 <some other crap>'
                #try to catch it all
-               print d.shortName
+               print(d.shortName)
                if n.startswith(d.shortName) or n.startswith(d.shortName[1:]):
                    lab.dye = d
-                   print lab.dye
+                   print(lab.dye)
 
 
             lab.save()
--- ./PYME/cSMI/__init__.py	(original)
+++ ./PYME/cSMI/__init__.py	(refactored)
@@ -21,4 +21,4 @@
 #
 ##################
 
-from cSMI import *
+from .cSMI import *
--- ./PYME/cSMI/cSMI.py	(original)
+++ ./PYME/cSMI/cSMI.py	(refactored)
@@ -14,7 +14,7 @@
         try:
             fp, pathname, description = imp.find_module('_cSMI', [dirname(__file__)])
         except ImportError:
-            import _cSMI
+            from . import _cSMI
             return _cSMI
         if fp is not None:
             try:
@@ -25,7 +25,7 @@
     _cSMI = swig_import_helper()
     del swig_import_helper
 else:
-    import _cSMI
+    from . import _cSMI
 del version_info
 try:
     _swig_property = property
--- ./PYME/cpmath/bg_compensate.py	(original)
+++ ./PYME/cpmath/bg_compensate.py	(refactored)
@@ -377,7 +377,7 @@
     from pylab import ceil,imshow,show
     import numpy,pylab
     from matplotlib.image import pil_to_array
-    from filter import canny
+    from .filter import canny
     import matplotlib
     import cProfile
 
@@ -395,7 +395,7 @@
         img_size.reverse()
         new_img = imgdata.reshape(img_size)
         # The magic # for maximum sample value is 281
-        if img.tag.has_key(281):
+        if 281 in img.tag:
             img = new_img.astype(np.float32) / img.tag[281][0]
         elif np.max(new_img) < 4096:
             img = new_img.astype(np.float32) / 4095.
@@ -423,7 +423,7 @@
     import time
     t0 = time.clock()
     bg = backgr(img, mask, MODE_AUTO, sigma, splinepoints=splinepoints, scale=scale)
-    print ("Executed in %f sec" % (time.clock() - t0))
+    print(("Executed in %f sec" % (time.clock() - t0)))
     bg[~mask] = img[~mask]
 
     pylab.subplot(1,3,2).imshow(img - bg, cmap=matplotlib.cm.Greys_r)
--- ./PYME/cpmath/convex_hull.py	(original)
+++ ./PYME/cpmath/convex_hull.py	(refactored)
@@ -105,10 +105,10 @@
         reordered[dest_start:dest_end, :] = out[src_start:src_end, :]
         reordered_idx += count
         reordered_counts[reordered_num] = count
-    print "OUT", out
-    print "C", vertex_counts
-    print "REO", reordered
-    print "RC", reordered_counts
+    print("OUT", out)
+    print("C", vertex_counts)
+    print("REO", reordered)
+    print("RC", reordered_counts)
     return reordered[:, [2, 0, 1]], reordered_counts
 
 def convex_hull(labels, indexes=None):
--- ./PYME/cpmath/cpmorphology.py	(original)
+++ ./PYME/cpmath/cpmorphology.py	(refactored)
@@ -19,9 +19,9 @@
 import scipy.ndimage as scind
 import scipy.sparse
 import _cpmorphology
-from outline import outline
-from rankorder import rank_order
-from index import Indexes
+from .outline import outline
+from .rankorder import rank_order
+from .index import Indexes
 from _cpmorphology2 import skeletonize_loop, table_lookup_index
 from _cpmorphology2 import grey_reconstruction_loop
 from _cpmorphology2 import _all_connected_components
@@ -551,7 +551,7 @@
     #
     # An array that converts from label # to index in "indexes"
     anti_indexes = np.zeros((np.max(indexes)+1,),int)
-    anti_indexes[indexes] = range(len(indexes))
+    anti_indexes[indexes] = list(range(len(indexes)))
 
     coords = pixel_labels[:,:2]
     i = coords[:, 0]
@@ -654,7 +654,7 @@
             # Map label #s to the index into indexes_to_finish of that label #
             #
             anti_indexes_to_finish = np.zeros((len(indexes),), np.int32)
-            anti_indexes_to_finish[indexes_to_finish] = range(len(indexes_to_finish))
+            anti_indexes_to_finish[indexes_to_finish] = list(range(len(indexes_to_finish)))
             #
             # Figure out the indices of each point in a label to be finished.
             # We figure out how much to subtract for each label, then
@@ -666,7 +666,7 @@
             finish_idx_base = np.zeros((len(indexes_to_finish),), np.int32)
             finish_idx_base[1:]=np.cumsum(new_counts[indexes_to_finish])[:-1]
             finish_idx_bases = finish_idx_base[anti_indexes_to_finish[atf_indexes]]
-            finish_idx = (np.array(range(a_to_finish.shape[0]))-
+            finish_idx = (np.array(list(range(a_to_finish.shape[0])))-
                           finish_idx_bases)
             finish_idx = finish_idx + result_index[atf_indexes]
             result[finish_idx,1:] = a_to_finish[:,1:]
@@ -690,12 +690,12 @@
         # to address those situations.
         #
         anti_indexes_to_keep = np.zeros((len(indexes),), np.int32)
-        anti_indexes_to_keep[indexes_to_keep] = range(len(indexes_to_keep))
+        anti_indexes_to_keep[indexes_to_keep] = list(range(len(indexes_to_keep)))
         idx_base = np.zeros((len(indexes_to_keep),), np.int32)
         idx_base[1:]=np.cumsum(counts[keep_me])[0:-1]
         idx_bases = idx_base[anti_indexes_to_keep[a[:,0]]]
         counts_per_pt = counts[a[:,0]]
-        idx = np.array(range(a.shape[0]), np.int32)-idx_bases
+        idx = np.array(list(range(a.shape[0])), np.int32)-idx_bases
         n_minus_one = np.mod(idx+counts_per_pt-1,counts_per_pt)+idx_bases
         n_plus_one  = np.mod(idx+1,counts_per_pt)+idx_bases
         #
@@ -761,7 +761,7 @@
     # points for a label, then only keep those whose indexes are
     # less than the count for their label.
     #
-    within_label_index = np.array(range(result.shape[0]), np.int32)
+    within_label_index = np.array(list(range(result.shape[0])), np.int32)
     counts_per_point = result_counts[r_anti_indexes_per_point]
     result_indexes_per_point = result_index[r_anti_indexes_per_point] 
     within_label_index = (within_label_index - result_indexes_per_point)
@@ -1097,7 +1097,7 @@
             indexes = np.array(np.unique(hull_and_point_count[0][:,0]),dtype=np.int32)
         else:
             max_label = np.max(labels)
-            indexes = np.array(range(1,max_label+1),dtype=np.int32)
+            indexes = np.array(list(range(1,max_label+1)),dtype=np.int32)
     else:
         indexes = np.array(indexes,dtype=np.int32)
     if indexes.shape[0] == 0:
@@ -1138,7 +1138,7 @@
     # anti_indexes_per_point gives the label index of any vertex
     #
     anti_indexes=np.zeros((np.max(indexes)+1,),int)
-    anti_indexes[indexes] = range(indexes.shape[0])
+    anti_indexes[indexes] = list(range(indexes.shape[0]))
     anti_indexes_per_point = anti_indexes[hull[:,0]]
     #
     # Start out by eliminating the degenerate cases: 0, 1 and 2
@@ -1170,7 +1170,7 @@
     # the order in which we'll get their angles. We use this to pick out
     # points # 2 to N which are the candidate vertices to S
     # 
-    within_label_indexes = (np.array(range(hull.shape[0]),int) -
+    within_label_indexes = (np.array(list(range(hull.shape[0])),int) -
                             point_index[anti_indexes_per_point])
     
     while(np.any(keep_me)):
@@ -1190,7 +1190,7 @@
         anti_indexes_to_consider =\
             np.zeros((np.max(labels_to_consider)+1,),int)
         anti_indexes_to_consider[labels_to_consider] = \
-            np.array(range(labels_to_consider.shape[0]))
+            np.array(list(range(labels_to_consider.shape[0])))
         ##############################################################
         # Vertex indexing for active vertexes other than S0 and S1
         ##############################################################
@@ -2062,7 +2062,7 @@
     # Given a label number "index_of_label" indexes into the result
     #
     index_of_label = np.zeros((hull[:,0].max()+1),int)
-    index_of_label[indexes] = np.array(range(indexes.shape[0]))
+    index_of_label[indexes] = np.array(list(range(indexes.shape[0])))
     #
     # hull_index is the index into hull of the first point on the hull
     # per label
@@ -2088,7 +2088,7 @@
     counts_nd = counts[counts>=3]
     indexes_nd = indexes[counts>=3]
     index_of_label_nd = np.zeros((index_of_label.shape[0],),int)
-    index_of_label_nd[indexes_nd] = np.array(range(indexes_nd.shape[0]))
+    index_of_label_nd[indexes_nd] = np.array(list(range(indexes_nd.shape[0])))
     #
     # Figure out the within-label index of each point in a label. This is
     # so we can do modulo arithmetic when pairing a point with the next
@@ -2099,7 +2099,7 @@
         hull_index_nd[1:] = np.cumsum(counts_nd[:-1])
     index_of_label_per_pixel_nd = index_of_label_nd[hull_nd[:,0]]
     hull_index_per_pixel_nd = hull_index_nd[index_of_label_per_pixel_nd] 
-    within_label_index = (np.array(range(hull_nd.shape[0])) -
+    within_label_index = (np.array(list(range(hull_nd.shape[0]))) -
                           hull_index_per_pixel_nd)
     #
     # Find some point within each convex hull.
@@ -2138,7 +2138,7 @@
     # from point n to point n+1 (modulo count) to the point within
     # the hull.
     #
-    plus_one_idx = np.array(range(hull_nd.shape[0]))+1
+    plus_one_idx = np.array(list(range(hull_nd.shape[0])))+1
     modulo_mask = within_label_index+1 == counts_nd[index_of_label_per_pixel_nd]
     plus_one_idx[modulo_mask] = hull_index_per_pixel_nd[modulo_mask]
     area_per_pt_nd = triangle_areas(hull_nd[:,1:],
@@ -2305,7 +2305,7 @@
     i = (i * multiplier[0]).astype(int)
     j = (j * multiplier[1]).astype(int)
     labels = i * ijmax[1] + j
-    indexes = np.array(range(np.product(ijmax)))
+    indexes = np.array(list(range(np.product(ijmax))))
     return labels, indexes
 
 def white_tophat(image, radius=None, mask=None, footprint=None):
--- ./PYME/cpmath/filter.py	(original)
+++ ./PYME/cpmath/filter.py	(refactored)
@@ -17,17 +17,17 @@
 import numpy as np
 import itertools
 import _filter
-from rankorder import rank_order
+from .rankorder import rank_order
 import scipy.ndimage as scind
 from scipy.ndimage import map_coordinates, label
 from scipy.ndimage import convolve, correlate1d, gaussian_filter
 from scipy.ndimage import binary_dilation, binary_erosion
 from scipy.ndimage import generate_binary_structure
-from smooth import smooth_with_function_and_mask
-from cpmorphology import fixup_scipy_ndimage_result as fix
-from cpmorphology import centers_of_labels
-from cpmorphology import grey_erosion, grey_reconstruction
-from cpmorphology import convex_hull_ijv, get_line_pts
+from .smooth import smooth_with_function_and_mask
+from .cpmorphology import fixup_scipy_ndimage_result as fix
+from .cpmorphology import centers_of_labels
+from .cpmorphology import grey_erosion, grey_reconstruction
+from .cpmorphology import convex_hull_ijv, get_line_pts
 
 '''# of points handled in the first pass of the convex hull code'''
 CONVEX_HULL_CHUNKSIZE = 250000
@@ -1176,7 +1176,7 @@
     for i in range(1,result_fwd.shape[0]):
         result_fwd[i] += result_fwd[i-1] * decay
     result_rev = smoothed.copy()
-    for i in reversed(range(result_rev.shape[0]-1)):
+    for i in reversed(list(range(result_rev.shape[0]-1))):
         result_rev[i] += result_rev[i+1] * decay
     result = (result_fwd - result_rev) / 2
     #
--- ./PYME/cpmath/haralick.py	(original)
+++ ./PYME/cpmath/haralick.py	(refactored)
@@ -17,7 +17,7 @@
 import scipy.ndimage as scind
 from scipy.linalg import toeplitz
 
-from cpmorphology import fixup_scipy_ndimage_result as fix
+from .cpmorphology import fixup_scipy_ndimage_result as fix
 
 def minimum(input, labels, index):
     return fix(scind.minimum(input, labels, index))
@@ -261,7 +261,7 @@
     mask = image > 30
     labels = scipy.ndimage.label(mask)[0]
     h = Haralick(image, labels, 3)
-    print h
+    print(h)
 
 if __name__ == '__main__':
     gray = np.array([[0,0,1,1],[0,0,1,1],[0,2,2,2],[2,2,3,3]], dtype=float)
--- ./PYME/cpmath/lapjv.py	(original)
+++ ./PYME/cpmath/lapjv.py	(refactored)
@@ -313,7 +313,7 @@
         cc[i,jj[idx[i]:(idx[i]+count[i])]] = c[idx[i]:(idx[i]+count[i])]
     c = cc
     for i in ii:
-        print "Processing i=%d" % i
+        print("Processing i=%d" % i)
         j = jj[idx[i]:(idx[i] + count[i])]
         d = c[i,:] - v
         pred = np.ones(n, int) * i
@@ -323,12 +323,12 @@
         to_do = list(range(n))
         try:
             while True:
-                print "Evaluating i=%d, n_scan = %d" % (i, len(scan))
+                print("Evaluating i=%d, n_scan = %d" % (i, len(scan)))
                 if len(scan) == 0:
                     ready += on_deck
                     on_deck = []
                     umin = np.min([d[jjj] for jjj in to_do])
-                    print "umin = %f" % umin
+                    print("umin = %f" % umin)
                     scan = [jjj for jjj in to_do if d[jjj] == umin]
                     to_do = [jjj for jjj in to_do if d[jjj] != umin]
                     for j1 in scan:
@@ -336,34 +336,34 @@
                             raise StopIteration()
                 j1 = scan[0]
                 iii = y[j1]
-                print "Consider replacing i=%d, j=%d" % (iii, j1)
+                print("Consider replacing i=%d, j=%d" % (iii, j1))
                 scan = scan[1:]
                 on_deck += [j1]
                 u1 = c[iii, j1] - v[j1] - umin
                 for j1 in list(to_do):
                     h = c[iii, j1] - v[j1] - u1
-                    print "Consider j=%d as replacement, c[%d,%d]=%f,v[%d]=%f,h=%f, d[j]= %f" % (j1,iii,j1,c[iii,j1],j1,v[j1],h,d[j1])
+                    print("Consider j=%d as replacement, c[%d,%d]=%f,v[%d]=%f,h=%f, d[j]= %f" % (j1,iii,j1,c[iii,j1],j1,v[j1],h,d[j1]))
                     if h < d[j1]:
-                        print "Add to chain"
+                        print("Add to chain")
                         pred[j1] = iii
                         if h == umin:
                             if y[j1] == n:
                                 raise StopIteration()
-                            print "Add to scan"
+                            print("Add to scan")
                             scan += [j1]
                             to_do.remove(j1)
                         d[j1] = h
 
         except StopIteration:
             # Augment
-            print "Augmenting %d" % j1
+            print("Augmenting %d" % j1)
             for k in ready:
                 temp = v[k]
                 v[k] = v[k] + d[k] - umin
-                print "v[%d] %f -> %f" % (k, temp, v[k])
+                print("v[%d] %f -> %f" % (k, temp, v[k]))
             while True:
                 iii = pred[j1]
-                print "y[%d] %d -> %d" % (j1, y[j1], iii)
+                print("y[%d] %d -> %d" % (j1, y[j1], iii))
                 y[j1] = iii
                 j1, x[iii] = x[iii], j1
                 if iii == i:
--- ./PYME/cpmath/threshold.py	(original)
+++ ./PYME/cpmath/threshold.py	(refactored)
@@ -24,9 +24,9 @@
 import scipy.sparse
 import scipy.interpolate
 
-from otsu import otsu, entropy, otsu3, entropy3
-from smooth import smooth_with_noise
-from filter import stretch, unstretch
+from .otsu import otsu, entropy, otsu3, entropy3
+from .smooth import smooth_with_noise
+from .filter import stretch, unstretch
 
 TM_OTSU                         = "Otsu"
 TM_OTSU_GLOBAL                  = "Otsu Global"
@@ -313,7 +313,7 @@
             labels[np.logical_not(mask)] = 0 
     label_extents = scipy.ndimage.find_objects(labels,np.max(labels))
     local_threshold = np.ones(image.shape,image.dtype)
-    for i,extent in zip(range(1,len(label_extents)+1),label_extents):
+    for i,extent in zip(list(range(1,len(label_extents)+1)),label_extents):
         label_mask = labels[extent]==i
         if not mask is None:
             label_mask = np.logical_and(mask[extent], label_mask)
@@ -462,7 +462,7 @@
     # Construct an equally spaced array of values between the background
     # and object mean
     ndivisions = 10000
-    level = (np.array(range(ndivisions)) *
+    level = (np.array(list(range(ndivisions))) *
              ((class_mean[2]-class_mean[0]) / ndivisions)
              + class_mean[0])
     class_gaussian = np.ndarray((ndivisions,class_count))
@@ -588,7 +588,7 @@
                                         max_log_image,
                                         256)
     histogram_values = (min_log_image + (max_log_image - min_log_image)*
-                        np.array(range(256),float) / 255)
+                        np.array(list(range(256)),float) / 255)
     # drop any zero bins
     keep = histogram != 0
     histogram = histogram[keep]
@@ -794,7 +794,7 @@
 
 def numpy_histogram(a, bins=10, range=None, normed=False, weights=None):
     '''A version of numpy.histogram that accounts for numpy's version'''
-    args = inspect.getargs(np.histogram.func_code)[0]
+    args = inspect.getargs(np.histogram.__code__)[0]
     if args[-1] == "new":
         return np.histogram(a, bins, range, normed, weights, new=True)
     return np.histogram(a, bins, range, normed, weights)
--- ./PYME/cpmath/watershed.py	(original)
+++ ./PYME/cpmath/watershed.py	(refactored)
@@ -32,7 +32,7 @@
 from _heapq import heapify, heappush, heappop
 import numpy
 import scipy.ndimage
-from rankorder import rank_order
+from .rankorder import rank_order
 
 import _watershed
 
@@ -70,7 +70,7 @@
     ncoords= coords.shape[0]
     if ncoords > 0:
         pixels = image[markers != 0]
-        age    = numpy.array(range(ncoords))
+        age    = numpy.array(list(range(ncoords)))
         offset = numpy.zeros(coords.shape[0],int)
         for i in range(image.ndim):
             offset = offset + stride[i]*coords[:,i]
@@ -157,10 +157,10 @@
     else:
         c_connectivity = numpy.array(connectivity,bool)
         if c_connectivity.ndim != image.ndim:
-            raise ValueError,"Connectivity dimension must be same as image"
+            raise ValueError("Connectivity dimension must be same as image")
     if offset == None:
         if any([x%2==0 for x in c_connectivity.shape]):
-            raise ValueError,"Connectivity array must have an unambiguous center"
+            raise ValueError("Connectivity array must have an unambiguous center")
         #
         # offset to center of connectivity array
         #
@@ -184,17 +184,16 @@
     c_image = rank_order(image)[0].astype(numpy.int32)
     c_markers = numpy.ascontiguousarray(markers,dtype=numpy.int32)
     if c_markers.ndim!=c_image.ndim:
-        raise ValueError,\
-            "markers (ndim=%d) must have same # of dimensions "\
-            "as image (ndim=%d)"%(c_markers.ndim, c_image.ndim)
+        raise ValueError("markers (ndim=%d) must have same # of dimensions "\
+            "as image (ndim=%d)"%(c_markers.ndim, c_image.ndim))
     if not all([x==y for x,y in zip(c_markers.shape, c_image.shape)]):
         raise ValueError("image and markers must have the same shape")
     if mask!=None:
         c_mask = numpy.ascontiguousarray(mask,dtype=bool)
         if c_mask.ndim!=c_markers.ndim:
-            raise ValueError, "mask must have same # of dimensions as image"
+            raise ValueError("mask must have same # of dimensions as image")
         if not all([x==y for x,y in zip(c_markers.shape, c_mask.shape)]):
-            raise ValueError, "mask must have same shape as image"
+            raise ValueError("mask must have same shape as image")
         c_markers[numpy.logical_not(mask)]=0
     else:
         c_mask = None
--- ./PYME/cpmath/zernike.py	(original)
+++ ./PYME/cpmath/zernike.py	(refactored)
@@ -18,8 +18,8 @@
 import numpy as np
 import scipy.sparse
 import scipy.ndimage
-from cpmorphology import minimum_enclosing_circle,fixup_scipy_ndimage_result
-from cpmorphology import fill_labeled_holes,draw_line
+from .cpmorphology import minimum_enclosing_circle,fixup_scipy_ndimage_result
+from .cpmorphology import fill_labeled_holes,draw_line
 
 def construct_zernike_lookuptable(zernike_indexes):
     """Return a lookup table of the sum-of-factorial part of the radial
@@ -29,10 +29,10 @@
                       computed.
     """
     factorial = np.ones((100,))
-    factorial[1:] = np.cumproduct(range(1,100))
+    factorial[1:] = np.cumproduct(list(range(1,100)))
     width = int(np.max(zernike_indexes[:,0]) / 2+1)
     lut = np.zeros((zernike_indexes.shape[0],width))
-    for idx,(n,m) in zip(range(zernike_indexes.shape[0]),zernike_indexes):
+    for idx,(n,m) in zip(list(range(zernike_indexes.shape[0])),zernike_indexes):
         for k in range(0,(n-m)/2+1):
             lut[idx,k] = \
                 (((-1)**k) * factorial[n-k] /
@@ -64,9 +64,9 @@
     zf = np.zeros((x.shape[0], nzernikes), np.complex)
     s = np.zeros(x.shape,np.complex)
     exp_terms = {}
-    for idx,(n,m) in zip(range(nzernikes), zernike_indexes):
+    for idx,(n,m) in zip(list(range(nzernikes)), zernike_indexes):
         s[:]=0
-        if not exp_terms.has_key(m):
+        if m not in exp_terms:
             exp_terms[m] = np.exp(1j*m*phi)
         exp_term = exp_terms[m]
         for k in range((n-m)/2+1):
--- ./PYME/cpmath/tests/test_cpmorphology.py	(original)
+++ ./PYME/cpmath/tests/test_cpmorphology.py	(refactored)
@@ -60,7 +60,7 @@
                    ((0,10),(15,25),(0,3),(18,22)),
                    ((15,25),(30,39),(18,22),(36,39)),
                    ((30,39),(15,25),(36,39),(18,22)))
-        for idx,x in zip(range(1,len(objects)+1),objects):
+        for idx,x in zip(list(range(1,len(objects)+1)),objects):
             image[x[0][0]:x[0][1],x[1][0]:x[1][1]] = idx
             image[x[2][0]:x[2][1],x[3][0]:x[3][1]] = 0
         output = morph.fill_labeled_holes(image)
@@ -297,7 +297,7 @@
         filled_labels = morph.fill_labeled_holes(labels)
         input = filled_labels > 0
         result = morph.binary_shrink(input)
-        my_sum = scind.sum(result.astype(int),filled_labels,np.array(range(nlabels+1),dtype=np.int32))
+        my_sum = scind.sum(result.astype(int),filled_labels,np.array(list(range(nlabels+1)),dtype=np.int32))
         my_sum = np.array(my_sum)
         self.assertTrue(np.all(my_sum[1:] == 1))
         
@@ -545,7 +545,7 @@
         ct = 20
         labels = np.zeros((side,side),int)
         pts = np.zeros((s*s*ct,2),int)
-        index = np.array(range(pts.shape[0])).astype(float)/float(ct)
+        index = np.array(list(range(pts.shape[0]))).astype(float)/float(ct)
         index = index.astype(int)
         idx = 0
         for i in range(0,side,mini_side):
@@ -581,7 +581,7 @@
                 for k in range(ct):
                     morph.draw_line(labels, p[k,:], p[(k+1)%ct,:], idx)
         self.assertTrue(labels[5,106]==5)
-        result,counts = morph.convex_hull(labels,np.array(range(100))+1)
+        result,counts = morph.convex_hull(labels,np.array(list(range(100)))+1)
         self.assertFalse(np.any(np.logical_and(result[:,1]==5,
                                                      result[:,2]==106)))
     
@@ -769,7 +769,7 @@
         while n_multi_edge < 10:
             labels = np.zeros((side,side),int)
             pts = np.zeros((s*s*ct,2),int)
-            index = np.array(range(pts.shape[0])).astype(float)/float(ct)
+            index = np.array(list(range(pts.shape[0]))).astype(float)/float(ct)
             index = index.astype(int)
             idx = 0
             for i in range(0,side,mini_side):
@@ -805,7 +805,7 @@
                     for k in range(ct):
                         morph.draw_line(labels, p[k,:], p[(k+1)%ct,:], idx)
             center,radius = morph.minimum_enclosing_circle(labels, 
-                                                           np.array(range(s**2))+1)
+                                                           np.array(list(range(s**2)))+1)
             epsilon = .000001
             center_per_pt = center[index]
             radius_per_pt = radius[index]
@@ -818,7 +818,7 @@
             pt_on_edge = np.abs(distance_from_center - radius_per_pt)<epsilon
             count_pt_on_edge = scind.sum(pt_on_edge,
                                                  index,
-                                                 np.array(range(s**2),dtype=np.int32))
+                                                 np.array(list(range(s**2)),dtype=np.int32))
             count_pt_on_edge = np.array(count_pt_on_edge)
             #
             # Every dodecagon must have at least 2 points on the edge.
--- ./PYME/cpmath/tests/test_propagate.py	(original)
+++ ./PYME/cpmath/tests/test_propagate.py	(refactored)
@@ -129,10 +129,10 @@
         x_coords = numpy.random.uniform(low=0, high=1000,size=(300,)).astype(int)
         y_coords = numpy.random.uniform(low=0, high=1000,size=(300,)).astype(int)
         labels = numpy.zeros((1000,1000),dtype=int)
-        labels[x_coords,y_coords]=numpy.array(range(300))+1
+        labels[x_coords,y_coords]=numpy.array(list(range(300)))+1
         mask = numpy.ones((1000,1000),bool)
         t1 = time.clock() 
         result,distances = cellprofiler.cpmath.propagate.propagate(image, labels, mask, 1.0)
         t2 = time.clock()
-        print "Running time: %f sec"%(t2-t1)
+        print("Running time: %f sec"%(t2-t1))
         
--- ./PYME/cpmath/tests/test_watershed.py	(original)
+++ ./PYME/cpmath/tests/test_watershed.py	(refactored)
@@ -387,9 +387,9 @@
         before = time.clock() 
         out = fast_watershed(image,markers,self.eight)
         elapsed = time.clock()-before
-        print "Fast watershed ran a megapixel image in %f seconds"%(elapsed)
+        print("Fast watershed ran a megapixel image in %f seconds"%(elapsed))
         before = time.clock()
         out = scipy.ndimage.watershed_ift(image.astype(numpy.uint16), markers, self.eight)
         elapsed = time.clock()-before
-        print "Scipy watershed ran a megapixel image in %f seconds"%(elapsed)
-
+        print("Scipy watershed ran a megapixel image in %f seconds"%(elapsed))
+
--- ./PYME/dataBrowser/manage.py	(original)
+++ ./PYME/dataBrowser/manage.py	(refactored)
@@ -24,7 +24,7 @@
 #!/usr/bin/python
 from django.core.management import execute_manager
 try:
-    import settings # Assumed to be in the same directory.
+    from . import settings # Assumed to be in the same directory.
 except ImportError:
     import sys
     sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
--- ./PYME/gohlke/czifile.py	(original)
+++ ./PYME/gohlke/czifile.py	(refactored)
@@ -94,7 +94,7 @@
 
 """
 
-from __future__ import division, print_function
+
 
 import sys
 import os
@@ -112,7 +112,7 @@
 import numpy
 from scipy.ndimage.interpolation import zoom
 
-from tifffile import decodelzw, lazyattr, stripnull
+from .tifffile import decodelzw, lazyattr, stripnull
 
 try:
     import _czifile
@@ -195,7 +195,7 @@
             self._fh.close()
             raise
 
-        if multifile and self.header.file_part and isinstance(arg, basestring):
+        if multifile and self.header.file_part and isinstance(arg, str):
             # open master file instead
             self._fh.close()
             name, _ = match_filename(arg)
@@ -430,7 +430,7 @@
             is used.
 
         """
-        if isinstance(arg, basestring):  # file name
+        if isinstance(arg, str):  # file name
             filename = os.path.abspath(arg)
             self.path, self.name = os.path.split(filename)
             self._fh = open(filename, mode)
@@ -603,7 +603,7 @@
         if raw:
             return data
         data = data.replace(b'\r\n', b'\n').replace(b'\r', b'\n')
-        return unicode(data, 'utf-8')
+        return str(data, 'utf-8')
 
     def __str__(self):
         return "MetadataSegment\n %s" % self.data()
@@ -637,7 +637,7 @@
     def metadata(self):
         """Read metadata from file and return as XML string."""
         self._fh.seek(self.data_offset - self.metadata_size)
-        return unicode(self._fh.read(self.metadata_size), 'utf-8')
+        return str(self._fh.read(self.metadata_size), 'utf-8')
 
     def data(self, raw=False, bgr2rgb=True, resize=True, order=1):
         """Read image data from file and return as numpy array."""
@@ -926,14 +926,14 @@
             raise ValueError("not a AttachmentEntryA1")
         self.content_guid = uuid.UUID(bytes=content_guid)
         self.content_file_type = stripnull(content_file_type)
-        self.name = unicode(stripnull(name), 'utf-8')
+        self.name = str(stripnull(name), 'utf-8')
         self._fh = fh
 
     @property
     def filename(self):
         """Return unique file name for attachment."""
         return "%s@%i.%s" % (self.name, self.file_position,
-                             unicode(self.content_file_type, 'utf-8').lower())
+                             str(self.content_file_type, 'utf-8').lower())
 
     def data_segment(self):
         """Read and return AttachmentSegment at file_position."""
@@ -1094,7 +1094,7 @@
          description_size,
          ) = struct.unpack('<idii', fh.read(20))
         description = stripnull(fh.read(description_size))
-        self.description = unicode(description, 'utf-8')
+        self.description = str(description, 'utf-8')
 
     def __str__(self):
         return "%s @ %s (%s)" % (EventListEntry.EV_TYPE[self.event_type],
@@ -1130,7 +1130,7 @@
 
     def __init__(self, fh):
         size, identifier, number = struct.unpack('<i80si', fh.read(88))
-        self.identifier = unicode(stripnull(identifier), 'utf-8')
+        self.identifier = str(stripnull(identifier), 'utf-8')
         self.components = [ComponentEntry(fh) for _ in range(number)]
 
     def __len__(self):
@@ -1168,7 +1168,7 @@
 
 def xml_reader(fh, filesize):
     """Read XML from file and return as xml.ElementTree root Element."""
-    xml = unicode(stripnull(fh.read(filesize)), 'utf-8')
+    xml = str(stripnull(fh.read(filesize)), 'utf-8')
     return etree.fromstring(xml)
 
 
@@ -1186,7 +1186,7 @@
     fd, filename = tempfile.mkstemp(suffix='.jxr')
     with os.fdopen(fd, 'wb') as fh:
         fh.write(data)
-    if isinstance(filename, unicode):
+    if isinstance(filename, str):
         filename = filename.encode('ascii')
     try:
         out = _czifile.decodejxr(filename)
@@ -1280,8 +1280,8 @@
     DECOMPRESS[4] = decodejxr
 
 if sys.version_info[0] > 2:
-    unicode = str
-    basestring = str, bytes
+    str = str
+    str = str, bytes
 
 if __name__ == "__main__":
     import doctest
--- ./PYME/gohlke/fcsfiles.py	(original)
+++ ./PYME/gohlke/fcsfiles.py	(refactored)
@@ -61,7 +61,7 @@
 
 """
 
-from __future__ import division, print_function
+
 
 import os
 import struct
@@ -178,7 +178,7 @@
             if isinstance(value, dict):
                 result.append("%sBEGIN %s%s %i" % (
                     indent, key, index, value['_value']))
-                for k, v in sorted(value.items(), key=sortkey):
+                for k, v in sorted(list(value.items()), key=sortkey):
                     append(k, v, indent+'\t')
                 result.append("%sEND" % indent)
             elif isinstance(value, (list, tuple)):
@@ -208,7 +208,7 @@
                 return '~~~' + key
             return key
 
-        for key, val in sorted(self.items(), key=sortkey):
+        for key, val in sorted(list(self.items()), key=sortkey):
             append(key, val)
         return '\n'.join(result)
 
--- ./PYME/gohlke/tifffile.py	(original)
+++ ./PYME/gohlke/tifffile.py	(refactored)
@@ -112,7 +112,7 @@
 
 """
 
-from __future__ import division, print_function
+
 
 import sys
 import os
@@ -480,7 +480,7 @@
         """Close open file handle(s)."""
         if not hasattr(self, 'tiffs'):
             return
-        for tif in self._tiffs.values():
+        for tif in list(self._tiffs.values()):
             if tif._fd:
                 tif._fd.close()
                 tif._fd = None
@@ -663,10 +663,10 @@
                                 newaxis = along.attrib.get('Type', 'other')
                                 newaxis = AXES_LABELS[newaxis]
                                 if 'Start' in along.attrib:
-                                    labels = range(
+                                    labels = list(range(
                                         int(along.attrib['Start']),
                                         int(along.attrib['End']) + 1,
-                                        int(along.attrib.get('Step', 1)))
+                                        int(along.attrib.get('Step', 1))))
                                 else:
                                     labels = [label.text for label in along
                                               if label.tag.endswith('Label')]
@@ -718,7 +718,7 @@
                                      dtype=numpy.dtype(ifds[0].dtype)))
 
         for record in result:
-            for axis, (newaxis, labels) in modulo.items():
+            for axis, (newaxis, labels) in list(modulo.items()):
                 i = record.axes.index(axis)
                 size = len(labels)
                 if record.shape[i] == size:
@@ -884,7 +884,7 @@
             tags[tag.name] = tag
 
         # read custom tags
-        for name, readtag in CUSTOM_TAGS.values():
+        for name, readtag in list(CUSTOM_TAGS.values()):
             if name in tags and readtag:
                 pos = fd.tell()
                 value = readtag(fd, byte_order, tags[name])
@@ -896,7 +896,7 @@
         # read LSM info subrecords
         if self.is_lsm:
             pos = fd.tell()
-            for name, reader in CZ_LSM_INFO_READERS.items():
+            for name, reader in list(CZ_LSM_INFO_READERS.items()):
                 try:
                     offset = self.cz_lsm_info["offset_"+name]
                 except KeyError:
@@ -917,7 +917,7 @@
 
         """
         tags = self.tags
-        for code, (name, default, dtype, count, validate) in TIFF_TAGS.items():
+        for code, (name, default, dtype, count, validate) in list(TIFF_TAGS.items()):
             if not (name in tags or default is None):
                 tags[name] = TIFFtag(code, dtype=dtype, count=count,
                                      value=default, name=name)
@@ -1413,7 +1413,7 @@
         s = []
         #sortbycode = lambda a, b: cmp(a.code, b.code)
         #for tag in sorted(self.values(), sortbycode):
-        for tag in sorted(self.values(), key=lambda x: x.code):
+        for tag in sorted(list(self.values()), key=lambda x: x.code):
             typecode = "%i%s" % (tag.count * int(tag.dtype[0]), tag.dtype[1])
             line = "* %i %s (%s) %s" % (tag.code, tag.name, typecode,
                                         str(tag.value).split('\n', 1)[0])
@@ -2009,7 +2009,7 @@
     'V': 'event',
     'O': 'other'}
 
-AXES_LABELS.update(dict((v, k) for k, v in AXES_LABELS.items()))
+AXES_LABELS.update(dict((v, k) for k, v in list(AXES_LABELS.items())))
 
 # MetaMorph STK tags
 MM_TAG_IDS = {
--- ./PYME/mProfile/__init__.py	(original)
+++ ./PYME/mProfile/__init__.py	(refactored)
@@ -1 +1 @@
-from mProfile import *
+from .mProfile import *
--- ./PYME/mProfile/colorize_db_t.py	(original)
+++ ./PYME/mProfile/colorize_db_t.py	(refactored)
@@ -29,7 +29,7 @@
 
 
 # Imports
-import cgi, string, sys, cStringIO
+import cgi, string, sys, io
 import keyword, token, tokenize
 
 
@@ -144,12 +144,12 @@
 
         # parse the source and write it
         self.pos = 0
-        text = cStringIO.StringIO(self.raw)
+        text = io.StringIO(self.raw)
         self.out.write(self.stylesheet)
         self.out.write('<pre class="code">\n')
         try:
             tokenize.tokenize(text.readline, self)
-        except tokenize.TokenError, ex:
+        except tokenize.TokenError as ex:
             msg = ex[0]
             line = ex[1][0]
             self.out.write("<h3>ERROR: %s</h3>%s\n" % (
@@ -159,12 +159,14 @@
                 self.cover_flag = False
         self.out.write('\n</pre>')
 
-    def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):
+    def __call__(self, toktype, toktext, xxx_todo_changeme, xxx_todo_changeme1, line):
         """ Token handler.
         """
+        (srow,scol) = xxx_todo_changeme
+        (erow,ecol) = xxx_todo_changeme1
         if 0:
-            print "type", toktype, token.tok_name[toktype], "text", toktext,
-            print "start", srow,scol, "end", erow,ecol, "<br>"
+            print("type", toktype, token.tok_name[toktype], "text", toktext, end=' ')
+            print("start", srow,scol, "end", erow,ecol, "<br>")
 
         # calculate new positions
         oldpos = self.pos
@@ -175,7 +177,7 @@
         if (not self.line_flag):
             #tspec = 'XXX.YYs'
             tspec =  '       ' + '       '
-            if (self.times.has_key(srow)):
+            if (srow in self.times):
                 #print srow
                 t = self.times[srow]
                 gb = 250*(1 - t/self.maxTime) 
--- ./PYME/mProfile/mProfile.py	(original)
+++ ./PYME/mProfile/mProfile.py	(refactored)
@@ -50,7 +50,7 @@
 import sys
 import time
 import os
-import colorize_db_t
+from . import colorize_db_t
 import webbrowser
 import tempfile
 import threading
@@ -63,7 +63,7 @@
         dict.__init__(self, *args)
 
     def __getitem__(self,key):
-        if self.has_key(key):
+        if key in self:
             return dict.__getitem__(self, key)
         else:
             return None
@@ -83,7 +83,7 @@
         dict.__init__(self, *args)
 
     def __getitem__(self,key):
-        if self.has_key(key):
+        if key in self:
             return dict.__getitem__(self, key)
         else:
             return 0
--- ./PYME/mProfile/p.py	(original)
+++ ./PYME/mProfile/p.py	(refactored)
@@ -24,7 +24,7 @@
 import sys
 import time
 import os
-import colorize_db_t
+from . import colorize_db_t
 import webbrowser
 
 #tPrev = time.time()
@@ -35,7 +35,7 @@
         dict.__init__(self, *args)
 
     def __getitem__(self,key):
-        if self.has_key(key):
+        if key in self:
             return dict.__getitem__(self, key)
         else:
             return None
@@ -52,7 +52,7 @@
         dict.__init__(self, *args)
 
     def __getitem__(self,key):
-        if self.has_key(key):
+        if key in self:
             return dict.__getitem__(self, key)
         else:
             return 0
--- ./PYME/mProfile/tProfile.py	(original)
+++ ./PYME/mProfile/tProfile.py	(refactored)
@@ -94,7 +94,7 @@
     def __init__(self):
         Thread.__init__(self)
     def run(self):                  # takes about 5 seconds
-        for i in xrange(10):
+        for i in range(10):
             self.test_method()
             test_function()
     def test_method(self):
@@ -103,10 +103,10 @@
 #profile_on('tProfile.py')
 #######################
 def runTests():
-    threads = [T() for i in xrange(3)]
+    threads = [T() for i in range(3)]
     for t in threads:
         t.start()
-    for i in xrange(10):
+    for i in range(10):
         test_function()
     for t in threads:
         t.join()
--- ./PYME/misc/TextCtrlAutoComplete.py	(original)
+++ ./PYME/misc/TextCtrlAutoComplete.py	(refactored)
@@ -10,7 +10,7 @@
 
 '''
 
-import locale, wx, sys, cStringIO
+import locale, wx, sys, io
 
 import  wx.lib.mixins.listctrl  as  listmix
 
@@ -29,7 +29,7 @@
     return BitmapFromImage(getSmallUpArrowImage())
 
 def getSmallUpArrowImage():
-    stream = cStringIO.StringIO(getSmallUpArrowData())
+    stream = io.StringIO(getSmallUpArrowData())
     return ImageFromStream(stream)
 
 
@@ -46,7 +46,7 @@
     return BitmapFromImage(getSmallDnArrowImage())
 
 def getSmallDnArrowImage():
-    stream = cStringIO.StringIO(getSmallDnArrowData())
+    stream = io.StringIO(getSmallDnArrowData())
     return ImageFromStream(stream)
 #----------------------------------------------------------------------
 
@@ -69,7 +69,7 @@
         by calling setChoices.
         '''
 
-        if therest.has_key('style'):
+        if 'style' in therest:
             therest['style']=wx.TE_PROCESS_ENTER | therest['style']
         else:
             therest['style']=wx.TE_PROCESS_ENTER
@@ -95,7 +95,7 @@
 
         #Load and sort data
         if not (self._multiChoices or self._choices):
-            raise ValueError, "Pass me at least one of multiChoices OR choices"
+            raise ValueError("Pass me at least one of multiChoices OR choices")
 
         #widgets
         self.dropdown = wx.PopupWindow( self )
@@ -195,7 +195,7 @@
             #load the sorted data into the listbox
             dd = self.dropdownlistbox
             choices = [dd.GetItem(x, self._colSearch).GetText()
-                for x in xrange(dd.GetItemCount())]
+                for x in range(dd.GetItemCount())]
         else:
             choices = self._choices
 
@@ -305,7 +305,7 @@
 
         lChoices = len(choices)
         if lChoices < 2:
-            raise ValueError, "You have to pass me a multi-dimension list"
+            raise ValueError("You have to pass me a multi-dimension list")
 
         for numCol, rowValues in enumerate(choices[0]):
 
@@ -318,7 +318,7 @@
 
             for numCol, colVal in enumerate(valRow):
                 if numCol == 0:
-                    index = self.dropdownlistbox.InsertImageStringItem(sys.maxint, colVal, -1)
+                    index = self.dropdownlistbox.InsertImageStringItem(sys.maxsize, colVal, -1)
                 self.dropdownlistbox.SetStringItem(index, numCol, colVal)
                 self.dropdownlistbox.SetItemData(index, numRow)
 
@@ -350,7 +350,7 @@
         self.dropdownlistbox.InsertColumn(0, "")
 
         for num, colVal in enumerate(self._choices):
-            index = self.dropdownlistbox.InsertImageStringItem(sys.maxint, colVal, -1)
+            index = self.dropdownlistbox.InsertImageStringItem(sys.maxsize, colVal, -1)
 
             self.dropdownlistbox.SetStringItem(index, 0, colVal)
             self.dropdownlistbox.SetItemData(index, num)
@@ -392,7 +392,7 @@
             if self._selectCallback:
                 dd = self.dropdownlistbox
                 values = [dd.GetItem(sel, x).GetText()
-                    for x in xrange(dd.GetColumnCount())]
+                    for x in range(dd.GetColumnCount())]
                 self._selectCallback( values )
 
             self.SetValue (itemtext)
@@ -575,7 +575,7 @@
         """ Simply function that receive the row values when the
             user select an item
         """
-        print "Select Callback called...:",  values
+        print("Select Callback called...:",  values)
 
 
 if __name__ == "__main__":
--- ./PYME/misc/TiffImagePlugin.py	(original)
+++ ./PYME/misc/TiffImagePlugin.py	(refactored)
@@ -227,11 +227,11 @@
     # dictionary API (sort of)
 
     def keys(self):
-        return self.tagdata.keys() + self.tags.keys()
+        return list(self.tagdata.keys()) + list(self.tags.keys())
 
     def items(self):
-        items = self.tags.items()
-        for tag in self.tagdata.keys():
+        items = list(self.tags.items())
+        for tag in list(self.tagdata.keys()):
             items.append((tag, self[tag]))
         return items
 
@@ -262,7 +262,7 @@
                     # work around broken (?) matrox library
                     # (from Ted Wright, via Bob Klimek)
                     raise KeyError # use default
-                raise ValueError, "not a scalar"
+                raise ValueError("not a scalar")
             return value[0]
         except KeyError:
             if default is None:
@@ -270,7 +270,7 @@
             return default
 
     def has_key(self, tag):
-        return self.tags.has_key(tag) or self.tagdata.has_key(tag)
+        return tag in self.tags or tag in self.tagdata
 
     def __setitem__(self, tag, value):
         if type(value) is not type(()):
@@ -352,14 +352,14 @@
                 import TiffTags
                 tagname = TiffTags.TAGS.get(tag, "unknown")
                 typname = TiffTags.TYPES.get(typ, "unknown")
-                print "tag: %s (%d)" % (tagname, tag),
-                print "- type: %s (%d)" % (typname, typ),
+                print("tag: %s (%d)" % (tagname, tag), end=' ')
+                print("- type: %s (%d)" % (typname, typ), end=' ')
 
             try:
                 dispatch = self.load_dispatch[typ]
             except KeyError:
                 if Image.DEBUG:
-                    print "- unsupported type", typ
+                    print("- unsupported type", typ)
                 continue # ignore unsupported type
 
             size, handler = dispatch
@@ -376,15 +376,15 @@
                 data = ifd[8:8+size]
 
             if len(data) != size:
-                raise IOError, "not enough data"
+                raise IOError("not enough data")
 
             self.tagdata[tag] = typ, data
 
             if Image.DEBUG:
                 if tag in (COLORMAP, IPTC_NAA_CHUNK, PHOTOSHOP_CHUNK):
-                    print "- value: <table: %d bytes>" % size
+                    print("- value: <table: %d bytes>" % size)
                 else:
-                    print "- value:", self[tag]
+                    print("- value:", self[tag])
 
         self.next = i32(fp.read(4))
 
@@ -398,7 +398,7 @@
         fp.write(o16(len(self.tags)))
 
         # always write in ascending tag order
-        tags = self.tags.items()
+        tags = list(self.tags.items())
         tags.sort()
 
         directory = []
@@ -414,8 +414,8 @@
             if Image.DEBUG:
                 import TiffTags
                 tagname = TiffTags.TAGS.get(tag, "unknown")
-                print "save: %s (%d)" % (tagname, tag),
-                print "- value:", value
+                print("save: %s (%d)" % (tagname, tag), end=' ')
+                print("- value:", value)
 
             if type(value[0]) is type(""):
                 # string data
@@ -436,9 +436,9 @@
                         if v >= 65536:
                             typ = 4
                 if typ == 3:
-                    data = string.join(map(o16, value), "")
+                    data = string.join(list(map(o16, value)), "")
                 else:
-                    data = string.join(map(o32, value), "")
+                    data = string.join(list(map(o32, value)), "")
 
             # figure out if data fits into the directory
             if len(data) == 4:
@@ -464,7 +464,7 @@
         # pass 2: write directory to file
         for tag, typ, count, value, data in directory:
             if Image.DEBUG > 1:
-                print tag, typ, count, repr(value), repr(data)
+                print(tag, typ, count, repr(value), repr(data))
             fp.write(o16(tag) + o16(typ) + o32(count) + value)
         fp.write("\0\0\0\0") # end of directory
 
@@ -491,7 +491,7 @@
         ifh = self.fp.read(8)
 
         if ifh[:4] not in PREFIXES:
-            raise SyntaxError, "not a TIFF file"
+            raise SyntaxError("not a TIFF file")
 
         # image file directory (tag dictionary)
         self.tag = self.ifd = ImageFileDirectory(ifh[:2])
@@ -525,10 +525,10 @@
             self.__next = self.__first
         while self.__frame < frame:
             if not self.__next:
-                raise EOFError, "no more images in TIFF file"
+                raise EOFError("no more images in TIFF file")
             self.fp.seek(self.__next)
             self.tag.load(self.fp)
-            self.__next = self.tag.next
+            self.__next = self.tag.__next__
             self.__frame = self.__frame + 1
         self._setup()
 
@@ -547,14 +547,14 @@
             args = (rawmode, 0, 1)
         elif compression == "jpeg":
             args = rawmode, ""
-            if self.tag.has_key(JPEGTABLES):
+            if JPEGTABLES in self.tag:
                 # Hack to handle abbreviated JPEG headers
                 self.tile_prefix = self.tag[JPEGTABLES]
         elif compression == "packbits":
             args = rawmode
         elif compression == "tiff_lzw":
             args = rawmode
-            if self.tag.has_key(317):
+            if 317 in self.tag:
                 # Section 14: Differencing Predictor
                 self.decoderconfig = (self.tag[PREDICTOR][0],)
 
@@ -563,8 +563,8 @@
     def _setup(self):
         "Setup this image object based on current tags"
 
-        if self.tag.has_key(0xBC01):
-            raise IOError, "Windows Media Photo files not yet supported"
+        if 0xBC01 in self.tag:
+            raise IOError("Windows Media Photo files not yet supported")
 
         getscalar = self.tag.getscalar
 
@@ -579,11 +579,11 @@
         fillorder = getscalar(FILLORDER, 1)
 
         if Image.DEBUG:
-            print "*** Summary ***"
-            print "- compression:", self._compression
-            print "- photometric_interpretation:", photo
-            print "- planar_configuration:", self._planar_configuration
-            print "- fill_order:", fillorder
+            print("*** Summary ***")
+            print("- compression:", self._compression)
+            print("- photometric_interpretation:", photo)
+            print("- planar_configuration:", self._planar_configuration)
+            print("- fill_order:", fillorder)
 
         # size
         xsize = getscalar(IMAGEWIDTH)
@@ -591,7 +591,7 @@
         self.size = xsize, ysize
 
         if Image.DEBUG:
-            print "- size:", self.size
+            print("- size:", self.size)
 
         format = getscalar(SAMPLEFORMAT, 1)
 
@@ -602,17 +602,17 @@
             self.tag.get(EXTRASAMPLES, ())
             )
         if Image.DEBUG:
-            print "format key:", key
+            print("format key:", key)
         try:
             self.mode, rawmode = OPEN_INFO[key]
         except KeyError:
             if Image.DEBUG:
-                print "- unsupported format"
-            raise SyntaxError, "unknown pixel mode"
+                print("- unsupported format")
+            raise SyntaxError("unknown pixel mode")
 
         if Image.DEBUG:
-            print "- raw mode:", rawmode
-            print "- pil mode:", self.mode
+            print("- raw mode:", rawmode)
+            print("- pil mode:", self.mode)
 
         self.info["compression"] = self._compression
 
@@ -633,7 +633,7 @@
         # build tile descriptors
         x = y = l = 0
         self.tile = []
-        if self.tag.has_key(STRIPOFFSETS):
+        if STRIPOFFSETS in self.tag:
             # striped image
             h = getscalar(ROWSPERSTRIP, ysize)
             w = self.size[0]
@@ -650,7 +650,7 @@
                     x = y = 0
                     l = l + 1
                     a = None
-        elif self.tag.has_key(TILEOFFSETS):
+        elif TILEOFFSETS in self.tag:
             # tiled image
             w = getscalar(322)
             h = getscalar(323)
@@ -673,7 +673,7 @@
                         a = None
         else:
             if Image.DEBUG:
-                print "- unsupported data organization"
+                print("- unsupported data organization")
             raise SyntaxError("unknown data organization")
 
         # fixup palette descriptor
@@ -681,10 +681,10 @@
         if self.mode == "P":
             #seb
             try:
-                palette = map(lambda a: chr(a // 256), self.tag[COLORMAP])
+                palette = [chr(a // 256) for a in self.tag[COLORMAP]]
             except KeyError:
                 pass # seb HACK !! for some Zeiss LSM files
-                palette = map(lambda a: chr(a // 256), range(256))
+                palette = [chr(a // 256) for a in range(256)]
             self.palette = ImagePalette.raw("RGB;L", string.join(palette, ""))
             #orig:
             #palette = map(lambda a: chr(a // 256), self.tag[COLORMAP])
@@ -734,7 +734,7 @@
     try:
         rawmode, byteorder, photo, format, bits, extra = SAVE_INFO[im.mode]
     except KeyError:
-        raise IOError, "cannot write mode %s as TIFF" % im.mode
+        raise IOError("cannot write mode %s as TIFF" % im.mode)
 
     ifd = ImageFileDirectory(BYTEORDER_TO_PREFIX[byteorder])
 
@@ -753,18 +753,18 @@
     if hasattr(im, 'tag'):
         # preserve tags from original TIFF image file
         for key in (RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION):
-            if im.tag.tagdata.has_key(key):
+            if key in im.tag.tagdata:
                 ifd[key] = im.tag.tagdata.get(key)
-    if im.encoderinfo.has_key("description"):
+    if "description" in im.encoderinfo:
         ifd[IMAGEDESCRIPTION] = im.encoderinfo["description"]
-    if im.encoderinfo.has_key("resolution"):
+    if "resolution" in im.encoderinfo:
         ifd[X_RESOLUTION] = ifd[Y_RESOLUTION] \
                                 = _cvt_res(im.encoderinfo["resolution"])
-    if im.encoderinfo.has_key("x resolution"):
+    if "x resolution" in im.encoderinfo:
         ifd[X_RESOLUTION] = _cvt_res(im.encoderinfo["x resolution"])
-    if im.encoderinfo.has_key("y resolution"):
+    if "y resolution" in im.encoderinfo:
         ifd[Y_RESOLUTION] = _cvt_res(im.encoderinfo["y resolution"])
-    if im.encoderinfo.has_key("resolution unit"):
+    if "resolution unit" in im.encoderinfo:
         unit = im.encoderinfo["resolution unit"]
         if unit == "inch":
             ifd[RESOLUTION_UNIT] = 2
@@ -772,13 +772,13 @@
             ifd[RESOLUTION_UNIT] = 3
         else:
             ifd[RESOLUTION_UNIT] = 1
-    if im.encoderinfo.has_key("software"):
+    if "software" in im.encoderinfo:
         ifd[SOFTWARE] = im.encoderinfo["software"]
-    if im.encoderinfo.has_key("date time"):
+    if "date time" in im.encoderinfo:
         ifd[DATE_TIME] = im.encoderinfo["date time"]
-    if im.encoderinfo.has_key("artist"):
+    if "artist" in im.encoderinfo:
         ifd[ARTIST] = im.encoderinfo["artist"]
-    if im.encoderinfo.has_key("copyright"):
+    if "copyright" in im.encoderinfo:
         ifd[COPYRIGHT] = im.encoderinfo["copyright"]
 
     dpi = im.encoderinfo.get("dpi")
@@ -800,7 +800,7 @@
 
     if im.mode == "P":
         lut = im.im.getpalette("RGB", "RGB;L")
-        ifd[COLORMAP] = tuple(map(lambda v: ord(v) * 256, lut))
+        ifd[COLORMAP] = tuple([ord(v) * 256 for v in lut])
 
     # data orientation
     stride = len(bits) * ((im.size[0]*bits[0]+7)/8)
@@ -817,7 +817,7 @@
 
 
     #seb -- multi-page -- 
-    if im.encoderinfo.has_key("_debug_multipage"):
+    if "_debug_multipage" in im.encoderinfo:
         #just to access o32 and o16 (using correct byte order)
         im._debug_multipage = ifd
 
--- ./PYME/misc/VolProj.py	(original)
+++ ./PYME/misc/VolProj.py	(refactored)
@@ -50,7 +50,7 @@
         self.isos = []
         self.projs = []
 
-        for im, th, i in zip(channels, thresholds, range(len(channels))):
+        for im, th, i in zip(channels, thresholds, list(range(len(channels)))):
             c = mlab.contour3d(im, contours=[th], color = pylab.cm.gist_rainbow(float(i)/len(channels))[:3])
             c.mlab_source.dataset.spacing = pixelsize
             self.isos.append(c)
--- ./PYME/misc/autoFoldPanel.py	(original)
+++ ./PYME/misc/autoFoldPanel.py	(refactored)
@@ -26,7 +26,7 @@
 from wx.lib.agw.aui.aui_utilities import BitmapFromBits
 
 def ColourFromStyle(col):
-    if type(col) in [str, unicode]:
+    if type(col) in [str, str]:
         col = wx.NamedColour(col)
     else:
         col = wx.Colour(*col)
@@ -185,9 +185,9 @@
 
         font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
         #print font.GetFaceName(), font.GetPointSize()
-        if 'FONT_WEIGHT' in self.style.keys():
+        if 'FONT_WEIGHT' in list(self.style.keys()):
             font.SetWeight(self.style['FONT_WEIGHT'])
-        if 'FONT_SIZE' in self.style.keys():
+        if 'FONT_SIZE' in list(self.style.keys()):
             font.SetPointSize(self.style['FONT_SIZE'])
             
         fc = ColourFromStyle(self.style['FONT_COLOUR'])
@@ -449,7 +449,7 @@
         self.bFold.Bind(wx.EVT_LEFT_UP, self.OnFold)
 
     def OnFold(self, event):
-        print 'fold'
+        print('fold')
         if self.folded:
             self.Unfold()
             self.bFold.SetFolded(False)
--- ./PYME/misc/colorsys.py	(original)
+++ ./PYME/misc/colorsys.py	(refactored)
@@ -131,7 +131,7 @@
     maxc = np.max([r, g, b],0)
     minc = np.min([r, g, b],0)
 
-    print maxc.shape
+    print(maxc.shape)
 
     v = maxc
     h = np.zeros(v.shape)
--- ./PYME/misc/computerName.py	(original)
+++ ./PYME/misc/computerName.py	(refactored)
@@ -24,7 +24,7 @@
 import sys
 
 def GetComputerName():
-    if 'PYME_COMPUTERNAME' in os.environ.keys():
+    if 'PYME_COMPUTERNAME' in list(os.environ.keys()):
         return os.environ['PYME_COMPUTERNAME']
     elif sys.platform == 'win32':
         return os.environ['COMPUTERNAME']
--- ./PYME/misc/congrid.py	(original)
+++ ./PYME/misc/congrid.py	(refactored)
@@ -58,9 +58,9 @@
     old = n.array( a.shape )
     ndims = len( a.shape )
     if len( newdims ) != ndims:
-        print "[congrid] dimensions error. " \
+        print("[congrid] dimensions error. " \
               "This routine currently only support " \
-              "rebinning to the same number of dimensions."
+              "rebinning to the same number of dimensions.")
         return None
     newdims = n.asarray( newdims, dtype=float )
     dimlist = []
@@ -87,7 +87,7 @@
         mint = scipy.interpolate.interp1d( olddims[-1], a, kind=method )
         newa = mint( dimlist[-1] )
 
-        trorder = [ndims - 1] + range( ndims - 1 )
+        trorder = [ndims - 1] + list(range( ndims - 1))
         for i in range( ndims - 2, -1, -1 ):
             newa = newa.transpose( trorder )
 
@@ -105,7 +105,7 @@
         nslices = [ slice(0,j) for j in list(newdims) ]
         newcoords = n.mgrid[nslices]
 
-        newcoords_dims = range(n.rank(newcoords))
+        newcoords_dims = list(range(n.rank(newcoords)))
         #make first index last
         newcoords_dims.append(newcoords_dims.pop(0))
         newcoords_tr = newcoords.transpose(newcoords_dims)
@@ -121,7 +121,7 @@
         newa = scipy.ndimage.map_coordinates(a, newcoords)
         return newa
     else:
-        print "Congrid error: Unrecognized interpolation type.\n", \
+        print("Congrid error: Unrecognized interpolation type.\n", \
               "Currently only \'neighbour\', \'nearest\',\'linear\',", \
-              "and \'spline\' are supported."
+              "and \'spline\' are supported.")
         return None
--- ./PYME/misc/diskCleanup.py	(original)
+++ ./PYME/misc/diskCleanup.py	(refactored)
@@ -42,7 +42,7 @@
             #print nFilename, bFilename
 
             if os.path.exists(nFilename) and os.path.getsize(nFilename) == os.path.getsize(filename): #and os.path.exists(bFilename) and os.path.getsize(filename) == os.path.getsize(nFilename):
-                print 'Deleting %s' % filename
+                print('Deleting %s' % filename)
                 try:
                     os.remove(filename)
                 except OSError:
@@ -50,13 +50,13 @@
                     traceback.print_exc()
                     
             else:
-                print 'Keeping %s' % filename
+                print('Keeping %s' % filename)
 
         for dir in dirs:
             dirname = os.path.join(path, dir)
 
             if len(os.listdir(dirname)) == 0 and not 'System Volume Information' in dirname:
-                print 'Removing %s' % dirname
+                print('Removing %s' % dirname)
                 os.rmdir(dirname)
 
 
--- ./PYME/misc/editgrid.py	(original)
+++ ./PYME/misc/editgrid.py	(refactored)
@@ -55,7 +55,7 @@
                 
     
     def tostring(self, selection=None):
-        from cStringIO import StringIO
+        from io import StringIO
         sb = StringIO()
         
         np.savetxt(sb, self.toarray(selection), delimiter='\t')
@@ -63,7 +63,7 @@
         return sb.getvalue()
         
     def setfromstring(self, data, x0=0, y0=0):
-        from cStringIO import StringIO
+        from io import StringIO
         #print repr(data)
         sb = StringIO(data.encode())
         
--- ./PYME/misc/eventSpy.py	(original)
+++ ./PYME/misc/eventSpy.py	(refactored)
@@ -98,7 +98,7 @@
     #global lastEvent
     #print event.GetEventType()
     lastEvents.append(eventInfo(event))
-    print lastEvents[-1]
+    print(lastEvents[-1])
     event.Skip()
 
 def InstallSpy(window):
--- ./PYME/misc/extraCMaps.py	(original)
+++ ./PYME/misc/extraCMaps.py	(refactored)
@@ -51,7 +51,7 @@
 
 ndat = {'r':_r, 'g':_g, 'b':_b, 'c':_c, 'm':_m, 'y':_y, 'hsp': _hsv_part}
 
-ncmapnames = ndat.keys()
+ncmapnames = list(ndat.keys())
 pylab.cm.cmapnames += ncmapnames
 for cmapname in ncmapnames:
     pylab.cm.__dict__[cmapname] = colors.LinearSegmentedColormap(cmapname, ndat[cmapname], pylab.cm.LUTSIZE)
--- ./PYME/misc/fbpIcons.py	(original)
+++ ./PYME/misc/fbpIcons.py	(refactored)
@@ -51,8 +51,8 @@
     return wx.BitmapFromImage(GetCollapsedIconImage())
 
 def GetCollapsedIconImage():
-    import cStringIO
-    stream = cStringIO.StringIO(GetCollapsedIconData())
+    import io
+    stream = io.StringIO(GetCollapsedIconData())
     return wx.ImageFromStream(stream)
 
 #----------------------------------------------------------------------
@@ -83,6 +83,6 @@
     return wx.BitmapFromImage(GetExpandedIconImage())
 
 def GetExpandedIconImage():
-    import cStringIO
-    stream = cStringIO.StringIO(GetExpandedIconData())
+    import io
+    stream = io.StringIO(GetExpandedIconData())
     return wx.ImageFromStream(stream)
--- ./PYME/misc/findCycles.py	(original)
+++ ./PYME/misc/findCycles.py	(refactored)
@@ -44,7 +44,7 @@
 
             outstream.write("   %s -- " % str(type(step)))
             if isinstance(step, dict):
-                for key, val in step.items():
+                for key, val in list(step.items()):
                     if val is next:
                         outstream.write("[%s]" % repr(key))
                         break
--- ./PYME/misc/glassModel.py	(original)
+++ ./PYME/misc/glassModel.py	(refactored)
@@ -58,7 +58,7 @@
 
     n = 0
 
-    for a, n in zip(args, range(len(args))):
+    for a, n in zip(args, list(range(len(args)))):
         n += a/(L2**n)
 
     return n
--- ./PYME/misc/hash32.py	(original)
+++ ./PYME/misc/hash32.py	(refactored)
@@ -23,7 +23,7 @@
 import numpy as np
 
 def c_mul(a, b):
-    return eval(hex((long(a) * b) & 0xFFFFFFFFL)[:-1])
+    return eval(hex((int(a) * b) & 0xFFFFFFFF)[:-1])
 
 
 def hashString32(s):
--- ./PYME/misc/hillcurve.py	(original)
+++ ./PYME/misc/hillcurve.py	(refactored)
@@ -47,7 +47,7 @@
 fit_results = FitModel(hill, [1, 2.7, 50, 1], ratio_control)
 p_control = fit_results[0]
 
-print '''
+print('''
 Control:
 ---------
 n = %3.2f
@@ -55,7 +55,7 @@
 Fmax = %3.2f
 Fmin = %3.2f
 
-''' % p_control
+''' % p_control)
 
 ratio = linspace(1.5, 4)
 plot(ratio, hill(p_control, ratio))
@@ -69,7 +69,7 @@
 fit_results = FitModel(hill, [1, 2.7, 50, 1], ratio_cptome)
 p_cptome = fit_results[0]
 
-print '''
+print('''
 CPTOME:
 ---------
 n = %3.2f
@@ -77,7 +77,7 @@
 Fmax = %3.2f
 Fmin = %3.2f
 
-''' % p_cptome
+''' % p_cptome)
 
 plot(ratio, hill(p_cptome, ratio))
 
--- ./PYME/misc/kdFit.py	(original)
+++ ./PYME/misc/kdFit.py	(refactored)
@@ -43,7 +43,7 @@
     semilogx(c, f, 'x')
     
     r = FitModel(efunc, [10, 1, 0, 1], f, c)
-    print '''
+    print('''
     Fit Results:
     --------------------
      R_bound   = %3.2f
@@ -51,7 +51,7 @@
      C50       = %3.3f
      sigma     = %3.2f
      
-     ''' % (r[0][0], r[0][1], 10**r[0][2], r[0][3])
+     ''' % (r[0][0], r[0][1], 10**r[0][2], r[0][3]))
         
     
     #print log10(c[0] + .01), log10(c[-1])
--- ./PYME/misc/listctrlMixins.py	(original)
+++ ./PYME/misc/listctrlMixins.py	(refactored)
@@ -64,7 +64,7 @@
         self.SetColumnCount(numColumns)
         list = self.GetListCtrl()
         if not list:
-            raise ValueError, "No wx.ListCtrl available"
+            raise ValueError("No wx.ListCtrl available")
         list.Bind(wx.EVT_LIST_COL_CLICK, self.__OnColClick, list)
 
 
@@ -161,7 +161,7 @@
 
         # If the items are equal then pick something else to make the sort value unique
         if cmpVal == 0:
-            cmpVal = apply(cmp, self.GetSecondarySortValues(col, key1, key2))
+            cmpVal = cmp(*self.GetSecondarySortValues(col, key1, key2))
 
         if ascending:
             return cmpVal
@@ -839,7 +839,7 @@
 
     def RefreshRows(self):
         """Re-color all the rows"""
-        for row in xrange(self.GetItemCount()):
+        for row in range(self.GetItemCount()):
             if self._defaultb is None:
                 self._defaultb = self.GetItemBackgroundColour(row)
 
--- ./PYME/misc/lzw.py	(original)
+++ ./PYME/misc/lzw.py	(refactored)
@@ -623,7 +623,7 @@
 
         try:
             while 1:
-                cp = codepoints.next()
+                cp = next(codepoints)
                 if cp != END_OF_INFO_CODE:
                     yield cp
                 else:
--- ./PYME/misc/optics.py	(original)
+++ ./PYME/misc/optics.py	(refactored)
@@ -57,14 +57,14 @@
         D = H.squareform(H.pdist(x, distMethod))
         distOK = True
     except:
-        print "squareform or pdist error"
+        print("squareform or pdist error")
         distOK = False
 
 
     CD = N.zeros(m)
     RD = N.ones(m)*1E10
 
-    for i in xrange(m):
+    for i in range(m):
         #again you can use the euclid function if you don't want hcluster
 #        d = euclid(x[i],x)
 #        d.sort()
@@ -109,7 +109,7 @@
     y += 1
     y *= i
     if len(x) != len(y):
-        raise ValueError, "vectors must be same length"
+        raise ValueError("vectors must be same length")
 
     d = (x-y)**2
     return N.sqrt(N.sum(d, axis = 1))
@@ -138,6 +138,6 @@
     testXOrdered = testX[order]
     P.plot(testXOrdered[:,0], testXOrdered[:,1], 'b-')
 	
-    print order
+    print(order)
 
     P.show()
--- ./PYME/misc/read_agf.py	(original)
+++ ./PYME/misc/read_agf.py	(refactored)
@@ -235,7 +235,7 @@
 
         f.close()
     else:
-        print('read_glasscat(): The input filename "' + glassdir + '" is not a valid file or directory.')
+        print(('read_glasscat(): The input filename "' + glassdir + '" is not a valid file or directory.'))
         sys.exit(1)
 
     return(glasscat)
@@ -294,8 +294,8 @@
         s = sigma_min + (sigma_max - sigma_min) * arange(nwaves) / (nwaves - 1.0)
         w = 1.0 / s
     else:
-        print('The sampling domain "' + sampling_domain + '" defined as input ' \
-              + 'to the "dispersion_data()" function is invalid.')
+        print(('The sampling domain "' + sampling_domain + '" defined as input ' \
+              + 'to the "dispersion_data()" function is invalid.'))
         sys.exit(1)
 
     if (dispform == 1):
@@ -424,14 +424,14 @@
     (waves, indices) = dispersion_data(cd, dispform, ld, sampling_domain=sampling_domain)
 
     if (wavemin < waves.min()):
-        print('index_coeffs(): The minimum wavelength (' + str(wavemin) +
+        print(('index_coeffs(): The minimum wavelength (' + str(wavemin) +
               'nm)\n is outside the transmission range given for the glass (' +
-              str(waves.min()) + '--' + str(waves.max()) + ' nm)')
+              str(waves.min()) + '--' + str(waves.max()) + ' nm)'))
         return(zeros(8), zeros(alen(waves)), waves)
     if (wavemax > waves.max()):
-        print('index_coeffs(): The maximum wavelength (' + str(wavemax) +
+        print(('index_coeffs(): The maximum wavelength (' + str(wavemax) +
               'nm)\n is outside the transmission range given for the glass (' +
-              str(waves.min()) + '--' + str(waves.max()) + ' nm)')
+              str(waves.min()) + '--' + str(waves.max()) + ' nm)'))
         return(zeros(8), zeros(alen(waves)), waves)
 
     okay = (waves >= wavemin) & (waves <= wavemax)
@@ -467,8 +467,8 @@
         H[:,7] = 0.0625 * (429.0 * x**7 - 693.0 * x**5 + 315.0 * x**3 - 35.0 * x)
         H[:,8] = 0.0078125 * (6435.0 * x**8 - 12012.0 * x**6 + 6930.0 * x**4 - 1260.0 * x**2 + 35.0)
     else:
-        print('The basis chosen (' + basis + ') is invalid for the ' + \
-              '"index_coeffs()" function.')
+        print(('The basis chosen (' + basis + ') is invalid for the ' + \
+              '"index_coeffs()" function.'))
         sys.exit(3)
 
     g = indices
@@ -501,18 +501,18 @@
 
 ## =============================================================================
 def print_glass_report(glass_dict):
-    print('name     = ' + str(glass_dict['name']))
-    print('nd       = ' + str(glass_dict['nd']))
-    print('vd       = ' + str(glass_dict['vd']))
-    print('dispform = ' + str(glass_dict['dispform']))
-    print('tce      = ' + str(glass_dict['tce']))
-    print('density  = ' + str(glass_dict['density']))
-    print('dpgf     = ' + str(glass_dict['dpgf']))
-    print('cd       = ' + str(glass_dict['cd']))
-    print('td       = ' + str(glass_dict['td']))
-    print('od       = ' + str(glass_dict['od']))
-    print('ld       = ' + str(glass_dict['ld']))
-    if 'coeffs' in glass_dict: print('coeffs   = ' + str(glass_dict['coeffs']))
+    print(('name     = ' + str(glass_dict['name'])))
+    print(('nd       = ' + str(glass_dict['nd'])))
+    print(('vd       = ' + str(glass_dict['vd'])))
+    print(('dispform = ' + str(glass_dict['dispform'])))
+    print(('tce      = ' + str(glass_dict['tce'])))
+    print(('density  = ' + str(glass_dict['density'])))
+    print(('dpgf     = ' + str(glass_dict['dpgf'])))
+    print(('cd       = ' + str(glass_dict['cd'])))
+    print(('td       = ' + str(glass_dict['td'])))
+    print(('od       = ' + str(glass_dict['od'])))
+    print(('ld       = ' + str(glass_dict['ld'])))
+    if 'coeffs' in glass_dict: print(('coeffs   = ' + str(glass_dict['coeffs'])))
     return
 
 ## =============================================================================
@@ -599,7 +599,7 @@
 ## =============================================================================
 def find_catalog(glasscat, glassname):
     for catalog in glasscat:
-        if glassname in glasscat[catalog].keys():
+        if glassname in list(glasscat[catalog].keys()):
             catalog1 = catalog
             break
     return(catalog)
--- ./PYME/misc/sqlitendarray.py	(original)
+++ ./PYME/misc/sqlitendarray.py	(refactored)
@@ -30,7 +30,7 @@
 import sqlite3
 from numpy import ndarray
 import zlib
-import cPickle as pickle
+import pickle as pickle
 
 #teach sqlite about numpy arrays
 def adapt_numarray(array):
--- ./PYME/misc/startCommentify.py	(original)
+++ ./PYME/misc/startCommentify.py	(refactored)
@@ -59,13 +59,13 @@
 
           #f = open()
 
-          print '------------------------------------------------'
-          print fn
-          print '------------------------------------------------\n'
+          print('------------------------------------------------')
+          print(fn)
+          print('------------------------------------------------\n')
 
-          print text[:500]
+          print(text[:500])
 
-          res = raw_input('Add header to file? y/n:')
+          res = input('Add header to file? y/n:')
 
           if res.upper() == 'Y':
               f = open(os.path.join(dirname, fn), 'w')
--- ./PYME/misc/tempLoggerDB.py	(original)
+++ ./PYME/misc/tempLoggerDB.py	(refactored)
@@ -23,7 +23,7 @@
 #!/usr/bin/python
 from PYME.Acquire.Hardware.DigiData.DigiDataClient import getDDClient
 import time
-import tempDB
+from . import tempDB
 import subprocess
 
 #check to see if we're already running
--- ./PYME/misc/tifffile.py	(original)
+++ ./PYME/misc/tifffile.py	(refactored)
@@ -98,7 +98,7 @@
 
 """
 
-from __future__ import division, print_function
+
 
 import sys
 import os
@@ -363,7 +363,7 @@
 
         # read custom tags
         pos = fhandle.tell()
-        for name, readtag in CUSTOM_TAGS.values():
+        for name, readtag in list(CUSTOM_TAGS.values()):
             if name in tags and readtag:
                 value = readtag(fhandle, byte_order, tags[name])
                 if isinstance(value, dict):  # numpy.core.records.record
@@ -374,7 +374,7 @@
         # read LSM info subrecords
         if self.is_lsm:
             pos = fhandle.tell()
-            for name, reader in CZ_LSM_INFO_READERS.items():
+            for name, reader in list(CZ_LSM_INFO_READERS.items()):
                 try:
                     offset = self.cz_lsm_info["offset_"+name]
                 except KeyError:
@@ -396,7 +396,7 @@
         """
         tags = self.tags
 
-        for code, (name, default, dtype, count, validate) in TIFF_TAGS.items():
+        for code, (name, default, dtype, count, validate) in list(TIFF_TAGS.items()):
             if not (name in tags or default is None):
                 tags[name] = TIFFtag(code, dtype=dtype, count=count,
                                      value=default, name=name)
@@ -751,7 +751,7 @@
         s = []
         #sortbycode = lambda a, b: cmp(a.code, b.code)
         #for tag in sorted(self.values(), sortbycode):
-        for tag in sorted(self.values(), key=lambda x: x.code):
+        for tag in sorted(list(self.values()), key=lambda x: x.code):
             typecode = "%i%s" % (tag.count * int(tag.dtype[0]), tag.dtype[1])
             line = "* %i %s (%s) %s" % (tag.code, tag.name, typecode,
                                         str(tag.value).split('\n', 1)[0])
--- ./PYME/misc/wxPlotPanel.py	(original)
+++ ./PYME/misc/wxPlotPanel.py	(refactored)
@@ -27,9 +27,9 @@
         self.parent = parent
 
         # initialize Panel
-        if 'id' not in kwargs.keys():
+        if 'id' not in list(kwargs.keys()):
             kwargs['id'] = wx.ID_ANY
-        if 'style' not in kwargs.keys():
+        if 'style' not in list(kwargs.keys()):
             kwargs['style'] = wx.NO_FULL_REPAINT_ON_RESIZE
         wx.Panel.__init__( self, parent, **kwargs )
 
--- ./PYME/misc/zemax.py	(original)
+++ ./PYME/misc/zemax.py	(refactored)
@@ -7,7 +7,7 @@
 from PYME.misc import lzw
 import numpy as np
 
-import read_agf
+from . import read_agf
 
 def decompZar(filename):
     '''zemax .zar files are a series of concatenated, LZW compressed text-format 
@@ -154,7 +154,7 @@
         pos = np.array(position)
         
         l = sum([s.disz for s in surfs[:-1]])
-        print l
+        print(l)
         
         if fb == None and f == None:
             #calculate length of lens
@@ -170,18 +170,18 @@
         
         if flip:
             z0 = -z0 - l
-            i_s = range(len(surfs))
+            i_s = list(range(len(surfs)))
             for i in i_s[::-1]:
-                print i
+                print(i)
                 s = surfs[i]
                 glass = self.surfaces[i].glass
                 outSurfs.append(pyo.SphericalSurface('ZMX_%d'%i, 1,np.ones(3)*float(s.diam[0]),pyo.Placement((z0 - 0)*d + pos,d),glass, -s.radius))
-                print z0, s.disz
+                print(z0, s.disz)
                 z0 += self.surfaces[i].disz         
         else:
             for i, s in enumerate(surfs):
                 outSurfs.append(pyo.SphericalSurface('ZMX_%d'%i, 1,np.ones(3)*float(s.diam[0]),pyo.Placement((z0 - 0)*d + pos,d),s.glass, s.radius))
-                print z0, s.disz
+                print(z0, s.disz)
                 z0 += s.disz
                 
             
@@ -194,14 +194,14 @@
     glasses = {}
     
     #find all the glass catalogs    
-    glass_cats = [n for n in components.keys() if n.endswith('.AGF')]
+    glass_cats = [n for n in list(components.keys()) if n.endswith('.AGF')]
     for gc in glass_cats:
         glasses.update(read_agf.read_cat_from_string(components[gc]))
         
-    print glasses.keys()
+    print(list(glasses.keys()))
         
     #find all components (probably only one)
-    zmxs = [ZMX(components[n], glasses) for n in components.keys() if (n.endswith('.ZMX') or n.endswith('.zmx'))]
+    zmxs = [ZMX(components[n], glasses) for n in list(components.keys()) if (n.endswith('.ZMX') or n.endswith('.zmx'))]
     
     return zmxs, glasses
             
--- ./PYME/misc/zernike.py	(original)
+++ ./PYME/misc/zernike.py	(refactored)
@@ -114,7 +114,7 @@
     ress = []
     for n in range(maxN):
         c, res, rand, sing = projectZ(im, n, weights)
-        print '%d\t%s: %3.2f   residual=%3.2f' % (n, NameByNumber[n], c, res)
+        print('%d\t%s: %3.2f   residual=%3.2f' % (n, NameByNumber[n], c, res))
         coeffs.append(c[0])
         ress.append(res)
         
--- ./PYME/pad/__init__.py	(original)
+++ ./PYME/pad/__init__.py	(refactored)
@@ -2,10 +2,10 @@
 #
 
 # Get documentation string:
-from info_pad import __doc__
+from .info_pad import __doc__
 
 # Import symbols from sub-module:
-from pad import *
+from .pad import *
 
 def test(level=1, verbosity=1):
     from numpy.testing import NumpyTest
--- ./PYME/pad/pad.py	(original)
+++ ./PYME/pad/pad.py	(refactored)
@@ -91,11 +91,11 @@
             and len(pad_width) == shapelen):
         pw = pad_width
     if (isinstance(pad_width, (tuple, list))
-            and isinstance(pad_width[0], (int, float, long))
+            and isinstance(pad_width[0], (int, float))
             and len(pad_width) == 1):
         pw = ((pad_width[0], pad_width[0]), ) * shapelen
     if (isinstance(pad_width, (tuple, list))
-            and isinstance(pad_width[0], (int, float, long))
+            and isinstance(pad_width[0], (int, float))
             and len(pad_width) == 2):
         pw = (pad_width, ) * shapelen
     if pw == None:
@@ -119,7 +119,7 @@
     else:
         kw['stat_len'] = None
     pad_width = __validate_tuple(nmatrix, pad_width)
-    rank = range(len(nmatrix.shape))
+    rank = list(range(len(nmatrix.shape)))
     total_dim_increase = [np.sum(pad_width[i]) for i in rank]
     offset_slices = [slice(pad_width[i][0],
                            pad_width[i][0] + nmatrix.shape[i])
@@ -662,9 +662,9 @@
     this module.
     '''
     arr = np.arange(100)
-    print arr
-    print with_median(arr, (3, ))
-    print with_constant(arr, (-25, 20), (10, 20))
+    print(arr)
+    print(with_median(arr, (3, )))
+    print(with_constant(arr, (-25, 20), (10, 20)))
     arr = np.arange(30)
     arr = np.reshape(arr, (6, 5))
-    print with_mean(arr, pad_width=((2, 3), (3, 2), (4, 5)), stat_len=(3, ))
+    print(with_mean(arr, pad_width=((2, 3), (3, 2), (4, 5)), stat_len=(3, )))
--- ./PYME/scripts/h5r-thumbnailer.py	(original)
+++ ./PYME/scripts/h5r-thumbnailer.py	(refactored)
@@ -48,17 +48,17 @@
 
     #print f1.keys()
 
-    if 'fitResults_Ag' in f1.keys():
+    if 'fitResults_Ag' in list(f1.keys()):
         #if we used the splitter set up a mapping so we can filter on total amplitude and ratio
         f1_ = inpFilt.mappingFilter(f1, A='fitResults_Ag + fitResults_Ar', gFrac='fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
         split = True
-    elif 'fitResults_sigma' in f1.keys():
+    elif 'fitResults_sigma' in list(f1.keys()):
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
     else:
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5])
 
-    if 'fitResults_z0' in f1.keys():
+    if 'fitResults_z0' in list(f1.keys()):
         threeD = True
 
     if 'Events' in dir(f1.h5f.root):
--- ./PYME/scripts/sf-thumbnailer.py	(original)
+++ ./PYME/scripts/sf-thumbnailer.py	(refactored)
@@ -30,7 +30,7 @@
 import sys
 import gnomevfs
 
-import cPickle
+import pickle
 
 import matplotlib
 matplotlib.use('Agg')
@@ -50,7 +50,7 @@
 
 #def generateThumbnail(inputFile, thumbsize):
 fid = open(inputFile)
-spx, spy = cPickle.load(fid)
+spx, spy = pickle.load(fid)
 fid.close()
 
 f = figure(figsize=(thumbSize/dpi, 0.5*thumbSize/dpi))
--- ./PYME/scripts/urlOpener.py	(original)
+++ ./PYME/scripts/urlOpener.py	(refactored)
@@ -35,20 +35,20 @@
 nasPrefix = '/mnt/NasData/'
 
 micrPath = micrPrefix
-if 'PYMEMICRPATH' in os.environ.keys():
+if 'PYMEMICRPATH' in list(os.environ.keys()):
     micrPath = os.environ['PYMEMICRPATH']
 
 nasPath = nasPrefix
-if 'PYMENASPATH' in os.environ.keys():
+if 'PYMENASPATH' in list(os.environ.keys()):
     nasPath = os.environ['PYMENASPATH']
 
 PYMEDir = os.path.split(os.path.split(os.path.abspath(nameUtils.__file__))[0])[0]
-print PYMEDir
+print(PYMEDir)
 #print __file__
 
 
 def openFile(url):
-    print url
+    print(url)
         
     
     if url.startswith(micrPrefix):
@@ -59,7 +59,7 @@
         filename = url
         
 
-    print filename
+    print(filename)
 
     if os.path.exists(filename):
         #return HttpResponse("Thumbnail for %s." % filename)
--- ./PYME/scripts/view3d.py	(original)
+++ ./PYME/scripts/view3d.py	(refactored)
@@ -23,7 +23,7 @@
 import sys
 import socket
 from optparse import OptionParser
-import SocketServer
+import socketserver
 
 op = OptionParser(usage = 'usage: %s [options] [filename]' % sys.argv[0])
 
@@ -65,7 +65,7 @@
 
         return 1
 
-class MyTCPHandler(SocketServer.BaseRequestHandler):
+class MyTCPHandler(socketserver.BaseRequestHandler):
     """
     The RequestHandler class for our server.
 
@@ -77,8 +77,8 @@
     def handle(self):
         # self.request is the TCP socket connected to the client
         data = self.request.recv(1024).strip()
-        print "%s wrote:" % self.client_address[0]
-        print data
+        print("%s wrote:" % self.client_address[0])
+        print(data)
         
         wx.CallAfter(OpenFile, data.split('\t'), True)
 
@@ -96,7 +96,7 @@
         
         app = MyApp(0)
 
-        sockServ = SocketServer.TCPServer(('localhost',9898), MyTCPHandler)
+        sockServ = socketserver.TCPServer(('localhost',9898), MyTCPHandler)
 
         thrd = threading.Thread(target=sockServ.serve_forever)
         thrd.start()
--- ./PYME/shmarray/shmTest.py	(original)
+++ ./PYME/shmarray/shmTest.py	(refactored)
@@ -23,7 +23,7 @@
 import numpy.random
 import multiprocessing
 import multiprocessing.sharedctypes
-import shmarray
+from . import shmarray
 import numpy
 
 
@@ -55,7 +55,7 @@
 
 pool = multiprocessing.Pool(4, initFuzz, (data,))
 
-i = pool.map(doFuzz, range(0, 100), chunksize=10)
+i = pool.map(doFuzz, list(range(0, 100)), chunksize=10)
 
 pool.close()
 
@@ -66,4 +66,4 @@
 p.start()
 p.join()
 
-print data
+print(data)
--- ./PYME/shmarray/shmarray.py	(original)
+++ ./PYME/shmarray/shmarray.py	(refactored)
@@ -97,7 +97,7 @@
     #otherwise create a suitably sized byte array
     dt = dtype.char
 
-    if not dt in sharedctypes.typecode_to_type.keys():
+    if not dt in list(sharedctypes.typecode_to_type.keys()):
         dt = 'b'
         N *= dtype.itemsize
 
--- ./build/scripts.linux-x86_64-2.6/h5r-thumbnailer.py	(original)
+++ ./build/scripts.linux-x86_64-2.6/h5r-thumbnailer.py	(refactored)
@@ -48,17 +48,17 @@
 
     #print f1.keys()
 
-    if 'fitResults_Ag' in f1.keys():
+    if 'fitResults_Ag' in list(f1.keys()):
         #if we used the splitter set up a mapping so we can filter on total amplitude and ratio
         f1_ = inpFilt.mappingFilter(f1, A='fitResults_Ag + fitResults_Ar', gFrac='fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
         split = True
-    elif 'fitResults_sigma' in f1.keys():
+    elif 'fitResults_sigma' in list(f1.keys()):
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
     else:
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5])
 
-    if 'fitResults_z0' in f1.keys():
+    if 'fitResults_z0' in list(f1.keys()):
         threeD = True
 
     if 'Events' in dir(f1.h5f.root):
--- ./build/scripts.linux-x86_64-2.6/sf-thumbnailer.py	(original)
+++ ./build/scripts.linux-x86_64-2.6/sf-thumbnailer.py	(refactored)
@@ -30,7 +30,7 @@
 import sys
 import gnomevfs
 
-import cPickle
+import pickle
 
 import matplotlib
 matplotlib.use('Agg')
@@ -50,7 +50,7 @@
 
 #def generateThumbnail(inputFile, thumbsize):
 fid = open(inputFile)
-spx, spy = cPickle.load(fid)
+spx, spy = pickle.load(fid)
 fid.close()
 
 f = figure(figsize=(thumbSize/dpi, 0.5*thumbSize/dpi))
--- ./build/scripts.linux-x86_64-2.6/urlOpener.py	(original)
+++ ./build/scripts.linux-x86_64-2.6/urlOpener.py	(refactored)
@@ -35,20 +35,20 @@
 nasPrefix = '/mnt/NasData/'
 
 micrPath = micrPrefix
-if 'PYMEMICRPATH' in os.environ.keys():
+if 'PYMEMICRPATH' in list(os.environ.keys()):
     micrPath = os.environ['PYMEMICRPATH']
 
 nasPath = nasPrefix
-if 'PYMENASPATH' in os.environ.keys():
+if 'PYMENASPATH' in list(os.environ.keys()):
     nasPath = os.environ['PYMENASPATH']
 
 PYMEDir = os.path.split(os.path.split(os.path.abspath(nameUtils.__file__))[0])[0]
-print PYMEDir
+print(PYMEDir)
 #print __file__
 
 
 def openFile(url):
-    print url
+    print(url)
         
     
     if url.startswith(micrPrefix):
@@ -59,7 +59,7 @@
         filename = url
         
 
-    print filename
+    print(filename)
 
     if os.path.exists(filename):
         #return HttpResponse("Thumbnail for %s." % filename)
--- ./build/scripts.linux-x86_64-2.6/view3d.py	(original)
+++ ./build/scripts.linux-x86_64-2.6/view3d.py	(refactored)
@@ -23,7 +23,7 @@
 import sys
 import socket
 from optparse import OptionParser
-import SocketServer
+import socketserver
 
 op = OptionParser(usage = 'usage: %s [options] [filename]' % sys.argv[0])
 
@@ -65,7 +65,7 @@
 
         return 1
 
-class MyTCPHandler(SocketServer.BaseRequestHandler):
+class MyTCPHandler(socketserver.BaseRequestHandler):
     """
     The RequestHandler class for our server.
 
@@ -77,8 +77,8 @@
     def handle(self):
         # self.request is the TCP socket connected to the client
         data = self.request.recv(1024).strip()
-        print "%s wrote:" % self.client_address[0]
-        print data
+        print("%s wrote:" % self.client_address[0])
+        print(data)
         
         wx.CallAfter(OpenFile, data.split('\t'), True)
 
@@ -96,7 +96,7 @@
         
         app = MyApp(0)
 
-        sockServ = SocketServer.TCPServer(('localhost',9898), MyTCPHandler)
+        sockServ = socketserver.TCPServer(('localhost',9898), MyTCPHandler)
 
         thrd = threading.Thread(target=sockServ.serve_forever)
         thrd.start()
--- ./build/scripts.linux-x86_64-2.7/h5r-thumbnailer.py	(original)
+++ ./build/scripts.linux-x86_64-2.7/h5r-thumbnailer.py	(refactored)
@@ -48,17 +48,17 @@
 
     #print f1.keys()
 
-    if 'fitResults_Ag' in f1.keys():
+    if 'fitResults_Ag' in list(f1.keys()):
         #if we used the splitter set up a mapping so we can filter on total amplitude and ratio
         f1_ = inpFilt.mappingFilter(f1, A='fitResults_Ag + fitResults_Ar', gFrac='fitResults_Ag/(fitResults_Ag + fitResults_Ar)')
         f2 = inpFilt.resultsFilter(f1_, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
         split = True
-    elif 'fitResults_sigma' in f1.keys():
+    elif 'fitResults_sigma' in list(f1.keys()):
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5], sig=[100/2.35, 350/2.35])
     else:
         f2 = inpFilt.resultsFilter(f1, error_x=[0,30], A=[5, 1e5])
 
-    if 'fitResults_z0' in f1.keys():
+    if 'fitResults_z0' in list(f1.keys()):
         threeD = True
 
     if 'Events' in dir(f1.h5f.root):
--- ./build/scripts.linux-x86_64-2.7/sf-thumbnailer.py	(original)
+++ ./build/scripts.linux-x86_64-2.7/sf-thumbnailer.py	(refactored)
@@ -30,7 +30,7 @@
 import sys
 import gnomevfs
 
-import cPickle
+import pickle
 
 import matplotlib
 matplotlib.use('Agg')
@@ -50,7 +50,7 @@
 
 #def generateThumbnail(inputFile, thumbsize):
 fid = open(inputFile)
-spx, spy = cPickle.load(fid)
+spx, spy = pickle.load(fid)
 fid.close()
 
 f = figure(figsize=(thumbSize/dpi, 0.5*thumbSize/dpi))
--- ./build/scripts.linux-x86_64-2.7/urlOpener.py	(original)
+++ ./build/scripts.linux-x86_64-2.7/urlOpener.py	(refactored)
@@ -35,20 +35,20 @@
 nasPrefix = '/mnt/NasData/'
 
 micrPath = micrPrefix
-if 'PYMEMICRPATH' in os.environ.keys():
+if 'PYMEMICRPATH' in list(os.environ.keys()):
     micrPath = os.environ['PYMEMICRPATH']
 
 nasPath = nasPrefix
-if 'PYMENASPATH' in os.environ.keys():
+if 'PYMENASPATH' in list(os.environ.keys()):
     nasPath = os.environ['PYMENASPATH']
 
 PYMEDir = os.path.split(os.path.split(os.path.abspath(nameUtils.__file__))[0])[0]
-print PYMEDir
+print(PYMEDir)
 #print __file__
 
 
 def openFile(url):
-    print url
+    print(url)
         
     
     if url.startswith(micrPrefix):
@@ -59,7 +59,7 @@
         filename = url
         
 
-    print filename
+    print(filename)
 
     if os.path.exists(filename):
         #return HttpResponse("Thumbnail for %s." % filename)
--- ./build/scripts.linux-x86_64-2.7/view3d.py	(original)
+++ ./build/scripts.linux-x86_64-2.7/view3d.py	(refactored)
@@ -23,7 +23,7 @@
 import sys
 import socket
 from optparse import OptionParser
-import SocketServer
+import socketserver
 
 op = OptionParser(usage = 'usage: %s [options] [filename]' % sys.argv[0])
 
@@ -65,7 +65,7 @@
 
         return 1
 
-class MyTCPHandler(SocketServer.BaseRequestHandler):
+class MyTCPHandler(socketserver.BaseRequestHandler):
     """
     The RequestHandler class for our server.
 
@@ -77,8 +77,8 @@
     def handle(self):
         # self.request is the TCP socket connected to the client
         data = self.request.recv(1024).strip()
-        print "%s wrote:" % self.client_address[0]
-        print data
+        print("%s wrote:" % self.client_address[0])
+        print(data)
         
         wx.CallAfter(OpenFile, data.split('\t'), True)
 
@@ -96,7 +96,7 @@
         
         app = MyApp(0)
 
-        sockServ = SocketServer.TCPServer(('localhost',9898), MyTCPHandler)
+        sockServ = socketserver.TCPServer(('localhost',9898), MyTCPHandler)
 
         thrd = threading.Thread(target=sockServ.serve_forever)
         thrd.start()
--- ./doc/conf.py	(original)
+++ ./doc/conf.py	(refactored)
@@ -37,8 +37,8 @@
 master_doc = 'index'
 
 # General information about the project.
-project = u'PYME'
-copyright = u'2010, David Baddeley'
+project = 'PYME'
+copyright = '2010, David Baddeley'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
@@ -172,8 +172,8 @@
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title, author, documentclass [howto/manual]).
 latex_documents = [
-  ('index', 'PYME.tex', u'PYME Documentation',
-   u'David Baddeley', 'manual'),
+  ('index', 'PYME.tex', 'PYME Documentation',
+   'David Baddeley', 'manual'),
 ]
 
 # The name of an image file (relative to this directory) to place at the top of
